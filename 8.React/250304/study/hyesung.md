## 회고

- 함수형 리액트 컴포넌트
- 훅 함수

둘 다 함수지만, 데이터 반환 타입이 다름

### 시야가 좁음

`예제를 많이 봐두면 좋음`  

1. 다른 리액트 사용자들은 특정 기능을 어떻게 사용하고 있나?

`useNavigate` 로 보자.

기존의 리액트 유저들은 특정 훅 함수를 어떤식으로 사용하고 있나?
=> 아 useNavigate같은 경우에는 핸들러 함수에 선언을 하고 경로 넣고
해당 핸들러 함수를 특정 태그 이벤트에 등록하는 형식으로 쓰는구나?
=> 그러면 이제 본인 상황에 빗대는거야.

`/`로 클릭했을 때 분기점이 나뉘니까....컴포넌트를 선언해야겠지?
라우트 매핑해야하려면 컴포넌트를 넣어야 하니까!

2. 컴포넌트를 만들어봐.

```jsx
<Home/>

const Home = () => {}
```

만들었다 치고...아 그러면 컴포넌트가 최초 `마운트` 될 때
분기점을 가지고 교체 렌더링 시켜야겠당

```jsx
const Home = () => {
    useEffect(() => {
        if(user) {

        } else {
            
        }
    }, [])
    return (
        <></>
    )
}
```

## 자 오늘 수업으로 넘어가자 뭐가 어려웠어?

- useCallback이 너무 어려움.

한 가지 팁을 주자면, 렌더링이 언제 되고, 언제 종료되는지
=> 오늘 수업으로 인해서 함수형 컴포넌트는 함수다.
=> 상태가 변경될때마다 다시 생성되는걸 인지한다.  
=> 상태가 변경되는걸 감지하느냐? 그리고 감지한다면, 특정 함수를
생성시킬거냐 아니면 생성시키지 않을거냐
=> 최적화

이게 중요한거임.
위의 기준으로 공부를 하면 자연스럽게 따라옴.

## **핵심 포인트 정리**

1. **함수형 컴포넌트는 함수다**  
   → 호출될 때마다 내부 코드가 다시 생성됨 (렌더링).  

2. **상태(state)가 변경될 때마다 다시 생성됨**  
   → `useState`나 `useEffect`의 값이 변하면 리렌더링됨.  

3. **리렌더링될 때 함수도 새로 만들어진다**  
   → 내부에서 선언된 함수는 **렌더링될 때마다 새롭게 생성됨**.  

4. **그럼, 특정 함수를 매번 새로 만들 필요가 있는가?**  
   - 변경될 필요가 없으면 **굳이 새로 만들지 말고 재사용하면 된다!**  
   - 이때 사용하는 것이 `useCallback`.  

5. **`useCallback`은 특정 함수가 다시 생성될지, 안 될지를 결정하는 최적화 도구**  
   - **상태가 변할 때마다 새 함수를 생성할 건지?**  
   - **아니면 기존 함수를 유지할 건지?**  
   - 이걸 **의존성 배열을 보고 결정하는 것**이 `useCallback`.  

---

### **이 기준으로 공부하면 자연스럽게 이해됨**
- 리렌더링이 언제 되는지?
- 상태 변경이 발생할 때, 함수가 다시 생성되는지?
- 불필요한 함수 생성을 방지할 필요가 있는지?

이 흐름을 이해하면, **`useCallback` 자체를 어렵게 생각할 필요 없음**.  
그냥 **"이 함수, 매번 새로 만들 필요 있어? 없으면 `useCallback`으로 감싸자"** 이 정도로 보면 됨!

## useContext

전역 컴포넌트로 감싸서 사용하는건 이해하겠는데....
그냥 이해가 안됌

1. 직관적이지 못함

```jsx
<Home data={data}/>
```

=>

```jsx
<AuthProvider 여기에프롭스전달하는것도아닌데어떻게전역에서접근가능함?/>
```

2. 진입점 이해도 부족

무조건! 진입점은 index.jsx => App.jsx야

그러면 이걸 이해하려면 어떻게 납득시켜야 할까?


- `AuthProvider`는 전역 상태를 감싸는 역할
- useAuth()는 Context 값을 쉽게 가져오는 커스텀 훅
- `AuthProvider`로 감싸면 모든 컴포넌트에서 전역 상태를 사용 가능
- props 없이 useAuth()로 전역 상태를 직접 가져올 수 있음