# React.memo의 탄생 배경과 필요성

## 리액트의 렌더링 방식

리액트는 상태나 프롭스가 변경되면 해당 컴포넌트(Counter)와 하위 컴포넌트(Child)를 다시 렌더링하는 방식

1. `useState` 를 사용하여 상태를 변경하면, React는 해당 컴포넌트를 다시 호출한다.
=> 재평가 재실행
2. 함수형 컴포넌트는 **전체 함수가 다시 실행**되며, `return`이 재평가된다.
3. 변경된 가상 DOM(Virtual DOM)을 기존 가상 DOM과 비교(Diffing)하여 실제 DOM에 반영한다.
4. 부모 컴포넌트가 렌더링되면 기본적으로 자식 컴포넌트도 함께 렌더링된다.

## 문제점

### 불필요한 렌더링 문제

- `count` 상태만 변경되었지만, `Counter`가 리렌더링되면서 `Child`도 함께 리렌더링됨.
- `Child`는 변하지 않았는데도, 부모가 렌더링될 때 불필요하게 다시 렌더링됨.

## React memo가 탄생

React 16.6(2018년)에서 리액트 메모 도입.  
불필요한 자식 컴포넌트의 리렌더링을 방지하기 위한 성능

### 동작 방식

1. `memo`는 이전 렌더링의 프롭을 기억(메모이제이션)한다.
2. 새로운 렌더링이 요청되면 **이전 프롭과 현재 프롭을 비교**한다.
3. **프롭이 변하지 않았다면, 기존 결과`값`를 재사용하고 렌더링을 생략한다.**

즉, 값을 비교해서 값이 바뀌면 리렌더링 함!


