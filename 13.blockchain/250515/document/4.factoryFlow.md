# Factory.sol 분석 – DAO를 생산하는 컨트랙트

오늘 우리는 어제 사용했던 `DAO.sol`을 그대로 가져옵니다.
하지만 오늘은 **그 컨트랙트를 직접 배포하지 않고**,
→ **Factory라는 구조를 통해 생성합니다.**

왜냐하면…

> 지금부터 DAO는 단순히 "하나 배포해서 쓰는 코드"가 아니라,
> **구조화되고 기록되며 관리되는 대상**이기 때문입니다.

바로 그 생성을 담당하는 컨트랙트,
오늘의 새로운 주인공이 등장합니다:

> **Factory.sol**

---

이제 우리는 이 두 파일로 수업을 진행하게 됩니다:

- `DAO.sol`: 우리가 만들고 싶은 DAO 구조의 정의
- `Factory.sol`: 그 DAO들을 반복해서 생성하고, 그 이력을 온체인에 구조화하는 컨트랙트

## 3-0. 먼저 생각해봅시다

> “안건이 생기면 DAO 컨트랙트를 하나 만들고 싶다.”
> “그리고 나중에 그 컨트랙트의 주소(CA)를 찾아서 사용하고 싶다.”

그렇다면 우리가 필요한 건?

→ **컨트랙트를 생성하고**,
→ **그 주소를 기록해두는 저장소**입니다.

## 3-1. 그래서 필요한 상태가 선언됩니다

```solidity
address[] public deployedDAOs;
mapping(address => address[]) public createdBy;
```

- `deployedDAOs`: 지금까지 만들어진 **모든 DAO의 주소 목록**입니다.
- `createdBy`: 누가 어떤 DAO들을 만들었는지 **사용자별 기록**입니다.

이제 이 두 상태 변수는
→ **DAO를 만들고 추적하는 핵심 저장소**가 됩니다.

## 3-2. 컨트랙트를 만들고, 그 주소를 저장하는 이유

```solidity
DAO dao = new DAO(msg.sender);
deployedDAOs.push(address(dao));
```

이 코드에서 일어나는 일은 단순하지만 아주 강력합니다.

1. `DAO dao = new DAO(msg.sender);`

   - **컨트랙트를 하나 새로 배포**합니다.
   - 생성자 인자로 `msg.sender`를 넘겨줌으로써,
     → **이 DAO의 의장을 설정**합니다.
   - 다시 말해, **안건을 제안한 사람 = DAO를 만든 사람 = 의장**입니다.

2. `deployedDAOs.push(address(dao));`

   - 생성된 DAO 컨트랙트는 **이더리움 네트워크에 배포되었기 때문에 고유 주소(CA)를 가집니다.**
   - 그 주소를 `address(dao)`로 변환하여
     → `deployedDAOs` 배열에 저장합니다.

> 단순한 변수 할당이 아닙니다.
> 이건 **“하나의 조직(DAO)이 탄생하고, 그 기록이 남는 구조”**를 코드로 만든 것입니다.

## 3-3. 컨트랙트 조회

```solidity
function getDAO(uint index) public view returns (address) {
    require(index < deployedDAOs.length, "Invalid index");
    return deployedDAOs[index];
}
```

### 이 함수는 무엇을 하는가?

- `deployedDAOs` 배열에 저장된 DAO 주소 중
- 사용자가 지정한 인덱스(`index`)에 해당하는 DAO 주소를 반환합니다.
- 단, 범위를 초과한 요청에 대해선 오류를 반환합니다.

---

### 왜 이 함수가 중요한가?

1. **DAO 구조를 탐색 가능한 구조로 만듭니다.**

   - 단순히 배포된 DAO를 만들고 끝나는 것이 아니라,
     → 그 목록을 **인덱싱(indexing)** 하여 조회할 수 있도록 합니다.

   - 이는 DAO 생태계를 "이름도 없이 생성된 무작위 컨트랙트들의 집합"이 아니라,
     → **정돈되고 순회 가능한 목록**으로 만들어줍니다.

2. **프론트엔드 연동을 위한 기본 단위입니다.**

   - 프론트에서는 사용자의 DAO를 순회하거나,
   - 전체 DAO 목록을 리스트업할 때 반드시 이런 조회 기능이 필요합니다.

3. **블록체인 위에 정렬된 레지스트리 구조로 활용됩니다.**

   - 이 배열은 단순한 데이터가 아니라,
   - “블록체인 위에 기록된 조직의 생성 이력”입니다.
   - 즉, **DAO라는 조직 구조가 언제, 어떤 순서로 탄생했는지를 온체인에서 추적 가능**하게 만듭니다.

---

### 예시로 이해하기

- `getDAO(0)` → 가장 처음 만든 DAO 주소
- `getDAO(2)` → 세 번째로 만들어진 DAO 주소

## 3-4. 주요 함수 흐름

이제 이 Factory는 DAO를 만들고 추적하기 위한 **기본 인터페이스**를 제공합니다:

- `createDAO()`

  - 새로운 DAO 컨트랙트를 생성합니다.
  - 의장은 현재 트랜잭션을 보낸 사람 (`msg.sender`)
  - 생성된 DAO의 주소를 두 곳에 저장:

    - `deployedDAOs` → 전체 목록
    - `createdBy[msg.sender]` → 사용자별 DAO 목록

- `getMyDAOs()`

  - 현재 사용자가 생성한 DAO 목록을 조회합니다.
  - 프론트에서 자신의 DAO들만 보고 싶을 때 유용

- `getDAO(index)`

  - 전체 DAO 목록에서 특정 DAO 주소를 가져옵니다.
  - 예: `getDAO(0)` → 첫 번째로 생성된 DAO 주소 반환

---

이제 Factory 구조의 핵심은 이해했습니다.
**다음 단계는 이 Factory를 Remix에서 실습하고,**
→ **생성된 DAO와 실제로 상호작용해보는 흐름**입니다.
