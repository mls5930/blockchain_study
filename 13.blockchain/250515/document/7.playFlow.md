# 수업 실습 시나리오 – Remix에서 DAO 생태계를 직접 구성해보기

우리는 앞서 "하나의 안건이 하나의 DAO 인스턴스로 태어나는 구조"를 설계했습니다.  
이제는 그 구조를 **직접 손으로 구현해보는 단계**입니다.  
단순히 기능을 따라 누르는 것이 아니라,

> **왜 이 흐름이 필요한지를 이해하며 실습합니다.**

## 1. DAO 생태계의 출발점 – Factory.sol 컴파일 및 배포

우리가 설계한 구조에서,  
모든 DAO는 Factory 컨트랙트로부터 태어납니다.  
즉, DAO는 스스로 존재하는 것이 아니라,

> **생성되었으며, 그 생성 내역은 추적 가능합니다.**

이를 위해 첫 단계로, **Factory 컨트랙트를 배포**합니다.

### 실습 절차:

- Remix에서 `Factory.sol`을 엽니다.
- 좌측 **"Solidity Compiler" 탭**에서 컴파일을 먼저 수행합니다.
- 이어서 **"Deploy & Run Transactions" 탭**으로 이동합니다.
- Environment는 `JavaScript VM` 또는 `Injected Provider`(메타마스크) 중 선택합니다.
- **`Factory` 컨트랙트를 선택한 뒤 Deploy 버튼을 누릅니다.**

→ 이제, DAO들을 생성할 수 있는 **공식적인 출발점(Factory)** 이 배포된 상태입니다.

## 2. 안건 하나 = DAO 하나 → `createDAO()` 호출

앞서 말했듯이,  
우리는 더 이상 `proposals[0]`, `proposals[1]` 같은 인덱스 방식으로  
여러 안건을 하나의 컨트랙트에 몰아넣지 않습니다.

이제 안건이 생기면,

> 그 안건은 하나의 DAO 인스턴스로 **독립적으로 태어나야** 합니다.

이를 위해 `createDAO()`를 호출합니다.

### 실습 절차:

- `createDAO()` 버튼을 한 번 클릭합니다.
- DAO 컨트랙트가 새롭게 배포됩니다.
- 내부적으로 다음 두 곳에 주소가 저장됩니다:

  - `deployedDAOs`: 전체 DAO 목록
  - `createdBy[msg.sender]`: 이 유저가 만든 DAO 목록

→ **이제 이 안건은 하나의 컨트랙트로 존재하게 되었습니다.**

→ 한 번이 아닌 **여러 번 반복**해서 DAO를 만들어보세요.  
→ 각각의 DAO는 독립된 컨트랙트이며, 서로 간섭하지 않습니다.

## 3. DAO 목록을 확인 – `getMyDAOs()` 호출

각 DAO는 생성과 동시에 Factory에 기록됩니다.  
우리는 그 기록을 통해,

> “내가 생성한 DAO 목록”을 불러올 수 있습니다.

### 실습 절차:

- `getMyDAOs()`를 클릭하면
- 배열 형태로 여러 DAO 주소가 반환됩니다.
- 하나의 주소를 복사해둡니다 (Ctrl+C)

→ 이 주소는 곧 **Remix에서 직접 해당 DAO에 접근하기 위한 Key**가 됩니다.

## 4. Remix의 `At Address` 기능이란?

이제 여러분은 DAO 컨트랙트의 주소(CA)를 하나 얻었습니다.
그런데 문제는…

> “지금 Remix에 배포되어 있는 건 Factory 컨트랙트뿐인데,
> 내가 방금 만든 DAO 컨트랙트에 어떻게 접근하지?”

그걸 도와주는 기능이 바로 **Remix의 `At Address`**입니다.

### 정리하면:

- `At Address`는 Remix의 기능 중 하나로,
  **"이미 네트워크에 배포된 컨트랙트"에 접근할 수 있도록 해주는 기능**입니다.
- 단, Remix가 마법처럼 모든 걸 다 해주는 건 아닙니다.
  → 우리가 어떤 코드(ABI와 바이트코드)를 기준으로 접근할지 **직접 선택**해야 합니다.

---

### 실습 절차:

1. 좌측 파일 목록에서 **`DAO.sol` 파일을 선택**합니다.
   (※ 이걸 선택하지 않으면 Remix는 이 주소가 어떤 컨트랙트인지 모르기 때문에 연결에 실패합니다.)

2. 상단 **Deploy & Run** 탭에서
   컨트랙트 목록에서 **`DAO`를 선택**합니다.

3. 하단의 **At Address 버튼**을 클릭합니다.

4. 앞서 복사한 DAO 주소(CA)를 붙여넣고 Enter를 누릅니다.

→ Remix가 해당 DAO 인스턴스와 연결된 상태가 됩니다.  
→ 이제 그 DAO는 **내가 만든 독립적인 생태계**로서 실습 가능합니다.

## 5. DAO 인스턴스 안에서 구조 흐름 실습

이제 연결된 DAO 안에서,  
의장이 멤버를 모집하고,  
안건을 만들고,  
투표를 받고,  
결과를 판정하는 흐름을 직접 실습해봅니다.

### 실습 순서:

- `setMember(address)`
  → 멤버로 승인할 주소를 지정합니다.  
  → Remix에서 계정 변경 기능으로 여러 주소를 테스트해보세요.

- `createProposal("제목")`
  → 안건을 생성합니다.  
  → 하나의 DAO 안에서도 여러 개의 안건을 만들 수 있습니다.

- `vote(id, true/false)`
  → 멤버로 등록된 계정만 투표할 수 있습니다.  
  → 찬성은 `true`, 반대는 `false`

- `finishVote(id)`
  → 의장만 호출 가능. 투표 종료

- `getResult(id)`
  → 투표가 끝났다면 결과 메시지를 반환  
  → 아직 진행 중이면 `"Voting in progress"`

## 정리

우리가 오늘 실습한 것은  
단순히 컨트랙트를 배포하고 함수만 호출하는 것이 아닙니다.

> **하나의 의사결정 단위가 독립된 생태계로 태어나고,
> 그것이 온체인에서 구조화되는 흐름을 실습한 것**입니다.

이제 여러분은 "배포된 컨트랙트와 상호작용하는 사용자"가 아니라,
**컨트랙트를 구조적으로 설계하고 구성하는 DAO 설계자**입니다.
