# 왜 오늘은 코드가 많지 않았을까?

수업을 마치고 나면, 이런 생각이 들 수도 있습니다:

> “오늘은 뭔가 손으로 쓴 코드가 별로 없는데…?”

맞습니다.
어제는 `vote`, `getResult`, `finishVote` 같은 기능을 직접 구현했습니다.
하지만 오늘은 어제보다 **더 적은 코드**,
그런데도 **더 깊은 구조**를 만들었습니다.

---

### 그 이유는 단순합니다.

> 우리는 오늘 ‘기능’을 만든 게 아니라,
> **기능이 담길 구조를 만든 것이기 때문**입니다.

어제는 "이 기능이 되나 안 되나"를 고민했습니다.
오늘은 "이 기능이 어디에 있어야 하고, 어떻게 분리되어야 하며,
무엇이 무엇을 소유해야 하는가?"를 고민했습니다.

---

같은 `vote()` 함수라도,

> "모든 안건이 공유하는 하나의 함수"로 쓸 것인가
> "각 안건마다 독립된 컨트랙트에서 실행될 것인가"는 **완전히 다른 철학**입니다.

> **의사결정을 객체로 만들고, DAO를 생태계 단위로 구조화하는 설계로 발전**한 것입니다.

# 오늘 DAO 수업은 마무리됩니다

## 오늘 우리는 무엇을 배웠나요?

- **ERC는 토큰만을 위한 게 아닙니다.**
  → 그것은 컨트랙트 간의 **합의된 약속**이며, 우리가 확장할 수 있는 **인터페이스 구조**입니다.

- **ERC는 강제가 아닙니다.**
  → 우리는 그것을 **따를 수도**, **변형할 수도**, **새롭게 정의할 수도 있습니다.**

- **DAO는 대단한 기능이 아닙니다.**
  → 그것은 **구조적 실험이자, 정치적 상상력**이자,
  → 스마트 컨트랙트를 **사람 중심 구조로 만드는 시도**입니다.

- **여러분은 블록체인 개발자라고 말하십시오.**
  → 구조를 고민하고, 분리하고, 연결하고, 실험하는
  → **Web3 생태계를 설계하는 설계자**입니다.

## 오늘 DAO는 아직 완성되지 않았습니다.

우리는 DAO를 개별화했습니다.  
하지만 질문은 남습니다:

- 찬성이 많다고 해서,
  → **그 행동은 자동으로 일어나야 할까요?**

- 구조는 만들어졌지만,
  → **실제 실행은 누가, 언제, 어떻게 합니까?**

- `vote()` → `finishVote()` → `getResult()`
  → 이 흐름을 하나의 컨트랙트로 둘 것인가,
  → 아니면 역할별로 분리할 것인가?

> 여러분은 이 질문에 답하기 위해 **다음 단계를 설계**하는 편이 좋습니다.

# 9. 다음 시간 – Proxy Pattern으로 이어지는 구조적 사고

우리는 오늘 **“DAO가 어떻게 태어나는가”**를 다뤘습니다.
다음 시간에는,

> **“그 구조가 오래 살아남기 위해 어떻게 관리될 수 있는가?”**를 다룹니다.

## 다음 시간 주제: Proxy Pattern

- 컨트랙트를 배포한 후에도 **기능을 변경할 수 있으려면?**
- 상태(state)는 유지하면서 로직만 바꾸려면?
- **가스비를 아끼면서** 컨트랙트를 복제하려면?

DAO에서 우리는
→ **역할을 분리하고 객체를 생성하는 구조를 배웠습니다.**

Proxy에서는
→ **그 구조를 안전하게 유지하고 확장하는 방법을 배웁니다.**
