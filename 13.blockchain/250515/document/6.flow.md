# 전체 실행 흐름 – "하나의 안건, 하나의 DAO"

우리가 오늘 만든 구조는 단순히 DAO 컨트랙트를 여러 개 만드는 게 아닙니다.
우리는 **안건을 구조화하고, 식별 가능하게 만들며, 독립적인 생태계로 설계**했습니다.

> 하나의 안건은 단순한 데이터가 아니라,
> **하나의 DAO 인스턴스로 태어납니다.**

## 더 이상 안건을 배열에 “우겨넣지” 않습니다

어제까지는 `proposals[0]`, `proposals[1]`처럼
→ 하나의 DAO 컨트랙트 안에 여러 안건을 담는 구조였습니다.

하지만 그 방식은 다음과 같은 한계를 가졌습니다:

- 모든 안건이 동일한 조건을 따릅니다.
- 투표 규칙을 안건마다 다르게 적용할 수 없습니다.
- 멤버 구성, 책임자 설정이 유연하지 않습니다.

## 이제 안건은 “하나의 구조”로 태어납니다

Factory 패턴을 통해 안건이 생기면
→ 그 안건은 **하나의 DAO 컨트랙트 인스턴스로 생성**됩니다.

그리고 그 DAO는 단순한 코드 블록이 아니라,
→ **고유한 책임자, 멤버, 상태, 의사결정 흐름을 갖는 독립적 존재**입니다.

## 각 DAO 인스턴스는 구조화된 생명체입니다

- **의장(Chairperson)**
  → DAO를 제안한 사람, 책임자

- **멤버(Members)**
  → 그 DAO에 승인받아 참여한 사람들

- **투표(Vote)와 종료(Finish)**
  → 해당 DAO의 룰에 따라 참여와 종료가 독립적으로 발생

- **결과(Result)**
  → 각 DAO가 자체적으로 판단하고 기록

## 구조 시각화

```
[Factory Contract]
     |
     | createDAO() 호출
     ↓
[DAO Instance A] ← 안건: 점심 예산 인상
    - chairperson: Alice
    - members: Bob, Carol
    - result: Proposal Passed

[DAO Instance B] ← 안건: 워크숍 장소 변경
    - chairperson: Dave
    - members: Erin, Frank
    - result: Proposal Rejected
```

## 이 구조가 중요한 이유

- 각 DAO는 **상태와 멤버를 독립적으로 가집니다**.
- 생성자는 언제나 **Factory로부터 나왔음을 증명**할 수 있습니다.
- 모든 DAO는 **on-chain 레지스트리로 기록되어**, 추적 가능합니다.
- 구조적으로 DAO가 “생성되고 관리되는 질서”를 갖습니다.

## 결론

우리는 지금 단지 컨트랙트를 여러 개 만드는 것이 아니라,

> **“의사결정의 단위”를 코드로 객체화하고,
> 그 객체들이 추적 가능하고, 책임을 가진 생태계로 존재할 수 있는 구조를 설계한 것**입니다.
