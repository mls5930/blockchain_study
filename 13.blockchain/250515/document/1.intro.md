# 어제 수업 복기 – 하나의 DAO, 하나의 공간

여러분, 어제 수업에서 우리는
**하나의 DAO 컨트랙트만 가지고 전체 투표 구조를 설계**해봤습니다.

`DAO.sol`이라는 단 하나의 컨트랙트를 배포한 뒤,
그 안에 다음과 같은 흐름을 모두 넣었죠:

- 안건을 만들고 (`createProposal`)
- 찬반 투표를 받고 (`vote`)
- 투표를 종료하고 (`finishVote`)
- 결과를 확인했습니다 (`getResult`)

구조가 되게 간단했죠?  
처음 배우는 사람에게는 이처럼 **단일 구조**가 매우 효과적이니까요.

---

하지만 수업이 끝나고 나서  
혹시 이런 생각이 들지 않았나요?

> "근데... 이거 실제로 쓸 수 있는 구조 맞아?"

## 하나의 컨트랙트에 모든 안건이 쌓인다는 것

어제 만든 DAO 구조는 이런 식으로 되어 있었습니다:

```solidity
mapping(uint => Proposal) public proposals;
```

- 모든 안건은 `proposals[0]`, `proposals[1]`, `proposals[2]`처럼
  → **하나의 공간에 순서대로 쌓이는 구조**였습니다.
- 안건이 10개가 되든, 100개가 되든
  → 전부 **한 컨트랙트 안에서 상태를 공유**했습니다.

## 이 구조는 처음엔 편하지만, 곧 한계가 드러납니다

- 모든 안건이 **같은 투표 조건을 따릅니다.**
  → "찬성이 더 많으면 통과"라는 고정된 기준이죠.
- 실행 조건을 바꿀 수 없습니다.
  → 안건마다 다른 규칙을 적용할 수가 없습니다.
- 투표 기록과 멤버도 전부 공유합니다.
  → 커뮤니티마다 별도 DAO를 만들 수 없습니다.

---

> **즉, 모든 결정이 한 방에 몰려 있고, 모든 기록이 한 컨트랙트에 쌓입니다.**

처음엔 이게 단순해 보여도,  
현실에서는 **분리된 조직과 독립된 투표가 필요합니다.**

## 오늘은 바로 그 한계를 넘어서 봅니다

- 안건 하나를 **하나의 컨트랙트로 만들 수 있다면?**
- 그 컨트랙트가 **자기 의장을 가지고, 자기 멤버를 관리한다면?**
- 안건마다 **다른 조건과 흐름을 가질 수 있다면?**

→ 이 질문이 오늘 수업의 시작점입니다.  
→ 바로 **DAO Factory 구조**를 통해 이 문제를 해결해봅니다.

---

다음으로 넘어가 봅시다.
**“안건을 컨트랙트로 만든다?”** 그게 무슨 뜻일까요?
