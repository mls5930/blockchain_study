# 다음 수업 준비 - 한 번 검색해보세요.

### 키워드: `delegatecall`, `Implementation`

---

## 핵심 문장

> **delegatecall이란, 로직을 대신 “부른다”는 것** > **Implementation이란, 로직을 대신 “갖고 있는 곳”이다**

다른 컨트랙트의 **코드를 내 컨텍스트(this 주소, 상태)**에서 실행한다.
delegatecall 다른로직에 있는 컨트렉트를 가져와서 실행시키지만  다른컨트렉트의 값은 변화시키지 못함. 내 변수값만 변화 가능. 하다

## 정리 기준

- `delegatecall`은 **내가 아닌 다른 컨트랙트에 있는 코드를 호출**합니다.
  하지만!

  - **내 상태(state)** 를 기준으로 실행됩니다.
  - 즉, **“로직은 저기 있는 걸 부르지만, 상태는 내 상태에 기록됩니다.”**

- `Implementation`은

  - Proxy가 “기억하고 있는” **로직의 주소**
  - Proxy는 직접 기능을 갖지 않고,
    → **모든 함수 실행을 그 Implementation에게 위임**합니다.

## 반드시 검색해서 읽어보기

아래 질문에 스스로 답해볼 수 있도록 정리해 오세요:

- `delegatecall`과 `call`의 차이는 무엇인가요?
- 왜 Proxy는 `delegatecall`을 써야만 하나요?
- 로직이 있는 Implementation이 바뀌면, 기존 상태는 어떻게 유지되나요?

---

이 두 개념은 단순한 문법이 아니라,

> 스마트 컨트랙트를 **버전 관리하고**, **진화시키고**, **유지보수하는 구조적 관점**의 핵심입니다.

> 프록시 패턴이 왜 등장했는지 이해하려면
> 이 두 키워드를 반드시 “내 말로 설명할 수 있게” 정리해 와야 합니다.
