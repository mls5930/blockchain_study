# 이제 서명하려고 합니다 – 그 전에 생각해봅시다

우리는 지금까지 **하나의 흐름을 구현**해왔습니다.
아주 구체적으로요.

- 사용자가 직접 트랜잭션을 날리지 않아도,
- 컨트랙트가 대신 실행해주는 구조를 만들자고 했고,
- 실제로 그 구조의 핵심인 `metaTransaction.sol` 컨트랙트도 작성했습니다.

이제 곧
우리는 `signMessage()`를 호출하고,
사용자의 의사를 **서명이라는 형태로 기록**하게 됩니다.

---

하지만 그 전에,  
한 걸음 뒤로 물러서서 **“우리가 지금 무엇을 하고 있는가”**를 다시 짚어야 합니다.

## 개발자인 우리는 지금 무엇을 구현하고 있는가?

지금 우리는 단순한 코드를 작성하고 있는 것이 아닙니다.  
우리는 Ethereum의 계정 구조를 다시 설계하려는  
**전 세계 개발자들의 실험에 직접 참여하고 있는 중**입니다.

- 사용자가 직접 트랜잭션을 날리지 않아도 되는 구조
- 가스비를 몰라도 Web3를 이용할 수 있는 구조
- 스마트 컨트랙트조차 계정처럼 행동할 수 있는 구조

이건 **하나의 API**나  
**하나의 프론트 페이지**를 만드는 것과는  
전혀 다른 차원의 개발입니다.

## 그런데… 사용자의 입장에서는 어떨까요?

이제 우리는 개발자이자 동시에  
**사용자의 역할**도 맡게 됩니다.

- 지갑을 생성하고
- 메시지를 만들고
- 그 메시지에 서명하게 될 겁니다

그 행위는 단순히 `signMessage()` 한 줄이 아니라,  
Ethereum 세계에서는 다음과 같이 해석됩니다:

> “나는 이 요청을 승인합니다.”
> “이건 내가 원한 행동이에요.”
> “내 지갑 주소가 책임지는 요청입니다.”

---

### 그래서 질문을 던져야 합니다:

> 정말 이 서명이, 내가 보낸 것이 맞는가?
> 내가 보낸 요청은 위조될 수 없도록 보장되어 있는가?

지금 여러분이 작성하고 있는 건  
그냥 테스트 코드가 아닙니다.  
**사용자의 신뢰를 대신 시뮬레이션하고 있는 코드**입니다.

## 왜 이 글이 중요한가?

우리는 앞선 `metaTransaction.sol`에서  
**signTransaction(...)**이라는 검증 구조를 만들었습니다.  
서명값을 분해하고, 해시를 만들고, ecrecover로 주소를 복원하는 작업까지.

그런데 말입니다.  
그 작업이 아무 의미 없는 코드가 되지 않으려면,  
이제 여러분이 만드는 서명이 **진짜 “의사를 담은 것”**이어야 합니다.

## 앞으로 여러분이 할 일은

- 사용자의 지갑 10개를 준비하고
- 메시지를 만들고
- 각 메시지에 대해 직접 서명하고
- 그 서명을 백엔드가 검증하도록 보내는 것

## 정리 – 지금 우리는 두 역할을 동시에 하고 있습니다

| 역할       | 우리가 하는 일                         |
| ---------- | -------------------------------------- |
| **개발자** | 계정 추상화 구조를 직접 구현하고 있음  |
| **사용자** | 지갑을 생성하고 메시지를 서명하고 있음 |

> 그리고 그 사이에 존재하는 **신뢰**, **검증**, **위임**,
> 이 모든 걸 하나씩 코드로 구현해나가고 있습니다.

---

다음 문서(`11.userEthers.js`)에서는  
이제 진짜로 서명할 **지갑 10개를 생성**합니다.

그 지갑들은 사용자가 됩니다.  
**실제 트랜잭션을 날리지는 않지만, 책임을 가진 요청을 보낼 수 있는 사용자들**입니다.

---

이제,  
여러분이 직접 만든 지갑으로  
**“나 토큰 주세요”라는 메시지를 만들고**,  
그 메시지에 서명해봅시다.

이제 우리는 사용자가 됩니다.
