# 내일 만들 서버 흐름, 오늘 TDD로 체화하기

자, 이제부터는 **TDD**로 갑니다.

우리는 내일, 백엔드에서 두 가지 중요한 흐름을 구성할 겁니다:

1. 사용자가 보낸 메시지와 서명을 `/sign`에 저장
2. 저장된 요청들을 회사 지갑이 `/metaTransction`에서 실행

---

근데 이걸 구현하기 전에,
**정말 이 흐름이 맞는지**,
**진짜 이렇게 작동할 수 있는 구조인지**
손으로 직접 써보고 체화해야 합니다.

즉,

- 지갑이 메시지를 서명하고
- 메시지를 누가 보냈는지 검증하고
- 검증이 통과되면 풀에 저장하고
- 저장된 메시지를 모아서 실행할 수 있는지

> 이 모든 걸 화면 없이,
> 코드와 테스트만으로 **하나씩 체험해보는 게 오늘의 목표**입니다.

## 우리가 따라갈 흐름 – 시나리오 정리

---

### 시나리오 A: 사용자 요청 처리 (`/sign`)

- 사용자가 메시지를 만든다 (`{ sender, data }`)
- 메시지를 개인키로 서명한다
- 백엔드에 보낸다
- 백엔드는 서명을 검증한다
- 서명이 유효하면 txpool에 저장한다

---

### 시나리오 B: 회사 지갑 실행 (`/metaTransction`)

- txpool에 쌓인 요청들을 읽는다
- address\[], data\[], message\[], signature\[] 형태로 재구성한다
- `contract.mint(...)`를 호출한다
- 호출이 끝나면 txpool을 비운다

---

이 두 가지 흐름을 **테스트 코드 안에서 미리 따라가볼** 겁니다.

즉, `server.js` 없이 `server.test.js`부터 먼저 작성하는 방식입니다.

## 이 테스트가 왜 중요한가?

- `signMessage()`로 생성된 서명이 정말 검증 가능한지
- `ethers.verifyMessage()`가 우리가 예상한대로 작동하는지
- `txpool`에 쌓는 구조가 괜찮은지
- 최종적으로 `contract.mint(...)`가 실행 가능한 형태로 묶일 수 있는지

> 이걸 미리 확인해두지 않으면
> 내일 `server.js` 만들 때 구조가 잘못돼도 못 알아챌 수 있습니다.

# 오해 방지 – 계정 추상화, 지갑이 없어도 되는 구조일까?

이 문서에서는 사용자의 메시지를 서버가 받아 저장하고,  
회사가 그 요청을 검증 후 실행하는 흐름을 TDD로 체험합니다.

하지만 이 흐름에 들어가기 전에,  
**몇 가지 오해할 수 있는 중요한 지점을 먼저 바로잡고** 가야 합니다.

## “지갑이 없어도 된다”는 말의 정확한 의미

우리는 지금 **계정 추상화(Account Abstraction)**를 실험하고 있습니다.  
이 개념에서 가장 흔하게 오해되는 문장이 있습니다:

> “계정 추상화는 지갑이 없어도 Web3를 쓸 수 있게 해준다.”

이건 절반만 맞는 말입니다.  
정확히 말하자면,

> **“사용자는 지갑을 몰라도 된다. 하지만 지갑은 반드시 존재해야 한다.”**

즉,

- 사용자가 직접 지갑을 만들고 관리하지 않아도 되는 구조를 만들고자 하는 것이고,
- 그 대신 **시스템이 사용자 대신 지갑을 생성하고, 요청을 책임지는 구조를 설계**하는 것이 계정 추상화의 핵심입니다.

## 테스트에서 지갑 10개를 만드는 이유

이제 질문이 생깁니다:

> “지갑을 몰라도 된다면서, 왜 우리는 지갑 10개를 만들죠?”

이건 단순한 편의 기능이 아니라,  
**“지갑이 있어야만 서명을 만들 수 있고, 그 서명이 있어야 검증 가능한 요청이 되기 때문”**입니다.

사용자는 트랜잭션을 날리지 않습니다.  
하지만 서명은 합니다.  
이 서명은 Ethereum 세계에서 곧 **의사 표현이고, 책임의 증거**입니다.

> 즉, 우리가 만드는 건  
> “트랜잭션은 못 보내지만, 책임 있는 요청은 만들 수 있는 사용자 지갑”입니다.

## 회사지갑(Bundler)의 역할은?

사용자가 만든 요청을 모아서  
**진짜로 실행하는 주체는 회사 지갑(Bundler)**입니다.

- 사용자는 오직 메시지에 서명만 합니다.
- 서버는 그 서명을 검증해서 txpool에 저장합니다.
- 회사 지갑은 그 요청들을 꺼내서, 실제 트랜잭션을 실행합니다.
- 스마트 컨트랙트는 `ecrecover()`로 서명을 검증한 뒤 실행합니다.

이 구조는 단순히 API를 분리한 것이 아니라,  
**책임, 위임, 신뢰의 흐름을 구조적으로 재설계**한 것입니다.

## 결론 – 지금 우리가 구현하고 있는 건 단순한 테스트가 아니다

우리는 Ethereum이 원래 가지고 있던

- “사용자가 직접 지갑을 만들고”
- “트랜잭션에 서명하고”
- “가스비까지 책임져야 하는 구조”를

다음과 같이 바꾸고 있는 중입니다:

| 항목      | 기존 구조                     | 계정 추상화 구조                               |
| --------- | ----------------------------- | ---------------------------------------------- |
| 지갑 생성 | 사용자가 직접 생성            | 시스템이 자동 생성 (보이지 않게)               |
| 서명      | 사용자가 트랜잭션에 직접 서명 | 사용자 또는 시스템이 메시지에 서명             |
| 실행      | 사용자가 트랜잭션 실행        | 회사 지갑이 실행, 컨트랙트가 검증 후 처리      |
| 가스비    | 사용자가 직접 지불            | Paymaster 또는 Bundler가 대신 지불 (추후 구현) |
