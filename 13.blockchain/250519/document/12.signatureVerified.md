# 서명은 단지 해시가 아닙니다 – 구조와 책임을 만듭니다

우리는 지금, 사용자의 지갑을 준비해놓았습니다.  
이제 곧 이 지갑들로 **메시지를 서명하려는 단계**에 들어갈 겁니다.

그런데 서두르기 전에  
**아주 중요한 개념 하나를 미리 정리하고 가야 합니다.**

## 지금 우리는 “서명”이라는 걸 하려 합니다

근데 여기서 말하는 “서명”이란,  
단지 어떤 데이터를 `keccak256()`으로 해시해서  
bytes로 바꾸는 것 이상의 **구조와 책임**을 담고 있습니다.

## “이 메시지가 진짜 ‘나’의 것임을 어떻게 증명할 수 있나요?”

바로 이 질문에 대한 답이,
Ethereum에서의 서명 검증 구조 전체를 결정합니다.

---

> 정답은 단 하나입니다.

> **“나만 알고 있는 비밀키로 서명한 값이어야 한다”**

Ethereum에서 서명을 검증하는 공식 구조는 다음과 같습니다:

1. 사용자가 **어떤 메시지를 서명**합니다.
2. 그 결과로 **65바이트짜리 signature**가 만들어집니다.
3. 이 서명은 Solidity에서 이렇게 검증됩니다:

```solidity
ecrecover(hash, v, r, s) == userAddress
```

즉,

- `hash`: 내가 서명한 메시지
- `v, r, s`: 서명을 구성하는 3개 조각
- `ecrecover(...)`: 이 서명으로 **주소를 복원**
- 복원된 주소와 **진짜 사용자의 주소가 일치**해야만 트랜잭션이 실행됩니다

## 그런데 여기서 중요한 전제 하나

> **그 “hash”는 아무 해시나 써도 되는 게 아닙니다.**

Ethereum에서는
“서명 전용”으로 만들어야 하는 **특수한 포맷**이 있습니다.

그게 바로 다음 구조입니다:

```sh
"\x19Ethereum Signed Message:\n" + <length> + <message>
```

이건 Ethereum이 “서명 전용 메시지임”을 표시하기 위해
**강제로 덧붙이는 서명 포맷**입니다.

이걸 넣지 않으면,  
서명한 쪽(사용자 지갑)과  
검증하는 쪽(Solidity 스마트 컨트랙트)에서 **완전히 다른 해시**가 만들어집니다.  
→ 검증 실패 → 실행 실패

## Solidity에서 이걸 어떻게 처리하나요?

그래서 우리는 Solidity에서 다음 함수를 미리 만들어두었습니다:

```solidity
function getEthSignMsgHash(string memory _msg) internal pure returns (bytes32) {
    uint msgLength = bytes(_msg).length;
    return keccak256(
        abi.encodePacked(
            "\x19Ethereum Signed Message:\n",
            Strings.toString(msgLength),
            _msg
        )
    );
}
```

→ 이걸 통해 Solidity도  
→ **지갑이 서명할 때 사용한 메시지 구조와 똑같은 방식으로 해시를 생성**합니다.

## 핵심 정리

| 항목                 | 설명                                                                    |
| -------------------- | ----------------------------------------------------------------------- |
| **서명 대상 메시지** | 단순 JSON 문자열 아님. Ethereum 포맷이 추가된 메시지                    |
| **해시 생성 방식**   | `\x19Ethereum Signed Message:\n` + 메시지 길이 + 본문                   |
| **서명**             | 지갑이 이 해시를 비밀키로 서명 → `r`, `s`, `v`로 구성된 signature 생성  |
| **검증 방식**        | Solidity에서 동일 포맷으로 해시 생성 후, `ecrecover()`로 주소 복원 비교 |

## 결론 – 지금 우리는 "준비"를 마치고 있는 중입니다

우리는 방금 사용자 지갑들을 생성했고,  
이제 곧 사용자처럼 행동하여 **메시지를 서명할 준비**를 하고 있습니다.

그런데 이 서명이  
정확히 어떤 구조로 만들어지고,  
어떤 전제를 따라야 하는지를  
**지금 확실히 인지하고 넘어가야**  
다음 단계에서 **“왜 이게 실패하는지”**를 알 수 있습니다.

---

다음은 이제,
`signMessage()`로 서명을 만들고,
**그 서명을 가지고 메시지를 전송하는 TDD 흐름**을 직접 구현하는 시간입니다.
