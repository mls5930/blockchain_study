# 또 다른 관점 – 추상화란 무엇인가?

자, 여러분.
**“추상화”**라는 단어, 오랜만이죠? ㅎㅎ
기억나시죠? 타입스크립트 수업 때 제가 그랬습니다.

> **“타입스크립트의 진짜 힘은 추상화에 있다.”**

## 그때 제가 이렇게 비유했었죠.

> “건물을 지을 때, 외벽부터 짓지 않습니다.”
> “철근 대신 나무, 기둥 대신 수세미를 넣으면 순살 자이 된다.”
> “그래서 **설계도**, 즉 **추상화된 규칙**이 필요하다.”
> → **모든 층이 일관된 규칙 위에서 지어져야 안전하다.**

현실 세계에도 **설계도**가 필요하듯이,  
코드를 짤 때도 **규칙과 구조를 추상화**해야 합니다.  
이걸 잘 해놓아야 확장할 수 있고, 일관성을 유지할 수 있죠.

그런데 이 추상화라는 개념은 사실,  
오늘 우리가 다룰 Ethereum 구조에서도 **그대로 등장합니다.**

---

Ethereum에는 **두 가지 계정 타입**이 있습니다.

1. **EOA (Externally Owned Account)** – 우리가 흔히 쓰는 개인 지갑 주소
2. **CA (Contract Account)** – 스마트 컨트랙트 주소

둘 다 “주소”처럼 생겼지만,
**행동 방식과 권한 구조는 전혀 다릅니다.**

> EOA는 서명할 수 있습니다.
> CA는 호출만 기다립니다.

## 그런데 여기서 질문 하나.

- CA는 왜 **스스로** 트랜잭션을 만들 수 없을까요?
- 왜 항상 누군가의 **호출을 기다리는 객체**로만 존재해야 할까요?
- 우리가 말하는 **“계정(Account)”**은 왜 **항상 EOA 기준**으로 설계되었을까요?

이건 마치 이런 상황입니다.

> 프론트엔드는 어떤 주소에게 토큰을 전송하고 싶어요.
> 그런데 그 주소가 CA예요.
> 그러면 Ethereum은 말합니다:
> “아, 얘는 서명 못 하는데요?”

마치, 설계도에는 철근을 써야 하는데  
개발자가 거기다 나무를 끼워넣는 격이죠.

Ethereum의 초기 구조는 단순했습니다.

- 트랜잭션? 사용자가 지갑에서 서명해서 보내면 됨
- 컨트랙트? 누가 호출하면 그때 반응하면 됨

그런데 생태계가 커지면서,  
단순함이 **제약이 되기 시작**합니다.

- 다중 서명 지갑이 필요해졌고,
- 소셜 로그인으로 서명 없이 참여하고 싶고,
- 가스비를 모르면 아무 것도 못 하는 현실도 생겼습니다.

이제 Ethereum도 깨닫습니다.

> “지금 이 구조는 확장성과 접근성을 담보하지 못한다.”
> “우리도 설계도, 즉 추상화된 구조가 필요하다.”

그래서 등장한 개념이 바로

## **계정 추상화 – Account Abstraction**

계정을 설계할 때, 더 이상

> “EOA만 서명 가능, CA는 실행만 가능”
> 이라는 이분법을 유지하지 말자.

Ethereum은 이런 질문을 스스로에게 던지기 시작합니다:

- “트랜잭션을 꼭 사람이 서명해야 하나?”
- “컨트랙트도 계정처럼 행동할 수 있지 않을까?”
- “계정이란 구조 자체를 바꾸면 안 될까?”

---

### 여기서 말하는 추상화란?

- 계정이라는 개념을 일반화(Generalization)하고
- **트랜잭션의 주체와 실행 구조를 유연하게 만드는 것**

결국 이건,  
Ethereum이 가지고 있던 **“계정 철학” 자체를 바꾸는 작업**입니다.

> 타입스크립트가 코드에 대한 우리의 태도를 바꿨듯이,
> 계정 추상화는 지갑과 트랜잭션에 대한 태도를 바꿉니다.

## 정리

**추상화는 복잡한 현실을 단순하게 구조화하는 행위입니다.**

Ethereum은 이제  
**계정이라는 현실을 추상화하여**,  
**컨트랙트조차도 계정처럼 행동할 수 있는 구조**를 만들고자 합니다.

> “사용자가 지갑을 몰라서 불편해요”
> 라는 차원이 아닙니다.

---

> “지갑이라는 존재 자체를 다시 정의하자.”
> “Web3의 사용성, 보안성, 확장성을 모두 아우르는 구조로 전환하자.”
> → **Web3 환경 자체를 변화시켜, 더 많은 사용자를 포함할 수 있도록 설계하자.**

이제 본격적으로,
그 구조가 어떻게 설계되어 있는지
**UserOperation, Bundler, EntryPoint**라는 키워드를 중심으로 살펴보겠습니다.
