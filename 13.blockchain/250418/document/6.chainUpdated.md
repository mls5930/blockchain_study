# 4단계: `chain.on("chainUpdated")` – 체인 변경 이벤트 등록

---

## 지금 우리는 어떤 흐름을 만들고 있죠?

- 브라우저가 WebSocket으로 서버에 연결됐고
- 연결되자마자 `init` 체인을 받았어요
- 그런데… 그 후 블록이 추가되면?

> **“브라우저는 그걸 어떻게 알 수 있을까?”**

---

## 그래서 필요한 게 바로 `chain.on("chainUpdated")`

이 구조는 이렇게 작동해요:

1. 체인이 바뀌는 **어떤 일이 발생함**  
   예: 블록 추가, 체인 교체 등

2. 우리는 그 시점에 `.emit("chainUpdated")`를 호출함  
   → "체인 바뀌었어요!"라고 외치는 것

3. `.on("chainUpdated")`로 등록된 콜백 함수가 호출됨  
   → 이 콜백에서 `ws.send()`를 실행함  
   → 브라우저로 실시간 전송됨!

---

## 용어 정리: `emit()` vs `on()`

| 메서드            | 역할                                               |
| ----------------- | -------------------------------------------------- |
| `emit("event")`   | **이벤트를 발생시킴** – 신호를 보냄                |
| `on("event", fn)` | **이벤트가 발생하면 실행할 함수 등록** – 감지 대기 |

---

## 그래서 왜 이게 핵심인가요?

지금까지 만든 구조는 전부 **이 이벤트를 위한 준비**였어요.

- WebSocket 연결을 했고
- `ws` 객체를 만들어서 기다리고 있었고
- 체인이 바뀌면 → `.emit()`을 날려서
- 기다리고 있던 `.on()`이 실행됨

> 즉, 우리가 만든 연결이 **드디어 동작하기 시작하는 순간**이 바로 이겁니다.

---

## 이걸 안 하면 어떤 문제가 생기죠?

- 체인이 바뀌었는데 브라우저는 모름
- 사용자는 새로고침해야지만 확인 가능
- 결과적으로 **블록체인이 실시간으로 작동하는 것처럼 안 보임**

---

## 예시 코드로 보면 이렇게 돼요

```ts
// 연결 시
chain.on("chainUpdated", (updatedChain) => {
  ws.send(JSON.stringify({ type: "chainUpdated", payload: updatedChain }));
});
```

---

## 체인이 바뀌었을 때는 어디서 `.emit()`하죠?

→ 그건 다음 단계인 **5단계**에서 다룹니다.  
(예: `addToChain()`, `replaceChain()` 내부에서 호출)

---

## 요약 정리

> **“WebSocket으로 연결된 브라우저가 체인의 변화를 실시간으로 감지할 수 있게 만드는 핵심 연결고리.”**  
> 이게 바로 `.on("chainUpdated")` 등록입니다.
