좋습니다!  
5단계는 **브라우저가 실시간 데이터를 받는 입장**에서  
전체 흐름이 마무리되는 지점이죠.

학생들이 “아, 내가 만든 블록이 다른 탭에도 바로 보이는 이유가 이거구나!”  
하고 **즉각적으로 체감할 수 있게** 다음처럼 친절하게 정리해봤어요:

---

# 5단계: 클라이언트(Web)에서 WebSocket 연결하기

> **메시지를 실시간으로 수신해서 화면에 체인 업데이트하기**

---

## 지금까지 우리는 서버에서 뭘 했죠?

1. HTTP 서버 만들었고
2. WebSocket 붙였고
3. 체인 변경 이벤트도 `.emit()`으로 날릴 준비 했어요

이제 마지막 퍼즐이 남았습니다:

> **브라우저가 그 메시지를 받아서 화면에 표시하는 것!**

---

## 이건 브라우저 코드에서 처리해요

브라우저는 자바스크립트에서 이렇게 WebSocket을 연결합니다:

```js
const socket = new WebSocket("ws://localhost:4001");
```

- 이건 HTTP가 아니라 **WebSocket 프로토콜을 여는 코드**입니다.
- 즉, `ws://`라는 주소로 **지속적인 연결을 요청**하는 거죠.

---

## 연결이 성공되면?

서버가 아까 등록해뒀던 `on("connection")`에 의해  
→ 체인 정보를 보내줍니다:

```ts
ws.send(JSON.stringify({ type: "init", payload: chain.get() }));
```

그럼 브라우저에서는 이렇게 받는 거죠:

```js
socket.onmessage = (event) => {
  const { type, payload } = JSON.parse(event.data);

  if (type === "chainUpdated") {
    blockListView.innerHTML = JSON.stringify(payload, null, 2);
  }
};
```

---

## 흐름이 가진 의미는?

- 블록을 누가 만들든
- 그 체인 데이터가 서버를 통해
- **실시간으로 나에게 전달되고**
- **화면(DOM)에 즉시 반영되는 것**

---

## 한 번만 더 흐름 정리해봅시다

1. `new WebSocket(...)` → 서버에 연결 요청
2. 서버 `on("connection")` → 연결 허용, 초기 체인 전송
3. 서버 `chain.emit("chainUpdated")` → 연결된 브라우저에 전송
4. 브라우저 `onmessage` → 메시지 수신
5. `innerHTML`로 DOM 업데이트 → **눈으로 체감**

---

## 우리가 확인하게 될 것

- 한 브라우저에서 블록을 만들면
- 다른 브라우저 탭에서도 **즉시 새 블록이 반영된다**

이게 오늘 수업의 핵심 장면입니다.

---

## 마지막 요약

> **“브라우저는 WebSocket으로 서버에 연결하고,  
> 서버가 체인 변화를 보내면  
> 그걸 받아서 화면에 실시간으로 표시한다.”**
