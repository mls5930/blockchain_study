# 우리는 지금 어디쯤 와 있을까요?

지금까지 여러분은 꽤 많은 걸 해냈습니다.

- 단순한 해시부터 시작해서
- 머클트리 구조로 데이터를 압축해보고
- 타입스크립트를 활용해 블록 구조를 추상화해보고
- 체인 구조를 통해 신뢰가 쌓이는 흐름도 구현했고
- 지갑을 만들어 ‘나’를 증명하고
- 트랜잭션을 만들어 누구에게 얼마를 보낼지 정의하고
- 그리고 이틀 전에는 **코인베이스 트랜잭션**을 통해  
  “채굴을 통해 새로운 코인을 얻는다”는 구조도 완성했죠.

이제 블록도 만들 수 있고, 트랜잭션도 만들 수 있습니다.

---

## 그런데… 이게 끝일까요?

트랜잭션도 만들고 블록도 만들었는데,  
그게 **내 컴퓨터 안에서만** 돌아가고 있다면…

그건 **블록체인이라고 할 수 있을까요?**

아니죠.

왜냐하면 블록체인의 핵심 철학은 바로 **“탈중앙화”**에 있기 때문입니다.

> “누가 만든 블록이든, 누구의 트랜잭션이든  
> 그것이 **전 세계의 노드들에게 동등하게 전파**되어야 한다.”

---

# 오늘 수업의 핵심 목표

**블록 생성 → 다른 노드에게 자동 전파 → 실시간 반영**

이 전체 흐름을 **코드로 직접 체험**합니다.

즉, 내가 블록을 하나 만들었을 때  
그 내용이 **다른 브라우저, 다른 노드**,  
다른 포트에서 켜진 프로그램에게 **실시간으로 전달**되어야 합니다.

그걸 가능하게 해주는 기술이 바로 오늘 배우는 **WebSocket + P2P 구조**입니다.

---

## 우리가 구현한 기존 구조, 다시 한 번 정리해봅시다

지금 여러분 프로젝트에는 폴더도 많고, 파일도 많고,  
`connect()`니 `listen()`이니 복잡해 보이죠?

하나씩 차근차근 정리해볼게요.

### 우리가 이미 만든 구조들

| 구성요소 | 역할 요약                                                   |
| -------- | ----------------------------------------------------------- |
| `Block`  | 실제 하나의 블록을 의미                                     |
| `Chain`  | 블록체인의 전체 흐름과 규칙을 관리하는 클래스               |
| `Client` | 다른 노드에게 데이터를 요청하거나 전송하는 역할 (보내는 쪽) |
| `P2P`    | 내가 받은 데이터를 처리하거나 리스닝하는 역할 (받는 쪽)     |

---

## 지금까지는 어떻게 연결되었죠?

우리는 이렇게 구성해왔습니다:

- `Client.connect(host, port)` → 데이터를 보낼 노드에게 연결
- `P2P.listen(port)` → 내 노드가 열어둔 포트에서 데이터를 받을 준비

즉, 각 노드가 서로 **IP + 포트 번호**를 기준으로  
**TCP 통신을 주고받는 구조**를 이미 구현해둔 상태입니다.

---

## 그런데 여기까지는 “요청 → 응답”이었어요

> “내가 블록을 만들었어요. 받아가세요.”

이런 식이었죠.  
그런데 오늘부터는?

---

## 오늘부터는, **자동으로**, **실시간으로** 보내야 합니다

이게 핵심입니다.

- 누가 블록을 만들었든,
- 그 블록이 내 체인을 업데이트하면,
- 내 브라우저에 **자동으로 실시간 반영**되어야 합니다.

---

## 그래서 오늘은 어떤 기술이 추가되나요?

바로 `WebSocket`이라는 기술입니다.

### 왜 WebSocket?

- HTTP는 **한 번 요청하면, 응답 받고 끝**입니다.
- 하지만 우리는 **계속 연결된 상태**가 필요합니다.
- 누가 블록을 생성하면, **실시간으로 자동 통보받아야** 하니까요.

---

## WebSocket은 이렇게 동작합니다

1. 브라우저가 서버에 연결 요청을 보냅니다 (`new WebSocket(...)`)
2. 서버는 `on("connection")`으로 연결을 받아줍니다
3. 서버는 체인이 업데이트될 때마다 `.emit()`으로 알립니다
4. 연결된 브라우저들에게 `.send()`로 최신 체인 데이터를 전송합니다
5. 브라우저는 `.onmessage()`로 그걸 받아서 화면에 반영합니다

---

## 이제 이걸 구현할 차례입니다

곧 여러분은 다음과 같은 걸 구현하게 됩니다:

- 서버에서 WebSocket을 열고,
- 체인이 바뀔 때마다 이벤트를 발생시키고,
- 연결된 브라우저에게 실시간으로 데이터를 보내고,
- 브라우저에서 이를 수신해서 화면에 반영합니다.

---

## 결론

> **"내가 만든 블록이  
> 다른 노드에게 자동 전파되고  
> 실시간으로 반영된다."**

이 철학을 코드로 직접 구현해보는 수업입니다.

---

## 다음 단계 힌트

조금 복잡해 보일 수 있지만, 아래 순서를 기억하세요:

1. `node.ts`에서 `WebSocketServer`를 올려주기
2. `websocket.ts`에서 연결 시 체인 보내기, 변경 시 자동 전송
3. `Chain` 클래스에서 `.emit("chainUpdated")` 넣어주기
4. `index.html`에서 `socket.onmessage()`로 반영하기

이 구조를 완성하면

> **“실시간 블록체인”**  
> 을 여러분 손으로 만든 겁니다.
