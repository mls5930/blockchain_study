# React Query

**서버에서 받아온 데이터, 그걸 어떻게 관리할 것인가?**

## 우리는 지금 무엇을 하려는가?

- 백엔드에서 데이터를 받아왔다
- 화면에 보여줘야 한다
- 그런데 이 데이터를 상태로 관리하고 싶다

이제 우리는 이런 고민을 하게 됩니다:

> 데이터를 어디에 저장하지?
> 상태로 두긴 해야겠는데, 이거 useState로 관리하면 너무 복잡한데?

## 1. 리액트는 원래 상태를 관리하기 위해 만들어졌다

리액트의 철학은 명확합니다.

> **“상태에 따라 UI가 결정된다. 상태가 바뀌면, 필요한 컴포넌트만 다시 그려준다.”**

그런데 여기서의 상태란 어떤 걸 말할까요?

- 사용자가 버튼을 클릭했는가?
- 모달이 열렸는가?
- 입력창의 값은 무엇인가?

이런 건 전형적인 **클라이언트 상태**입니다.

## 2. 서버에서 받아온 데이터도 상태일까?

→ 맞습니다.
하지만 **성질이 다릅니다.**

| 구분      | 클라이언트 상태          | 서버 상태                          |
| --------- | ------------------------ | ---------------------------------- |
| 제어권    | 내가 가짐                | 서버가 가짐                        |
| 변화 빈도 | 높음                     | 낮음 혹은 외부 요인                |
| 사용 위치 | 컴포넌트 내부 or Context | 외부 fetch, 여러 컴포넌트 공유     |
| 저장 방법 | useState, useReducer     | useEffect + fetch + useState 조합? |

## 3. 그래서 문제가 생긴다

서버에서 데이터를 받아올 때마다:

- `useEffect` 안에서 fetch
- 로딩 상태 따로 관리
- 에러 발생 시 try/catch 처리
- 새로고침하면 다시 요청
- 캐싱 안됨
- refetch 어려움

→ 이걸 다 직접 한다? 너무 번거롭습니다.

## 4. React Query는 무엇을 해결하는가?

React Query는 말합니다.

> “서버 상태도 마치 useState처럼 다뤄봐요.”
> “그리고 귀찮은 건 우리가 알아서 해줄게요.”

```ts
const { data, isLoading, isError } = useQuery(["posts"], fetchPosts);
```

이 한 줄로 끝나는 일들:

- 데이터 fetch
- 로딩 처리
- 에러 처리
- 캐싱
- 자동 재요청
- 백그라운드 리패치

## 5. 등장 배경과 철학

- **TanStack**에서 만든 `React Query`는
  **React에서의 서버 상태 문제를 해결하기 위한 라이브러리**입니다.

- 핵심 철학:

> **“서버 상태를 선언적으로 관리하자”**
> “명령형(fetch → setState)이 아닌 선언형(useQuery → 자동처리)”

- 내부적으로는 캐시 시스템을 두고, 모든 API 요청을 **캐싱 가능한 단위 상태**로 취급합니다.

## 6. 많이 쓰냐?

엄청 많이 씁니다.

- **Next.js 공식 튜토리얼 포함**
- **TanStack Query**로 발전
- 대형 프로젝트, 실무 서비스에서 거의 **표준처럼 채택**

## 7. 그럼 언제 써야 하냐?

- 서버에서 데이터를 자주 받아오는 경우
- 로딩/에러 상태 처리가 반복되는 경우
- 여러 페이지/컴포넌트에서 동일한 데이터가 필요할 때
- 캐싱이 필요한 상황
- 무한 스크롤, pagination, background refetch 등 고급 기능 필요할 때

## 8. 어떤 문제점이 있을까?

물론 한계도 있습니다:

- 클라이언트 상태까지 관리하긴 어려움
- 캐시 갱신 타이밍을 잘못 설정하면 stale 데이터 문제
- 서버 상태와 클라이언트 상태를 혼합해서 쓰려면 → 다른 라이브러리와 병행 필요 (예: Zustand, Recoil)

## 9. 그래서 무엇을 공부해야 하는가?

React Query를 공부할 땐 이렇게 단계적으로 접근하세요:

### (1) 기존 방식 먼저 해보기

- `useEffect + fetch + useState` → 구조적 한계 느끼기

### (2) useQuery 패턴 익히기

- key, fetcher 함수, 반환값 구조 파악

### (3) 캐싱/리패치 구조 이해하기

- queryKey가 무엇인지
- `refetch`, `staleTime`, `cacheTime` 등 옵션 이해

### (4) mutation 흐름도 익히기

- `useMutation`으로 post/put/delete 처리

## 면접에서 이렇게 말해보세요

> ❌ "그냥 많이 써서요"
> ✅ "서버 상태는 클라이언트 상태와 성질이 다르기 때문에, React Query로 선언적 구조로 관리했습니다. 캐시 기반이라 성능 최적화도 유리했고, 협업 시 로딩/에러 처리 분리가 용이했습니다."

## 정리

- React Query는 서버 상태 관리의 기준점입니다.
- 상태를 선언적으로 다루고, 캐시와 재요청까지 통합 관리할 수 있게 해줍니다.
- 실무에서는 거의 필수처럼 사용됩니다.

**→ 서버 상태가 등장하는 순간, React Query를 고려하세요.**

## React Query는 axios 같은 데이터 요청 라이브러리가 아니다.

**→ 비동기 상태 관리 매니저다.**

## ❌ 오해: React Query = axios 대체제?

많은 인터넷 글들, 튜토리얼, 블로그에서 이렇게 설명합니다.

> “React Query로 데이터를 요청하면요…”

> “useQuery에 API 넣으면 요청 날아가고, 결과 받아옵니다\~”

교육자로서 정말 안타깝지만…
**이건 틀렸습니다.**

## React Query는 데이터를 "요청하는" 도구가 아닙니다.

**→ 데이터를 "관리하는" 도구입니다.**

### 실제 요청은 누가 하나요?

직접 보시죠.

```tsx
const fetchPosts = async () => {
  const { data } = await axios.get("/api/posts");
  return data;
};

const { data, isLoading } = useQuery(["posts"], fetchPosts);
```

여기서 요청은 누가 합니까?
→ **axios가 합니다.**

React Query는 단 하나의 요청도 하지 않습니다.
**그저 "이 요청(fetchPosts)을 실행해줘"라고 위임할 뿐입니다.**

## ❓ 그럼 React Query는 뭘 하죠?

**요청 결과가 온 이후의 상태를 ‘통합적으로’ 관리합니다.**

| 기능                     | 설명                     |
| ------------------------ | ------------------------ |
| `isLoading`, `isError`   | 요청 상태 자동 분리      |
| `data`                   | 결과 상태 자동 저장      |
| `refetch()`              | 요청 재실행              |
| `cache`                  | 결과 재사용              |
| `staleTime`, `cacheTime` | 데이터 갱신 주기 관리    |
| `queryKey`               | 동일한 요청 구분 및 관리 |

→ 이 모든 걸 자동으로 관리하는 게 **React Query의 본질**입니다.

## 이 오해를 React Query 개발자도 답답해했습니다

TanStack(React Query 개발팀) 공식 문서에서는 다음과 같이 명시하고 있습니다:

> “React Query **does not fetch** your data. You do.”

그리고 여러 이슈, 블로그, 커뮤니티에서도 자주 나오는 정정 발언:

> “We manage the lifecycle of the async data. You still have to request it yourself.”
> “React Query는 **axios도 fetch도 아닙니다.** fetcher는 여러분이 정의하세요.”

## 이걸 잘못 이해하면 어떤 문제가 생기나?

- axios 대신 React Query만 쓰면 된다고 오해함
- 요청 로직을 `useQuery` 내부에 직접 작성함 → 분리 불가능
- 캐싱 정책을 설정하지 않음 → stale 데이터 남발
- 에러 처리, 리패치 타이밍을 이해 못하고 "그냥 쓰기"만 함

→ 결과적으로 **“왜 React Query를 써야 하는지” 모른 채로 써버리는 상황**이 발생합니다.

## 정리

| 잘못된 인식                     | 바로잡기                                          |
| ------------------------------- | ------------------------------------------------- |
| React Query는 axios다           | ❌ 아니다. axios는 fetcher일 뿐                   |
| React Query가 데이터를 요청한다 | ❌ 요청은 여러분의 함수가 한다                    |
| React Query는 요청 도구다       | ❌ 아니다. **요청 이후 상태를 관리하는 매니저**다 |

## 면접에서 이렇게 말해보자

> **“React Query는 axios, fetch를 대체하는 도구가 아니라, 비동기 데이터의 상태와 생명주기를 통합 관리하는 매니저입니다.
> 요청은 axios나 fetch 등으로 따로 정의하고, 그 요청 결과를 선언적으로 사용할 수 있도록 도와줍니다.”**
