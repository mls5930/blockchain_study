# 1.why.md

**왜 지금 “Node.js 구조 감각”을 익혀야 하는가?**

## 우리는 지금 어디에 있는가?

우리가 지금까지 배워온 건 Node.js입니다.  
Node.js는 자바스크립트를 백엔드 영역에서도 실행할 수 있게 만든 런타임입니다.

이는 굉장히 중요한 전환점이었습니다.  
**웹 브라우저 안에서만 머물던 자바스크립트**가  
이제는 서버, 배치, 백엔드 API 설계, 파일 시스템 접근까지 할 수 있게 되었습니다.

하지만…

오늘날 **Node.js는 더 이상 경쟁력이 아닙니다.**  
그냥 **기본 입장권**일 뿐입니다.

> **"Node.js 가능"은 면접을 볼 수 있는 최소한의 조건일 뿐,  
> 합격을 위한 무기는 아닙니다.**

## 그럼 우리는 뭘 해야 하는가?

지금 우리에게 필요한 건 단순한 API 구현이 아니라,  
**“설계 감각”을 갖춘 백엔드 개발자**가 되는 것입니다.

그리고 그 설계 감각은 다음의 질문에 답할 수 있어야 생깁니다:

- 요청을 어떤 구조로 분리할 것인가?
- 컨트롤러는 무엇을 하고, 서비스는 무엇을 해야 하는가?
- DB 로직은 어디에 위치해야 하는가?
- 미들웨어를 어디에 끼워 넣을 것인가?
- 코드가 복잡해졌을 때, 어떻게 정리해야 유지보수가 쉬운가?

## 그래서 시작합니다 – 구조화 백엔드 훈련

단순히 `GET`, `POST`를 구현하는 게 아닙니다.
지금부터 우리가 해야 할 것은,
**하나의 기능(Counter)을 기준으로 백엔드 설계 전체를 분해하고 재구성**하는 훈련입니다.

우리가 구현할 것은 **Counter 기능**입니다.
하지만 단순 숫자 증가 기능이 아닙니다.
다음과 같은 감각을 키우기 위한 실전 훈련입니다:

## 이 훈련에서 우리가 익힐 감각

| 감각                 | 설명                                                 |
| -------------------- | ---------------------------------------------------- |
| **계층 분리**        | 라우터 → 컨트롤러 → 서비스 → 모델 구조를 명확히 나눔 |
| **의존성 분리**      | 컨트롤러는 실행만, 로직은 서비스에서 관리            |
| **비동기 흐름**      | DB 요청 → 응답 흐름을 `async/await`로 제어           |
| **유효성 검사 흐름** | 요청을 처리하기 전에 필터링하는 미들웨어 설계        |
| **책임 분산**        | 파일 단위, 폴더 단위로 책임을 나눔                   |
| **DB 설계 감각**     | 테이블 구성, 관계성, 초기값 관리, 갱신 흐름          |

이 모든 구조를 단 하나의 도메인(Counter)에 집중해 연습하게 됩니다.

## 왜 Counter인가?

**단순하면서도 완결된 기능이기 때문입니다.**

- 값의 저장 (DB 연동)
- 값의 갱신 (POST 처리)
- 상태의 반영 (렌더링 or 응답)
- 흐름 분리 (계층화된 구조 설계)

이 과정을 통해, 우리는 **구조화 사고를 훈련**합니다.
그 어떤 프레임워크도 이 사고 없이 사용하면 “복잡한 문법”에 불과합니다.

## 지금은 ‘프레임워크’가 아니라 ‘감각’을 훈련할 때입니다

우리가 지금 배워야 하는 건 프레임워크 이름이 아닙니다.  
**디렉토리를 어떻게 나누고**,  
**역할을 어디에 배치하고**,  
**누가 무엇을 책임지는지**  
그 사고방식입니다.

## 정리하며

이제 우리는 백엔드 설계를 시작합니다.  
**“어떻게 구조를 짜야 유지보수가 가능한가”**  
**“나중에 협업할 때 어떤 기준으로 나누면 혼란이 줄어드는가”**

이 기준을 연습하는 것이 우리가 지금 해야 할 일입니다.

---

이제 다음 문서에서는 **구조 감각을 어떻게 연습할 것인지**
즉, `Counter 기능을 중심으로 한 실습 설계 (2.list.md)`를 확인해봅니다.
