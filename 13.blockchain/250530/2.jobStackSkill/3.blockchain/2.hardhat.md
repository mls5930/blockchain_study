# Hardhat

앞에서 우리는 **ethers.js**를 통해
블록체인과 애플리케이션을 연결하는 **Web3 통신 구조**를 살펴봤습니다.
이제 다음으로 살펴볼 것은 **Hardhat**입니다.

> ethers.js는 "호출"을 다루고,
> Hardhat은 "개발 전체 사이클"을 다룹니다.

즉,

- 컨트랙트를 **작성하고**,
- **컴파일하고**,
- **배포하고**,
- **테스트하고**,
- 필요하면 다시 **네트워크와 연결해서 상태를 확인하는**
  그 모든 과정을 책임지는 것이 **Hardhat**입니다.

## 배경과 역사

Hardhat은 2020년경, **Nomic Foundation**이라는 비영리 조직 주도로 개발된 도구입니다.
당시 스마트 컨트랙트 개발 도구는 **Truffle**이 주로 사용되고 있었지만,
현업에서는 아래와 같은 문제들이 계속 지적되었습니다:

- **테스트 속도가 느리다**
- **복잡한 테스트 시나리오가 어렵다**
- **디버깅과 에러 추적이 불편하다**
- **JS 생태계와 잘 안 맞는다**

이런 불만을 해결하기 위해 등장한 것이 Hardhat입니다.

처음에는 “Truffle보다 빠른 테스트 도구”라는 인식이었지만,
지금은 거의 **스마트 컨트랙트 개발 환경의 표준**처럼 자리잡았습니다.

> Hardhat은 단순한 CLI 도구가 아니라,
> **이더리움 개발자 생태계에 최적화된 풀스택 툴킷**입니다.

## 핵심 기능 및 실무 위치

| 기능 항목          | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| 컴파일러 설정      | solc 버전 지정, 다중 버전 지원                               |
| 배포 스크립트 작성 | 자동화된 배포 로직, 환경별 분기 처리                         |
| 테스트 환경        | mocha + chai 기반 구조화된 TDD 가능                          |
| 로컬 노드 구동     | ganache 대체 → `npx hardhat node`                            |
| 디버깅 지원        | `console.log` 직접 사용 가능, trace까지                      |
| ethers 통합        | **내장된 ethers.js 플러그인 지원**                           |
| EVM 상태 조작      | 블록 넘기기, 계정 세팅, 시간 변경 등 개발에 필요한 기능 다수 |

→ Hardhat을 통해 스마트 컨트랙트의 **개발 → 테스트 → 배포 → 실시간 디버깅**까지 하나의 흐름으로 연결됩니다.

## 왜 실무에서 Hardhat을 쓰는가?

실제 채용 공고와 오픈소스 블록체인 프로젝트 대부분은 Hardhat을 기본 도구로 설정하고 있습니다.
그 이유는 단순합니다.

> “혼자 개발하는 게 아니라, **여럿이 유지보수 가능한 구조를 만들기 위해서**입니다.”

- 컨트랙트가 10개 이상으로 늘어나면? → **배포 순서와 조건 관리**
- DAO, NFT, Token이 서로 호출해야 하면? → **모듈화된 배포 구조 필요**
- 테스트가 30개 이상이면? → **폴더 단위 테스트 분리와 상태 추적**
- 이벤트 로직 확인? → **로컬 네트워크 시뮬레이션으로 trace**

이 모든 게 Hardhat으로 가능해지기 때문입니다.

## ethers와의 통합

앞에서 살펴본 `ethers.js`는 단독으로도 사용할 수 있지만,
**Hardhat 내부에서는 자동으로 ethers 모듈을 연동해줍니다.**

```js
// 예시: Hardhat 테스트 코드
const [owner, user1] = await ethers.getSigners();
const Token = await ethers.getContractFactory("MyToken");
const token = await Token.deploy();
```

즉, Hardhat은 **ethers를 포함한 개발 컨텍스트 전체를 제공**합니다.
→ 별도로 provider, wallet, ABI 등을 설정하지 않아도 됨.

## 철학적 차이: Remix vs Hardhat

| 항목   | Remix        | Hardhat                            |
| ------ | ------------ | ---------------------------------- |
| 목적   | 데모 및 학습 | 팀 개발 및 실전 배포용             |
| 구조화 | 없음         | 폴더, 테스트, 스크립트 명확함      |
| 테스트 | 수동         | 자동화된 TDD 구성 가능             |
| 배포   | UI 클릭      | CLI 기반 반복 가능한 배포          |
| 확장성 | 한계 있음    | Ganache, Sepolia, ethers 등과 연동 |

> 즉, Remix는 실습용,
> Hardhat은 **실무형 블록체인 프로젝트의 뼈대**입니다.

## 실습으로 이어지는 흐름

> 단순히 `npx hardhat compile`만 치고 넘어가지 않습니다.
> 우리는 **이 도구가 해결하고자 한 문제의 흐름**을 그대로 따라가며 실습합니다.

예상 실습 구성:

1. 프로젝트 초기화 및 `hardhat.config.js` 구성
2. 로컬 개발 노드 `npx hardhat node` 실행
3. 스마트 컨트랙트 컴파일 및 배포 스크립트 작성
4. chai 기반 테스트 작성
5. 로컬 → Sepolia로 테스트넷 전환
6. 배포 후 트랜잭션 결과 추적 및 디버깅

## 우리는 왜 이걸 먼저 해야 하는가?

> 스마트 컨트랙트는 **작성만 하면 끝나는 코드가 아닙니다.**
> 그것은 운영되며, 실패를 방지해야 하고, 다른 팀원과 공유되고, 확장되어야 합니다.

Hardhat은 이 흐름을 **프로젝트 구조 안에서 훈련**시켜 줍니다.

단순히 배포할 줄 안다는 건
**“혼자서 해봤다”는 것이고**,
Hardhat을 통달한다는 건
**“여럿이 운영 가능한 구조를 설계할 줄 안다”는 뜻입니다.**
