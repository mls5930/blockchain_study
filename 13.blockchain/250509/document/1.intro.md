## 지난 수업 복습 – 베이스볼 흐름 재정리

**"토큰은 언제, 누가, 어떻게 움직이는가?"**

우리는 지난 시간에 단순히 `ERC-20` 표준 함수를 구현하는 데 그치지 않았습니다.
실제로 스마트 컨트랙트가 토큰을 **발행하고**, **전송하고**, **위임받아 회수하고**, **보상으로 지급하는** 구조를
**BaseballGame이라는 게임 도메인**에 맞춰 흐름 중심으로 구현해봤죠.

그 과정에서 우리는 다음과 같은 질문을 직접 마주했습니다:

> “누가 mint할 수 있어야 하는가?”
> “transfer와 transferFrom은 정확히 무엇이 다른가?”
> “approve는 단순한 허락인가, 위임인가?”

이제 오늘 수업을 시작하기 전에,
**BaseballGame 흐름에 따라 각 함수가 어떤 시점에서 어떤 역할을 했는지** 다시 한 번 정리해보겠습니다.

---

### 1. `mint()` – 게임 안에서 ‘가치’를 처음 만들어내는 출발점

게임을 시작하기 전에 가장 먼저 등장하는 건 **발행자(owner)의 mint 행위**입니다.

```solidity
mint(user1, 300 * 10 ** 18);
```

이 한 줄이 의미하는 건 단순한 잔액 증가가 아닙니다.
**“토큰이라는 가치를 이 세상에 처음으로 생성했다”는 선언이자 실행**이죠.

게임 컨트랙트는 토큰을 직접 발행하지 않습니다.
**발행은 오직 토큰 컨트랙트의 책임이고, 그 권한은 오직 오너에게만 주어졌습니다.**

→ 이 구조는 **발행 주체가 명확하지 않으면 신뢰가 무너진다**는 철학에서 비롯됩니다.

---

### 2. `transfer()` – 보상을 미리 나눠주는 동작

mint된 토큰은 아직 오너의 손 안에 있습니다.
이제 오너는 user1에게 토큰을 나눠줍니다.

```solidity
transfer(user1, 300 * 10 ** 18);
```

이 함수는 매우 단순한 조건을 따릅니다:
**“보내는 사람이 직접 호출하고, 충분한 잔액이 있어야 한다.”**

BaseballGame에서는 이 transfer가 두 가지 방식으로 등장했습니다:

- 오너가 user1에게 보상을 미리 주는 경우
- 게임에서 정답을 맞춘 유저에게 보상을 지급하는 경우 (CA → user1)

즉, **transfer는 '직접 전달'**의 의미를 가지며,
**누가 실행했는가(msg.sender)가 가장 중요한 함수**입니다.

---

### 3. `approve()` – “당신에게 권한을 주었으니, 주머니에서 언제든 가져가도 좋습니다”

유저가 게임에 참가한다고 해서 토큰을 직접 보내진 않습니다.
**CA가 알아서 회수하는 구조를 만들기 위해서는, 먼저 권한을 위임해야 합니다.**

```solidity
approve(baseballCA, 100 * 10 ** 18);
```

approve()는 지정한 주소에게 일정 금액만큼의 토큰을 사용할 수 있는 권한을 위임하는 함수입니다.
이 함수는 실행만으로 토큰이 이동하지는 않지만,
다른 컨트랙트나 계정이 transferFrom을 통해 내 지갑에서 토큰을 가져갈 수 있게 허락하는 구조입니다.

→ 중요한 건 이 시점에서는 **아직 아무런 토큰도 움직이지 않았다는 것**입니다.
→ 단지 **권한만** 부여한 겁니다.

---

### 4. `transferFrom()` – 참가비 회수, 그리고 누적 보상 풀의 형성

CA는 참가자가 미리 등록한 approve를 근거로 다음과 같은 함수로 참가비를 회수합니다.

```solidity
transferFrom(user1, address(this), 100 * 10 ** 18);
```

이 구조는 우리가 직접 보는 흐름과는 반대입니다.
**유저가 직접 주는 것이 아니라, CA가 가져가는 방식**이죠.

이게 가능하려면 반드시 두 조건이 만족되어야 합니다:

1. `user1`의 잔액이 충분할 것
2. `approve(user1 → baseballCA)`가 충분히 등록되어 있을 것

그리고 보상을 줄 때도 이 함수 구조와 대비되는 `transfer()`를 이용하죠:

```solidity
token.transfer(user1, reword);
```

이렇게 해서 BaseballGame은 **토큰 발행 → 분배 → 위임 → 회수 → 지급**의  
**완결된 흐름**을 하나의 시나리오 안에 담아냈습니다.

---

그리고, 여기서 우리는 아주 중요한 개념 하나를 다시 짚고 넘어가야 합니다:

> **“CA가 보유한 토큰은 단순히 ‘상태값’일 뿐이다.”**

우리는 종종 토큰을 **어떤 실체처럼 느끼지만**,  
사실 토큰은 단순히 **스마트 컨트랙트 내부의 `balances[주소]`라는 상태값**에 불과합니다.

즉, 컨트랙트가 토큰을 ‘가진다’는 것은  
**어떤 주소(CA)에 해당하는 숫자 상태값이 기록되어 있다는 뜻**입니다.

이 말은 곧, **메타마스크에서 토큰을 조회하는 행위도**  
해당 토큰 컨트랙트의 상태값을 읽는 것에 지나지 않습니다.

→ 그래서 우리가 메타마스크에 토큰을 ‘직접 추가’할 때  
→ **컨트랙트 주소(CA)를 입력하는 이유도 바로 여기에 있습니다.**

**"이 주소에 대해, 어떤 상태값이 기록되어 있는지 보여달라"는 요청**을  
메타마스크가 시각적으로 보여주는 것일 뿐입니다.

---

**토큰은 실체가 아니라, 상태값이다.**

이 인식을 가져야  
ERC-20을 단순히 전송만 되는 도구가 아니라,  
**상태 기반의 책임 구조**로 이해할 수 있습니다.

---

### 오늘은…

지금까지 우리는 `Ganache`라는 가상 이더리움 환경에서  
`mint`, `transfer`, `approve`, `transferFrom()` 흐름을 하나씩 테스트해보려고 했었죠?

심지어 어제는 `transferFrom()`까지 테스트하려다가…

**결국 실패하고 말았습니다.**  
제 불찰이긴 합니다. 하하.  
하지만 이 실패를 통해 **중요한 사실 하나를 확인**할 수 있었죠.

---

> **“Ganache는 EVM을 완벽하게 흉내내지 못합니다.”**

Ganache는 개발자가 빠르게 실험할 수 있도록 만들어진  
**‘가벼운 시뮬레이터’일 뿐**, 실제 메인넷/테스트넷과는 중요한 차이가 존재합니다.

특히 OpenZeppelin처럼 내부 구조가 복잡한 컨트랙트에서는  
`approve → transferFrom()` 흐름이 **실패하거나 의도치 않게 동작**할 수 있습니다.

---

그래서 오늘은 **이 시뮬레이션을 벗어나**,  
**실제 EVM이 구동되는 테스트넷**,  
즉 **KAIA 네트워크 위에서 우리의 컨트랙트를 진짜로 실행**해보려 합니다.
