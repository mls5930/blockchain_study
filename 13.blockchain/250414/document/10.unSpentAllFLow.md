# 트랜잭션 흐름 중간 점검

## 시나리오: **Bob이 Alice에게 7 코인을 전송**하는 트랜잭션을 만든다

> 앞서 작성한 로직을 **테스트 코드(TDD)**로 직접 실행하며,  
> 각각의 메서드가 올바르게 작동하는지 **명시적으로 증명**해보는 거예요.

---

## 테스트 목표

1. Bob이 충분한 잔액을 가지고 있는지 확인한다.
2. 잔액을 꺼내서 TxIn을 만든다.
3. 수신자(Alice)와 송신자(Bob)의 TxOut을 만든다.
4. 전체 트랜잭션 객체를 조립한다.
5. update()를 호출해서 UTXO가 갱신되는지 확인한다.

---

## 테스트 코드 예시 (`unspent.test.ts`)

```ts
import Unspent from "@core/transaction/unspent";
import {
  TxIn,
  TxOut,
  TransactionRow,
} from "@core/transaction/interface/transaction.interface";
import elliptic, { SignatureInput } from "elliptic";
import crypto from "crypto";
import { SHA256 } from "crypto-js";

const ec = new elliptic.ec("secp256k1");

describe("트랜잭션 흐름 TDD - Bob이 Alice에게 7코인을 보낸다", () => {
  let privateKey: string;
  let publicKey: string;
  let signature: SignatureInput;
  let unspent: Unspent;

  beforeEach(() => {
    unspent = new Unspent();

    const initHash = "init";
    const initTxOuts: TxOut[] = [
      { account: "Bob", amount: 5 },
      { account: "Bob", amount: 4 },
      { account: "Charlie", amount: 10 },
    ];
    initTxOuts.forEach(unspent.create(initHash));
  });
  it("밥의 키쌍을 생성할 수 있어야 한다.", () => {
    // 1. 비밀키 생성
    // 2. 비밀키로 파생된 공개키 생성
    privateKey = crypto.randomBytes(32).toString("hex");
    const keyPair = ec.keyFromPrivate(privateKey);
    publicKey = keyPair.getPublic().encode("hex", true);
  });

  it("밥이 자신의 키쌍을 가지고 임시 트랜잭션을 생성함.", () => {
    // 한 번 트랜잭션을 만들어서 서명까지 해보자
    const txData = "나 밥인데 100비트코인 있다고!";
    const hash = SHA256(txData).toString();

    const keyPair = ec.keyFromPrivate(privateKey);
    signature = keyPair.sign(hash, "hex");
  });

  it("Bob이 Alice에게 7코인을 보내는 트랜잭션을 만들고 UTXO 상태를 반영한다", () => {
    const sendAmount = 7;
    const sender = "Bob";
    const receiver = "Alice";

    // 1. 잔액 확인
    const canSend = unspent.isAmount(sender, sendAmount);
    expect(canSend).toBe(true);

    // 2. 사용할 잔액 선택
    const utxos = unspent.getUTXO(sender);
    let sum = 0;
    const txIns: TxIn[] = [];

    for (const utxo of utxos) {
      txIns.push({
        txOutId: utxo.txOutId,
        txOutIndex: utxo.txOutIndex,
        signature,
      });
      sum += utxo.amount;
      if (sum >= sendAmount) break;
    }

    expect(txIns.length).toBeGreaterThan(0);
    expect(sum).toBeGreaterThanOrEqual(sendAmount);

    // 3. TxOut 구성 (Alice에게 전송, Bob에게 거스름)
    const txOuts: TxOut[] = [{ account: receiver, amount: sendAmount }];
    if (sum > sendAmount) {
      txOuts.push({ account: sender, amount: sum - sendAmount });
    }

    // 4. 트랜잭션 조립 + 해시 생성
    const hash = SHA256(JSON.stringify({ txIns, txOuts })).toString();
    const transaction: TransactionRow = { txIns, txOuts, hash };

    // 5. update() 실행 → UTXO 갱신
    unspent.update(transaction);

    const result = unspent["unspentTxOuts"];

    // 6. 초기 등록된 Bob의 UTXO가 제거되었는지 확인 (unspentTxOuts에 "init" 해시 항목은 제거됨)
    expect(
      result.find((utxo) => utxo.txOutId === "init" && utxo.account === "Bob")
    ).toBeUndefined();

    // 7. 새로운 TxOut 등록 확인
    expect(
      result.find((utxo) => utxo.account === "Alice" && utxo.amount === 7)
    ).toBeDefined();
    expect(
      result.find((utxo) => utxo.account === "Bob" && utxo.amount === 2)
    ).toBeDefined();

    // 8. Charlie의 UTXO는 그대로 남아 있어야 함
    expect(
      result.find((utxo) => utxo.account === "Charlie" && utxo.amount === 10)
    ).toBeDefined();
  });
});
```

# Bob이 Alice에게 7코인을 보내는 전체 트랜잭션 흐름 – 코드 해설

## 1. 초기 UTXO 등록 (`beforeEach`)

```ts
beforeEach(() => {
  unspent = new Unspent();

  const initHash = "init";
  const initTxOuts: TxOut[] = [
    { account: "Bob", amount: 5 },
    { account: "Bob", amount: 4 },
    { account: "Charlie", amount: 10 },
  ];
  initTxOuts.forEach(unspent.create(initHash));
});
```

- 테스트마다 초기 상태를 동일하게 만들기 위해 `beforeEach` 사용
- `create(hash)` 메서드를 통해 초기 잔액(UTXO)을 세팅
- Bob은 총 9코인 보유 (5 + 4)

---

## 2. 개인 키 생성 (비공개 → 공개키)

```ts
privateKey = crypto.randomBytes(32).toString("hex");
const keyPair = ec.keyFromPrivate(privateKey);
publicKey = keyPair.getPublic().encode("hex", true);
```

- 서명을 위해 Bob의 개인 키와 공개 키를 생성
- 비공개 키는 트랜잭션 서명 시 필요하고,
- 공개 키는 검증할 때 사용됨 (이 단계에서는 검증 코드까지는 다루지 않음)

---

## 3. 서명(Signature) 생성

```ts
const txData = "나 밥인데 100비트코인 있다고!";
const hash = SHA256(txData).toString();
const keyPair = ec.keyFromPrivate(privateKey);
signature = keyPair.sign(hash, "hex");
```

- 임의의 데이터에 서명을 해보며 서명 구조 확인
- 실제 트랜잭션에선 `TxIn` 각각에 서명이 들어가야 함 → 이 테스트에선 동일한 서명을 넣어 실습함

---

## 4. 잔액 확인 – `isAmount()`

```ts
const canSend = unspent.isAmount("Bob", 7);
expect(canSend).toBe(true);
```

- Bob이 실제로 7코인을 보낼 수 있는지 체크
- 내부적으로 `getUTXO`와 `getAmount`를 통해 잔액 총합을 구함

---

## 5. 사용할 잔액 선택 – `getUTXO()` + TxIn 생성

```ts
const utxos = unspent.getUTXO(sender);
let sum = 0;
const txIns: TxIn[] = [];

for (const utxo of utxos) {
  txIns.push({
    txOutId: utxo.txOutId,
    txOutIndex: utxo.txOutIndex,
    signature,
  });
  sum += utxo.amount;
  if (sum >= sendAmount) break;
}
```

- Bob이 가진 잔액 중에서 7코인을 만족하는 조합을 선택
- 각 TxIn은 "어떤 트랜잭션의 몇 번째 출력을 쓰겠다"는 선언
- signature는 일단 모든 TxIn에 동일하게 넣었지만, 실제론 각각 해시 후 서명해야 함

---

## 6. TxOut 생성 – 수신자와 거스름

```ts
const txOuts: TxOut[] = [{ account: receiver, amount: sendAmount }];
if (sum > sendAmount) {
  txOuts.push({ account: sender, amount: sum - sendAmount });
}
```

- Alice에게 7코인 전송
- Bob은 9코인 중 2코인을 거스름으로 다시 받음

---

## 7. 트랜잭션 조립 + 해시 생성

```ts
const hash = SHA256(JSON.stringify({ txIns, txOuts })).toString();
const transaction: TransactionRow = { txIns, txOuts, hash };
```

- 입력과 출력을 조합한 후, 문자열로 직렬화하여 해시 생성
- 이 해시는 트랜잭션의 고유 ID 역할을 함

---

## 8. 트랜잭션 적용 – `update()` 호출

```ts
unspent.update(transaction);
```

- 사용한 TxIn에 해당하는 UTXO는 제거
- 새로 생성된 TxOut은 새로운 UTXO로 등록됨

---

## 9. UTXO 상태 검증

```ts
// 기존 Bob의 UTXO가 제거됐는지
expect(result.find(...)).toBeUndefined();

// 새로운 Alice, Bob의 UTXO가 추가됐는지
expect(result.find(...)).toBeDefined();

// Charlie의 기존 UTXO는 그대로 유지
expect(result.find(...)).toBeDefined();
```

- 트랜잭션의 결과로 Bob의 잔액은 업데이트되고, Alice는 7코인을 받음
- Charlie는 거래와 무관하므로 상태 그대로 유지됨
