# 사실 UTXO가 본체임

트랜잭션을 만드는 것도, 돈을 보내는 것도,  
**결국은 UTXO(미사용 잔액)를 기준으로 모든 게 이뤄집니다.**

---

> 입력값(TxIn)?  
> → 이전에 만들어진 UTXO 중 하나를 꺼내는 것

> 출력값(TxOut)?  
> → 이 트랜잭션을 통해 **새롭게 생겨난 UTXO**를 정의하는 것

---

즉, 트랜잭션의 입력과 출력은 전부  
**“UTXO의 소멸과 생성”이라는 입장에서 바라봐야** 제대로 이해가 됩니다.

## 근데 니 돈이 지금 얼마 있누?

이 질문이 핵심이에요.

> 아무리 `TxIn`, `TxOut`이 있어도  
> **“지금 이 주소에 실제로 얼마 남아 있는가”**를 추적하지 않으면  
> 새로운 트랜잭션을 만들 수 없어요.

그럼 그 **남아 있는 돈**, **쓸 수 있는 돈 목록**은 어디 저장하죠?

바로 **UTXO 목록(UnspentTxOut[])**입니다.

## 추상화 및 구조화

그래서 우리는 이걸 그냥 배열로 관리하지 않고,  
**Unspent 클래스로 추상화해서 구조화**합니다.

왜냐?

- 트랜잭션이 만들어지면 → **사용한 잔액은 제거하고**,
- 새로운 트랜잭션이 생기면 → **새로운 잔액을 추가하고**,
- 사용자의 잔액을 조회할 수 있어야 하며,
- 다음 트랜잭션을 만들 때 **꺼내쓸 수 있어야 하기 때문**이죠.

## 요약하면 이거임

지난 시간에는

- 하나의 트랜잭션을 만들고
- 해당 내용을 `TransactionPool`에 저장하는 흐름을 봤어요.

이번 시간에는

- 그 트랜잭션이 블록에 포함되었다고 가정하고,
- 거기서 나온 **TxOut을 새로운 UTXO로 등록**하고,
- 사용된 **TxIn에 해당하는 기존 UTXO는 제거**하는 구조를 만들 겁니다.

---

결국 이 구조는 아주 간단합니다:

> “내가 남긴 잔액을 시스템 안에 기록하고,  
> 다음에 그걸 불러다가 다시 쓰게 만드는 구조.”

---

다음 파트에서는 이걸 실제로 코드로 어떻게 구현하는지,  
**Unspent 클래스와 그 안의 메서드들(create, delete, update)**를 차근차근 만들어보면서  
**잔액의 흐름을 시스템 안에 어떻게 반영하는지** 보게 될 거예요.
