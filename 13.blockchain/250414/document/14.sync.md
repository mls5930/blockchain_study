# 트랜잭션 풀 – `sync()` 메서드 설명

---

## 왜 이 메서드가 필요한가?

블록은 한 번에 **여러 개의 트랜잭션**을 담습니다.  
그런데 블록이 생성된 후에도,  
**트랜잭션 풀(transactionPool)** 에는 여전히  
그 트랜잭션들이 **남아있게 되면 문제가 생깁니다.**

예를 들어,

- 같은 트랜잭션이 **다시 블록에 포함되는 중복 처리 문제**
- 처리된 트랜잭션이 여전히 유효한 것처럼 보이는 **잔여 정보 문제**

이런 혼란을 막기 위해서는,  
**블록에 들어간 트랜잭션을 풀에서 확실히 제거**해야 합니다.

---

## 그럼 어떻게 제거하나요?

지금까지는 `update(transaction: TransactionRow)` 메서드를 통해  
**트랜잭션 하나씩** 제거할 수 있었습니다.

하지만 실제 블록에는 수십 개 이상의 트랜잭션이 들어갈 수 있으니,  
**배열 형태로 한꺼번에 정리할 수 있는 메서드가 필요**합니다.

→ 그래서 등장한 것이 바로 `sync()`입니다.

---

## 목적

> 블록 안에 포함된 **여러 개의 트랜잭션**을  
> 트랜잭션 풀에서 **한꺼번에 제거**하는 메서드입니다.

---

## 전체 코드

```ts
sync(transactions: TransactionRow[]): void {
  if (typeof transactions === 'string') return;
  transactions.forEach(this.update.bind(this));
}
```

---

## 설명

### 1. 타입 확인 (방어 코드)

```ts
if (typeof transactions === "string") return;
```

- 외부에서 데이터를 잘못 넘겼을 때 (`string` 타입 등)
- 런타임 오류를 방지하기 위한 **방어적 프로그래밍**

### 2. 배열 순회하며 update 호출

```ts
transactions.forEach(this.update.bind(this));
```

- `update()`는 트랜잭션 하나씩 제거
- `sync()`는 그걸 반복해서 **배열 단위로 처리**

`bind(this)`가 중요한 이유는,  
`update()` 내부에서 `this.transactionPool`을 참조하기 때문에  
**this 바인딩을 유지하지 않으면 작동하지 않습니다.**

---

## 실제 사용 흐름

### 트랜잭션이 생성되고, 풀에 들어간다

```ts
transaction.create(receipt, utxos);
```

→ 이때 `transactionPool.push(...)`로 대기 상태 등록

---

### 채굴자가 블록 생성

```ts
const block = {
  transactions: [tx1, tx2, tx3],
};
```

---

### 블록 생성 이후 트랜잭션 정리

```ts
transaction.sync(block.transactions);
```

→ 내부적으로는 아래처럼 동작:

```ts
update(tx1);
update(tx2);
update(tx3);
```

---

## 언제 쓰는가?

| 상황                | 이유                                     |
| ------------------- | ---------------------------------------- |
| 블록 생성 직후      | 블록에 들어간 트랜잭션 제거 필요         |
| 노드 간 블록 동기화 | 다른 노드가 전송한 블록을 반영할 때 사용 |

---

## 전체 흐름 요약

```ts
1. 트랜잭션 생성 → 풀에 등록
2. 블록 생성 → 블록 안에 트랜잭션 포함
3. 블록 처리 완료 후 → sync(block.transactions)
4. → pool에서 해당 트랜잭션 제거 완료
```

---

## 한 줄 요약

> `sync()`는 블록에 포함된 트랜잭션들을  
> **트랜잭션 풀에서 정리해주는 배치 정리 메서드**입니다.  
> 단순하지만, 전체 시스템의 상태 일관성을 유지하는 데 필수입니다.
