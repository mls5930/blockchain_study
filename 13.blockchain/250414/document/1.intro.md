# 지금까지 우리는 무엇을 하였나요?

트랜잭션을 만들기 위해 다음과 같은 과정을 거쳤습니다:

1. **사용할 입력(TxIn)을 선택**

   - 내가 가진 UTXO(잔액) 중 필요한 만큼 꺼냄

2. **보낼 출력(TxOut)을 생성**

   - 받을 사람에게 보낼 금액 + 나에게 거스름돈

3. **트랜잭션 전체 조립 및 해시 생성**

   - 이 트랜잭션의 고유 ID가 됨

4. **트랜잭션 풀에 저장**
   - 아직 블록에 포함되진 않았지만, 채굴자가 사용할 수 있는 상태로 대기 중

---

## 그런데 트랜잭션이 만들어졌다고 해서, 거래가 끝난 걸까요?

**아직 아닙니다.**

> “트랜잭션을 만들었다 = 거래를 요청했다”  
> → **아직 잔액 정보는 바뀌지 않았습니다.**

---

## 언제 진짜 거래가 완료되나요?

바로 이럴 때입니다:

> 트랜잭션이 **블록에 포함되어**  
> 네트워크 전체에서 **검증이 완료**되었을 때

이 순간이 오면,  
우리는 시스템 내의 잔액 정보(UTXO)를 **정확하게 갱신**해야 합니다.

---

## 그래서 이제 필요한 건?

바로 **현재 UTXO 상태를 갱신할 수 있는 로직**입니다.

- 사용된 UTXO는 제거해야 하고
- 새롭게 생긴 TxOut은 **새로운 미사용 출력(UTXO)**로 등록해야 합니다.

---

## 왜 지금 이걸 해야 하나요?

- 우리는 트랜잭션을 만들 줄 알게 되었어요.
- 이제는 **그 트랜잭션을 실제 잔액 데이터에 반영**해야 해요.
- 그래야 다음 트랜잭션을 만들 때도 **정확한 잔액 기준**으로 검증할 수 있습니다.

---

## 오늘 수업의 목표는?

쉽게 말해,

> _"어제는 Bob이 거래 요청을 만들었고,_  
> _오늘은 그 거래를 실제로 잔액에 반영하는 과정"_ 을 배우는 거예요.

즉,

> “**Bob이 썼던 잔액은 이제 없다고 표시하고,  
> Alice가 받은 잔액은 새롭게 등록하는**”  
> **UTXO 업데이트 구조**를 구현하는 거죠.

---

# 그래서 등장하는 게 `Unspent` 클래스입니다

> **Unspent 클래스는 UTXO 상태를 관리하는 핵심 유닛입니다.**

이제부터 우리가 구현할 이 클래스는 다음 역할을 담당합니다:

- 새로운 트랜잭션이 블록에 포함되었을 때  
  → 시스템 내 잔액을 **정확하게 반영**해준다

이제 본격적으로 `Unspent` 클래스를 만들면서  
**어떻게 잔액을 저장하고, 삭제하고, 갱신하는지**를 하나씩 구현해보는 시간임!

## `Unspent` 클래스 구현 단계별 흐름

> **전제**: 현재까지 트랜잭션을 만들고, 블록에 포함되었다고 **가정**된 상태임  
> → 이제 해당 트랜잭션 내용을 바탕으로 UTXO를 갱신해야 함

---

### 1단계: `create()` – 트랜잭션의 **TxOut을 UTXO에 등록**

- 이유: 블록에 포함된 트랜잭션의 결과로 생긴 **새로운 잔액**을 반영해야 하니까
- 사용 시점: 트랜잭션의 `txOuts`를 순회할 때 사용
- 예시:
  ```ts
  txOuts.forEach(this.create(hash));
  ```

---

### 2단계: `delate()` – 트랜잭션의 **TxIn으로 기존 UTXO 제거**

- 이유: 이전에 존재했던 잔액(UTXO)은 이제 **사용되었으므로 제거**
- 사용 시점: 트랜잭션의 `txIns`를 순회하며 사용
- 예시:
  ```ts
  txIns.forEach(this.delate.bind(this));
  ```

---

### 3단계: `update()` – `create()`와 `delate()`를 동시에 수행

- 이유: 블록에 포함된 트랜잭션 1건을 **UTXO에 반영하는 전체 작업**의 핵심
- 내부적으로는:
  - `txOuts`로부터 새 UTXO 생성 → `create()`
  - `txIns`로부터 기존 UTXO 제거 → `delate()`

---

### 4단계: `getUTXO(account)` – 계정 잔액 조회

- 이유: 특정 사용자의 잔액을 확인해야 트랜잭션 생성 가능 여부 판단 가능
- 사용 예: 트랜잭션 생성 시 필요한 잔액 조회

---

### 5단계: `getAmount(utxoList)` – 잔액 합계 계산

- 이유: `getUTXO()` 결과를 바탕으로 **잔액 총합**을 계산하려면 필요
- 예: 트랜잭션을 보내기 전에 충분한 금액이 있는지 확인할 때 사용

---

### 6단계: `isAmount(account, sendAmount)` – 잔액 검증

- 이유: 보낼 금액보다 **보유 금액이 많은지** 확인해야 트랜잭션 생성 허용
- 내부에서 `getUTXO()` → `getAmount()`를 연계 호출

---

## 구현 순서

| 단계 | 메서드        | 설명                               |
| ---- | ------------- | ---------------------------------- |
| 1    | `create()`    | 새로운 TxOut → UTXO로 등록         |
| 2    | `delate()`    | 사용된 TxIn → 기존 UTXO에서 제거   |
| 3    | `update()`    | 블록 내 트랜잭션 반영 (1 + 2 결합) |
| 4    | `getUTXO()`   | 특정 계정의 보유 UTXO 조회         |
| 5    | `getAmount()` | 잔액 총합 계산                     |
| 6    | `isAmount()`  | 트랜잭션 생성 가능 여부 판단       |

## 오늘 수업 정리!

> 저번 시간! 우리는 "Bob이 Alice에게 7 비트코인을 보내는 트랜잭션"을 생성했습니다.  
> 그리고 오늘은 그 트랜잭션을 기준으로 **잔액 상태를 정리(갱신)**하는 구조를 구현하는 날입니다.

쉽게 말해…

> 저번 시간에는 **"거래 요청서를 작성"**한 날이고,  
> 오늘은 **"그 요청이 반영되어, Bob의 잔액은 빠지고 Alice의 잔액이 생기는"**  
> 실제적인 **잔액 업데이트 시스템을 구현**하는 시간입니다.

---

## 이 흐름은 어디까지 구현한 걸까요?

- **아직 네트워크 상의 채굴이나 검증은 구현하지 않았고**,
- **단일 노드에서 블록이 생성되었다고 가정**한 상태입니다.

즉, 로컬 환경에서 시뮬레이션하며 **"UTXO가 어떻게 갱신되는지"** 구조를 학습 중이고,  
**다음 수업에서는 이 구조가 P2P 네트워크를 통해 어떻게 동기화되는지**를 이어서 배우게 됩니다.
