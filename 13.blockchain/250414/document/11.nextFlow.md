# 트랜잭션 흐름 – 지금까지의 정리

## 1. 트랜잭션이란 무엇이었나요?

> 누군가가 다른 사람에게 코인을 보내는 디지털 거래 기록입니다.

- 입력값(`TxIn`)과 출력값(`TxOut`)으로 구성된 구조였고,
- 각각은 **“어디서 코인을 썼는지”, “누가 얼마를 받았는지”**를 나타냅니다.

---

## 2. 우리는 직접 트랜잭션을 만들어보았습니다

- `getUTXO()`로 사용 가능한 잔액을 확인하고
- `createInput()`으로 입력값을 구성하고
- `createOutInput()`으로 수신자와 거스름돈을 위한 출력값을 만들고
- `serializeRow()`를 통해 고유 해시 값을 생성해 트랜잭션을 완성했습니다.

예를 들어 이런 구조:

```ts
const transaction = {
  txIns: [...],
  txOuts: [...],
  hash: '...'
}
```

## 3. 생성된 트랜잭션은 잔액(UTXO)에 반영되었습니다

- `Unspent` 클래스의 `update()` 메서드를 통해
  - 사용한 입력값(`TxIn`)에 해당하는 UTXO는 **제거**
  - 새롭게 생긴 출력값(`TxOut`)은 **등록**
- 즉, 하나의 트랜잭션을 통해 **잔액 상태가 바뀌는 구조**를 완성했습니다.

## 그런데, 이런 의문이 들 수 있습니다

> “트랜잭션을 만들면 바로 블록에 들어가나요?”  
> “여러 사용자가 동시에 트랜잭션을 만들면 어떻게 되나요?”  
> “채굴자는 이걸 언제, 어디서 확인하나요?”

## 바로 이 지점에서 등장하는 것이

# 트랜잭션 풀 (Transaction Pool)

## 트랜잭션 풀이란?

> 아직 블록에 포함되지 않은 트랜잭션들이  
> **잠시 모여 대기하는 공간**입니다.

- 사용자가 트랜잭션을 생성하면
  → 곧바로 블록에 들어가는 것이 아니라
  → **일단은 트랜잭션 풀에 저장**됩니다.

누구는 memPool
누구는 txPool

- 이후 **채굴자**가 이 풀에서 트랜잭션을 선택해
  → 블록 후보에 포함시키고 채굴 시작함.
  → 블록이 생성되면 해당 트랜잭션은 **풀에서 제거**됩니다.

## 그럼 우리는 다음을 구현해야 합니다

트랜잭션 풀을 효과적으로 관리하기 위한 메서드들이 필요합니다:

| 메서드      | 기능 설명                     |
| ----------- | ----------------------------- |
| `getPool()` | 현재 트랜잭션 풀 목록 확인    |
| `update()`  | 블록에 포함된 트랜잭션을 제거 |
| `sync()`    | 여러 트랜잭션을 한꺼번에 제거 |

## 전체 흐름 정리

```
[1] 사용자 → 트랜잭션 생성
        ↓
[2] 트랜잭션 풀에 저장 (Transaction.create → 내부적으로 push)
        ↓
[3] 채굴자 → getPool() 으로 트랜잭션 목록 확인

블록 후보에 추가할 트랜잭션들을 쏙쏙 집어넣어서 채굴함.
        ↓
[4] 블록 생성
        ↓
[5] 트랜잭션 제거 (sync / update)
```

## 다음 목표는?

> 지금까지 만든 트랜잭션을 **어디에, 어떻게 저장하고 관리하는가**?.  
> 그리고 이 흐름은 **P2P 네트워크**로 확장되기 위한 첫 단추이기도 합니다.
