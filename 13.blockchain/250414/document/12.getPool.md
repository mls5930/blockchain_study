# 트랜잭션 풀 – 첫 번째 단계: `getPool()`

## 왜 이걸 먼저 만들어야 할까요?

우리는 앞에서 트랜잭션을 생성하고, UTXO를 갱신하는 흐름까지 구현했습니다.  
하지만 이건 **로컬 환경에서 한 건의 트랜잭션을 처리한 것일 뿐**,  
실제 블록체인 시스템에서는 다음 질문이 생깁니다:

> “트랜잭션을 만들었는데 지금 어디 있는 거지?”  
> “아직 블록에 들어가지 않은 거래들은 어디에 저장돼?”

## 바로 그 답이 되는 구조가 **트랜잭션 풀**입니다.

- 트랜잭션 풀은 말 그대로 **아직 블록에 포함되지 않은 거래들의 모임**입니다.
- 이 풀은 모든 노드(사용자/채굴자 포함)가 **참조하거나, 관리해야 하는 정보**입니다.
- 그리고 그 풀을 먼저 **확인할 수 있어야**, 그다음에
  - 제거하거나(`update`, `sync`)
  - 선택하거나(`createBlock`)
    할 수 있습니다.

## 그래서 가장 먼저 필요한 메서드가 `getPool()`입니다

> “현재 내 로컬에 보관 중인 모든 미확정 트랜잭션을 보여줘!”

## 메서드 정의

```ts
getPool(): TransactionPool {
  return this.transactionPool;
}
```

- `transactionPool`은 내부에 선언된 트랜잭션 대기 목록입니다.
- `getPool()`은 단순히 그 목록을 반환해줍니다.

---

## 왜 단순하지만 중요한가?

| 기능 구분         | 설명                                                      |
| ----------------- | --------------------------------------------------------- |
| 읽기 전용         | 배열을 그대로 리턴 – 수정이나 삭제는 하지 않음            |
| 블록 생성 전      | 어떤 트랜잭션을 블록에 넣을지 판단할 때 이 목록을 확인함  |
| 디버깅/디스플레이 | “지금 대기 중인 거래가 뭔지”를 확인하는 데 가장 기본이 됨 |

---

## 예시 사용

```ts
const txPool = transaction.getPool();

console.log("현재 대기 중인 트랜잭션:", txPool);
```

출력 예시:

```ts
[
  {
    txIns: [...],
    txOuts: [...],
    hash: '0xabc123...'
  },
  ...
]
```

## 언제 쓰이나요?

| 상황               | 이유                                                |
| ------------------ | --------------------------------------------------- |
| 트랜잭션 생성 직후 | "내 트랜잭션이 제대로 저장됐는지" 확인              |
| 채굴 전            | "지금 블록에 넣을 트랜잭션 후보가 뭔가요?"          |
| 블록 생성 후       | "블록에 들어간 거래는 풀에서 제거해야지!" 판단 기준 |
| 프론트 UI          | "승인 대기 중인 거래" 탭 구현 등                    |

## 결론 – `getPool()`은 단순 조회지만, 트랜잭션 풀 흐름의 시작점이다

> 이 메서드를 통해 전체 흐름의 **상태 점검**이 가능해지고  
> 이후에 이어질 `update()`와 `sync()` 같은 **제거/정리 작업의 기준**이 됩니다.

---

이제 다음 단계에서는

- `update()` – 트랜잭션 하나를 제거하거나
- `sync()` – 여러 트랜잭션을 한꺼번에 제거하는 흐름으로  
  트랜잭션 풀을 관리하는 기능들을 점점 추가하게 됩니다.
