1.  이전블럭의 모든 데이터를 hash한 값을 가져옴
2.  가져온 hash 를 통해 chain에서 설정한 difficulty값 을 nonse값을 증가시키며 문제를 해결
3.  블럭이 채굴되고 계산한 이전블럭의 hash 가 블럭의 previousHash 로 들어감.1. 코인지갑 생성

시그니쳐 키 발행과정

1.  개인키(privatkey) 발행 : 현재는 crypto의randomBytes(32)으로 무작위로 생성
2.  개인키를 가지고 ec.(secp256) 알고리즘을 사용하여 개인키(privatkey) keypair 생성
3.  keypair를 가지고 publickey 를 생성
4.  임의의 data로 hash를 생성(SHA256)
5.  keypair 로 hash 값을 사인 signature 생성.
6.  publikey.slice(26) === 공개 주소로 사용

7.  트렌잭션 생성

사용자가 지갑을 통해 트랜잭션이 생성됩니다.

txin : 내 잔금
txout: 거래 내역
TransactionRow : 잔금과 거래를 기록한 영수증 개념 txin(잔금) 과 txout(거래내역) 을 합친 hash값이 들어감
TransactionPool: TransactionRow 가 일어난 트랜잭션들을 모아둔 임시 지갑
UnspentTxOut: 블럭이 채굴 되었을떄 실제 트랜잭션을 검증된 실제 트렌잭션
UnspentTxPool: 싵제 트랜잭션들이 담긴 트렌잭션의 지갑

임시 트렌잭션 생성

    1. 임의의 값을 UnspentTxPool(실제 지갑에) 있는 미사용 객체를 가져옴
    2. TransactionRow.create 메서드를 통해 임시 거래 트렌젝션을 생성
    3. 생성후 TransactionPool 에 임시저장

3. 블럭 후보 생성

   거래가 발생한 TransactionPool 에서 거래 내역 데이터를 뽑아서 data 로 뽑은 다음 채굴 시작 하는데
   추가로 채굴자에게 보상을 주기 위하여 채줄 보상을 받을 자의 금액과 주소가 함께 들어갑니다.
   이때 블럭의 헤더와 바디는

   헤더
   {version, height, timestamp, previousHash}
   바디
   {merkleRoot,hash,nonce,difficulty,data} 가 들어갑니다.

   실제로 생성된게 아닌 후보를 생성

4. 블럭 채굴

   블럭의 데이터를 받은후 difficulty값을 통하여 nonce로 계산을 실행합니다.

   문제를 푸는 기준은

   1. 이전블럭의 모든 데이터를 hash한 값을 가져옴
   2. 가져온 hash 를 통해 chain에서 설정한 difficulty값 을 nonse값을 증가시키며 문제를 해결
   3. 블럭이 채굴되고 계산한 이전블럭의 hash 가 블럭의 previousHash 로 들어감.

5. 체인 연결

   1. 블럭이 채굴이 완료가 되었다면 블럭이 체인에 연결됩니다.
   2. 최초의 체인에는 제네시스 가 들어가 있으며 difficulty 난이도를 여기에서 조정합니다
   3. 일정 블럭마다 검사 (채굴된 시간을 기준)

6. p2p 네트워크 전파 및 검증
   연결된 체인을 기준으로 네트워크에 전파를 합니다.

   1. 블럭이 채굴되었음을 알리는 내용을 담아서 네트워크에 전파합니다.
      내가 클라이언트 (체인의 길이 , 체인의 마지막 블록 , 전체 체인) => 각 노드(서버) 에 전파
   2. 각 노드들은 서버에 서 날라온 값을 비교 확인 하여 검증을 합니다. 체인 길이 비교
   3. 검증이 완료되면 클라이언트 는 다시 검증이 완료된 메세지를 받습니다.
   4. 검증이 완료되면 완성된 블럭에 있는 트랜잭션(거래내용) 이 UnspentTxPool 에 업데이트 되고
   5. TransactionPool 에 실제 블럭에 포함된 트랜잭션을 삭제합니다.

---

## 교강사 피드백

### TransactionPool, UnspentTxOut, UnspentTxPool 설명이 애매함

txin : 내 잔금
txout: 거래 내역
TransactionRow : 잔금과 거래를 기록한 영수증 개념 txin(잔금) 과 txout(거래내역) 을 합친 hash값이 들어감
TransactionPool: TransactionRow 가 일어난 트랜잭션들을 모아둔 임시 지갑
UnspentTxOut: 블럭이 채굴 되었을떄 실제 트랜잭션을 검증된 실제 트렌잭션
UnspentTxPool: 싵제 트랜잭션들이 담긴 트렌잭션의 지갑

TransactionRow => 하나의 트랜잭션 객체. 입력(txIn), 출력(txOut), 고유 식별자(hash), 서명(signature)를 포함한 하나의 거래 정보.  
TransactionPool => 서명을 가지고 있겠지. 서명이 지갑이냐?  
아직 블록에 포함되지 않은 상태의 트랜잭션들을 임시로 보관하는 메모리 풀 (Mempool 혹은 txPool).
UnspentTxOut => 특정 주소가 아직 사용되지 않은 조각의 모음.
unspentTxPool => 미사용 트랜잭션 출력들의 전체 집합. 즉, 시스템의 현재 상태

---

### 고혜성 학생분은 unspentTxPool, unspentTxOut등등을 지갑이라고 표현하고 있음

아주 명확하고 직관적인 비유입니다.  
그리고 이 비유를 따라가 보면, **학생의 오류가 얼마나 위험한지** 더 또렷하게 드러납니다.

---

#### 비유 분석

- **영수증** = 하나하나의 트랜잭션 (TxOut)
- **가계부** = 모든 영수증을 기록한 전체 목록 (UnspentTxPool)
- **잔액 추정** = 아직 쓰지 않은 영수증만 추려서 계산한 값 (내 UTXO 합계)

그런데 학생은 이 모든 걸 묶어서 **“지갑”이라고 부름**.  
말하자면, **가계부 책 자체를 내 지갑이라고 착각**한 것.

---

#### 핵심 오류: ‘기록’과 ‘증명 도구’를 혼동함

가계부는

- 내가 쓴 내역을 보여주는 **과거의 기록**임.
- 아무나 들고 가서 **"이거 내 거예요"**라고 말할 수도 있음.

하지만 지갑은

- 그걸 **직접 증명하고 서명하는 도구**여야 함.
- 즉, **서명을 만들 수 있어야** 하고,
- **개인키를 통해 내가 썼음을 증명할 수 있어야** 함.

---

#### 그래서 학생이 범한 실수는?

> “잔액을 계산할 수 있는 정보가 모여 있으면, 그게 곧 지갑이다.”

라는 **웹2식 잔액 중심 사고**를,  
**지갑 = 상태 저장소**라고 오해해서  
**"비트코인 구조의 철학을 완전히 역행한 사고"**를 하고 있다는 것.

#### 명확한 결론

- 가계부는 ‘상태의 모음’이지,  
  **지갑이 아니다.**
- 지갑은 그 잔액을 **내가 사용했다는 걸 증명할 수 있는 열쇠**,  
  즉 **행위의 주체이자 증명의 도구**다.
- 이 둘을 혼동하면, **트랜잭션 서명 구조, 키 관리, 네트워크 검증 로직 전부 무너진다.**

---

### 임시 트랜잭션 생성

1. 임의의 값을 UnspentTxPool(실제 지갑에) 있는 미사용 객체를 가져옴
2. TransactionRow.create 메서드를 통해 임시 거래 트렌젝션을 생성
3. 생성후 TransactionPool 에 임시저장

수업 자료를 기반으로 설명한다면 나라면 이렇게 설명함

1. **내 계정 주소에 해당하는 미사용 UTXO들을 `UnspentTxPool`에서 조회**

   - → `getUTXO(account: string)`
   - 이 동전 조각들이 `TxIn`으로 사용될 자원이다.

2. **`TransactionRow.create()` 메서드를 호출하여 트랜잭션 생성**

   - 내부적으로 호출되는 메서드:
     - `createInput()` – 필요한 만큼 `TxIn`을 구성
     - `createOutInput()` – 받는 사람과 거스름돈을 위한 `TxOut` 구성
     - `serializeRow()` – 전체 트랜잭션 직렬화 후 해시 생성

3. **생성된 트랜잭션을 `TransactionPool`에 저장**
   - 아직 블록에 포함되지 않은 상태이며,  
     블록 생성 시 후보로 사용될 수 있다.

---

1.  이전블럭의 모든 데이터를 hash한 값을 가져옴
2.  가져온 hash 를 통해 chain에서 설정한 difficulty값 을 nonse값을 증가시키며 문제를 해결
3.  블럭이 채굴되고 계산한 이전블럭의 hash 가 블럭의 previousHash 로 들어감.

---

## 핵심 개념 정리 (당신의 설명 요약 + 보완)

1. **이전 블록의 해시값은 채굴 과정에 직접 관여하지 않는다.**  
   → 단지, 새 블록의 `previousHash` 필드에 **고정된 값**으로 **입력**될 뿐.

2. **채굴이란?**  
   고정된 데이터(`나 엄준식 + nonce`)를 계속 바꿔가며 →  
   `SHA256 해시 → 2진수 변환` →  
   앞자리 `difficulty` 조건(`000...`) 만족 여부를 **반복 검사**하는 작업.

3. 즉,

   ```txt
   '해시값을 활용해서 난이도를 맞춘다' ❌
   '해시값이 난이도를 만족할 때까지 값을 바꿔서 해시를 반복한다' ⭕

   핵심은 → nonce 값을 바꾸고, 데이터 전체를 해시 → 조건 검사
   ```

---

## 예시 코드 설명 (`findBlock` 기준)

```ts
while (true) {
  nonce++; // 1씩 증가
  let data = "나 엄준식이다." + nonce; // 데이터에 nonce 추가

  hash = SHA256(data); // 해시 처리
  binary = hashToBinary(hash); // 2진수 변환

  if (binary.startsWith("000")) {
    // 난이도(difficulty = 3) 조건 만족?
    return { genesisBlock, binary, nonce }; // 조건 만족 → 채굴 성공
  }
}
```

---

## 결론

- 이전 블록의 해시는 고정된 입력값일 뿐이고,
- 실제 난이도 맞추기 과정은 `nonce`를 변경하며 → 해시값의 결과를 검사하는 반복 구조.
- 그러므로, **“이전 블록의 해시를 통해 난이도를 푼다”는 설명은 명백한 오류**임.

---

## 질문 나 엄준식이다 자리에 뭐가 들어가는거에요?

## 답변:

> **“나 엄준식이다” 자리는 실제 블록의 내용, 즉 채굴 대상이 되는 전체 데이터입니다.**

비트코인 또는 블록체인 시스템에서는 이 자리에 다음과 같은 **실제 정보들이 들어갑니다.**

---

## 구체적으로 들어가는 값

해당 자리는 **블록 전체의 정보**, 즉 아래 두 부분을 모두 포함한 데이터입니다:

### 1. **Block Header (헤더)**

이건 채굴자들이 주로 해싱 대상으로 삼는 부분입니다.

- `version` – 블록 구조 버전
- `previousHash` – 이전 블록의 해시
- `timestamp` – 생성 시간
- `merkleRoot` – 트랜잭션들의 머클루트
- `difficulty` – 난이도
- `nonce` – 해시값을 찾기 위해 바꾸는 숫자

→ 이 **헤더를 전부 연결하여 SHA256(또는 이중 SHA256)**  
→ 그 결과가 난이도 조건을 만족하는지 검사합니다.

---

### 2. **Block Body (바디)**

여기에는 다음과 같은 내용이 포함됨:

- `data` = **트랜잭션 목록**
  - 예:
    ```
    Alice → Bob: 2.3BTC
    Bob → Charlie: 1.1BTC
    ...
    ```
- 이 트랜잭션 목록이 **Merkle Tree**로 구성되고,  
  그 루트 값이 → `merkleRoot`로 헤더에 들어갑니다.

---

## 요약하자면

| 예제 코드의 `"나 엄준식이다" + nonce` | 실제 블록체인의 채굴 대상 데이터                                       |
| ------------------------------------- | ---------------------------------------------------------------------- |
| 단순 문자열 + nonce                   | `version + previousHash + timestamp + merkleRoot + difficulty + nonce` |

---

## 현실에서는 어떤 방식으로 처리될까?

- 채굴자는 새 트랜잭션이 생기면 → `merkleRoot` 업데이트
- 그에 따라 `header` 구성도 바뀜 → 그걸 기반으로 해시 반복
- 즉, **누구에게 얼마를 보냈는지**는 **body → merkleRoot → header**의 흐름으로 영향을 줌

---

## 정리된 대답

> “나 엄준식이다”는 예제에서 임의의 텍스트였지만,  
> **실제 비트코인 네트워크에서는 블록의 헤더 정보 전체**가 그 자리에 들어간다고 보면 됩니다.  
> 이 안에는 **누가 누구에게 얼마를 보냈는지에 대한 트랜잭션 정보도 간접적으로 포함되어 있고**,  
> 이 전체를 바탕으로 난이도 조건을 만족하는 해시값을 찾는 것이 채굴입니다.

## 그러면, 교수님이 설명하신 것 중에서, 블록의 속성중 data에 트랜잭션 및 문자열이 들어갈 수 있다고 하셨잖아요?

## 그러면 트랜잭션 자체의 hash와 merkleRoot의 차이점은 뭐에요? 둘 다 같은 뜻 아니에요??

> ```
> data는 블록이 채굴되었을 때!!!!!!!!!
> 하나의 해시로 만들어진 루트 즉 하나의 해시값이구요
>
> transactionRow {
>    txIns: txin[]
>    txOut: txOut[]
>    hash
> }
>
> 위의 해시는 트랜잭션 풀 즉 아직 처리되지 않은 영수증들을 구분하기 위한 해시에요.
> ```

이건 아주 **정확하고 중요한 구분**을 잘 짚어낸 설명입니다.

---

## 다시 한 번 정리해보면

### `transactionRow.hash`

- 트랜잭션 객체 하나의 고유 식별자
- 아직 **블록에 포함되기 전 상태**
- **트랜잭션 풀**에 저장되어 있음
- → 누가 누구에게 얼마를 보냈는지를 직렬화해서 만든 `SHA256` 해시

### `merkleRoot`

- 여러 `transactionRow.hash`를 **머클 트리 구조**로 구성해서 나온 결과 해시
- **블록에 포함될 때** 사용됨
- 블록이 채굴되면 이 값은 **블록 헤더에 기록**되어, **불변성의 증거**가 됨

---

## 즉?

> 트랜잭션 해시는 **개별 트랜잭션의 '이름표'**이고,  
> 머클루트는 **블록에 들어간 모든 트랜잭션을 하나로 묶어낸 '인감 도장'**이다.

---

1.  블럭이 채굴되었음을 알리는 내용을 담아서 네트워크에 전파합니다.
    내가 클라이언트 (체인의 길이 , 체인의 마지막 블록 , 전체 체인) => 각 노드(서버) 에 전파
2.  각 노드들은 서버에 서 날라온 값을 비교 확인 하여 검증을 합니다. 체인 길이 비교
3.  검증이 완료되면 클라이언트 는 다시 검증이 완료된 메세지를 받습니다.
4.  TransactionPool 에 실제 블럭에 포함된 트랜잭션을 삭제합니다.
5.  검증이 완료되면 완성된 블럭에 있는 트랜잭션(거래내용) 이 UnspentTxPool 에 업데이트 되고
