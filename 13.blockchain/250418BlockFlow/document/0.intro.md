## 블록 생성부터 전파까지 – 전체 흐름 리스트

### [A] 지갑 생성 – 네트워크 참여 준비

1. 각 노드는 고유한 **지갑(Wallet)** 을 생성한다
   → 개인키(PrivateKey), 공개키(PublicKey), 주소(Account) 생성
   → 이것이 **"나"를 증명할 수 있는 유일한 구조**

---

### [B] 트랜잭션 생성 – 사용자 행동 발생

2. 사용자가 지갑을 통해 **송금 트랜잭션**을 생성한다  
   → 송신자 지갑이 `Transaction.create()` 호출  
   → `서명(Signature)` 포함
3. 생성된 트랜잭션은 **트랜잭션 풀(txPool)** 에 등록된다

---

### [C] 블록 후보 생성 – 노드 내부 처리

4. 노드는 새로운 **블록 후보(Block Candidate)** 를 생성한다  
   → Body: [코인베이스 트랜잭션 + txPool의 일반 트랜잭션들]
5. **코인베이스 트랜잭션**이 가장 먼저 삽입된다  
   → 채굴 보상을 받을 주소는 해당 노드의 지갑 주소

---

### [D] 채굴(mining) – 경쟁 과정

6. 블록 후보에 대해 `nonce` 값을 조정하며  
   `SHA256(block)` 해시값 계산 반복
7. **난이도 조건**을 만족하면 채굴 성공

---

### [E] 블록 전파 – 네트워크 동기화

8. 채굴된 블록을 **P2P 네트워크에 브로드캐스트** 한다  
   → `client.ts`가 `p2p.ts`에 전달  
   → `replaceChain()` 통해 블록을 반영
9. 다른 노드들은 받은 블록의 유효성을 검증하고  
   → 조건 만족 시 체인을 교체한다

## [F] 트랜잭션 정리 및 순환 (UTXO 처리 포함)

10. **블록에 포함된 트랜잭션들은 txPool에서 제거**된다  
    → 더 이상 처리 대상이 아니므로 삭제

11. **UTXO 구조를 기준으로, TxIn에 사용된 기존 객체(UTXO)를 제거**한다  
    → 해당 트랜잭션이 블록에 포함됨으로써  
    → **“사용된 것으로 인정” → 사용한 잔액은 시스템에서 제거**

12. **TxOut에 해당하는 새로운 UTXO 객체들을 등록한다**  
    → 즉, 잔액이 새롭게 생긴 계정에게 “남은 금액”을 객체로 기록  
    → 이 과정을 통해 **현재 계정들의 최신 잔액 상태**가 유지된다

13. 이후, 네트워크는 새로운 트랜잭션 생성을 기다리고  
    → 다시 블록 후보 생성 → 채굴 과정을 반복한다
