# **상태(State) 변수 vs 로컬(Local) 변수**

여기서부터는 조금 더 현실적인 질문을 던져야 합니다.

우리가 기존에 쓰던 자바스크립트나 타입스크립트를 떠올려봅시다.

이런 언어들에도

- **전역 변수(global variable)**
- **지역 변수(local variable)**

라는 개념이 존재했습니다.

- 전역 변수는 어디서든 접근할 수 있고,
- 지역 변수는 함수 안에서만 잠깐 쓸 수 있었죠.

이제 Solidity에서도  
비슷하게 익숙한 개념이 등장합니다.

다만,  
**블록체인은 하나 다른 점이 있습니다.**

> **"여기서는 변수를 어디에 선언하느냐에 따라,  
> 그 값이 영원히 기록되기도 하고,  
> 트랜잭션이 끝나면 사라지기도 한다"**는 점입니다.

## **1. 상태(State) 변수**

- 컨트랙트 바깥에 선언합니다. (함수 바깥)
- 블록체인 Storage에 기록됩니다.
- **모든 노드가 이 값을 복제하고 저장합니다.**
- 트랜잭션이 끝나도 절대 사라지지 않습니다.
- 값을 바꾸면 가스비가 발생합니다.

쉽게 말해서,  
**"이건 블록체인에 영구히 남을 기록"**입니다.

예를 들어,

```solidity
contract Example {
    uint public count = 0;
}
```

이 `count`는

- 세폴리아 네트워크에도,
- 전 세계 모든 노드에도  
  동일하게 기록됩니다.

그리고 수정할 때마다  
가스비를 내야 합니다.

## **2. 로컬(Local) 변수**

- 함수 안에 선언합니다.
- Memory(임시 저장 공간)에 잠깐 저장됩니다.
- 트랜잭션이 끝나면 사라집니다.
- Storage를 차지하지 않습니다.
- 별도의 가스비(저장비용)가 들지 않습니다.

예를 들어,

```solidity
function addOne() public {
    uint temp = count + 1;
}
```

이 `temp`라는 변수는

- `addOne` 함수가 실행되는 동안에만 존재합니다.
- 트랜잭션이 끝나면 메모리에서 사라집니다.
- 블록체인에는 남지 않습니다.

**로컬 변수는 그냥 계산용, 일시적 보조 역할**이라고 생각하면 됩니다.

## **왜 이 구분이 중요할까?**

블록체인에서는

- 무엇을 기록할 것인가,
- 무엇은 기록하지 않을 것인가

이 선택이  
**비용과 신뢰**를 결정합니다.

잘못해서 불필요한 데이터를 상태 변수로 선언하면,

- 가스비를 낭비하고,
- 체인에 쓸데없는 부담을 주고,
- 네트워크 전체에 쓸모없는 기록을 남기게 됩니다.

반대로,  
진짜 중요한 데이터를 로컬 변수로만 처리했다면,

- 트랜잭션이 끝나면 날아가버리고,
- 나중에 그 기록을 증명할 방법이 사라집니다.

## **한 줄 정리**

> **"상자를 어디에 둘 것인가? 영원히? 잠깐?"**

이 구분은

- 가스비,
- 데이터 구조,
- 전체 설계 철학에  
  직접적인 영향을 줍니다.

하지만,  
여기서 끝나지 않습니다.

상자를 만든 다음에는  
또 다른 중요한 질문이 필요합니다.

> **"이 상자는 누구에게 열려 있어야 할까?"**

블록체인에서는

- 모든 데이터가 복제되고,
- 누구나 접근할 수 있는 특성상,

**"무엇을 저장할지"** 만큼이나  
**"누구에게 보여줄지"**를 정하는 것도 중요합니다.

따라서, Solidity에서는  
변수를 만들 때 **접근 권한**을 명시적으로 설정하도록 강제합니다.

지금부터는,  
**변수에 문을 달아서  
누가 이 상자에 들어올 수 있는지 정하는 방법**을 배워보겠습니다.
