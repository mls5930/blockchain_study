# 변수 하나가 왜 중요한가?

```solidity
contract A {
    uint public count = 0;
}
```

이건 아주 간단한 Solidity 코드입니다.

여기에는 **변수 하나**가 선언되어 있습니다.

우리는 이전까지 자바스크립트나 타입스크립트에서  
변수를 이렇게 선언했었죠.

```javascript
const count = 0;
```

하지만 Solidity에서는 조금 다릅니다.

> **[타입] [접근자] [변수명] = [초기값];**

```solidity
contract A {
  uint256 public count = 10;
}
```

이렇게,  
**"어떤 데이터 타입을 가질지"**와  
**"누가 이 변수를 볼 수 있을지"**를  
**처음부터 명확하게 선언**합니다.

## **스마트 컨트랙트에서의 변수는 무엇인가?**

Solidity에서도 변수는 여전히,  
**"데이터를 담는 작은 상자"**입니다.

다만 이 상자는,  
**내 컴퓨터 메모리 안**에만 있는 게 아닙니다.

- 블록체인 전체에 복제될 것이고,
- 네트워크 모든 노드에 저장될 것이다.

작지만,  
**엄청나게 무거운 상자**가 되는 셈입니다.

## **변수를 만든다는 건 기록을 만든다는 것**

여기서 중요한 차이점이 있습니다.

일반 프로그램에서는 변수를 만들고 지우는 게 가볍습니다.  
하지만 블록체인에서는 변수를 만든다는 것은,  
**영구적으로 기록을 남긴다는 뜻**입니다.

기록을 남긴다는 건

- 가스비가 든다는 뜻이고,
- 책임이 생긴다는 뜻입니다.

## **위의 간단한 변수를 선언하고 배포한다면, 실제로 이런 일이 벌어집니다**

```solidity
contract A {
    uint public count = 0;
}
```

이 코드를 컴파일하고 네트워크에 배포한다고 가정해봅시다.

그러면 내부에서는 다음과 같은 일들이 일어납니다:

---

### 1. 컴파일: EVM이 읽을 수 있는 바이트코드 생성

- 우리가 작성한 Solidity 코드는  
  스마트 컨트랙트 바이트코드(기계어)로 변환됩니다.
- 이 바이트코드 안에는  
  `count` 변수를 생성하고,  
  초기값 `0`을 설정하는 명령이 포함됩니다.

---

### 2. 배포 트랜잭션 생성

- 이 바이트코드를 담은 트랜잭션을 만들어서
- 네트워크(예: 세폴리아)에 전송합니다.
- 트랜잭션에는 가스(gas) 비용도 함께 포함됩니다.

---

### 3. 네트워크 전파 및 블록에 포함

- 트랜잭션은 네트워크를 통해 퍼집니다.
- 여러 노드들이 트랜잭션을 받아들이고,
- 채굴자/검증자가 이 트랜잭션을 블록에 포함시킵니다.

---

### 4. 각 노드가 컨트랙트를 생성하고 상태를 저장

이제 중요한 부분입니다.

블록에 트랜잭션이 포함되면,  
**각 노드가 직접 이 트랜잭션을 검증합니다.**

여기서 **EVM**이 등장합니다.

> **"EVM은 네트워크에 하나만 존재하는 거대한 컴퓨터가 아닙니다."**  
> **"각 노드가 자신만의 EVM 인스턴스를 가지고 있습니다."**

- 각각의 노드 안에는  
  독립적으로 동작하는 **EVM 실행 환경**이 존재합니다.
- 이 EVM이 바이트코드를 읽고 해석하여,  
  컨트랙트를 생성하고 상태를 기록합니다.

즉,  
**모든 노드가 각각 자기 안에서 같은 과정을 실행**하는 것입니다.

> "네트워크 전체가 하나의 컴퓨터처럼 보이지만,  
> 사실은 수많은 EVM 인스턴스들이 각자의 컴퓨터에서 동시에 작동하는 구조입니다."

---

여기서 한 가지 중요한 점이 있습니다.

**EVM은 물리적인 컴퓨터가 아닙니다.**

EVM은

- 특정한 규격을 가진
- 소프트웨어 기반의 **가상 실행 환경**입니다.

실제로, 우리가 실습에서 사용할

- **Ganache** (가나슈)나
- **Hardhat** (하드햇) 같은 개발 도구 안에도  
  **EVM이 자바스크립트로 구현되어 내장**되어 있습니다.

즉, 우리가 Ganache를 켜서 스마트 컨트랙트를 배포할 때도,

- 실제로는 Ganache 안에 있는 **자바스크립트로 구현된 EVM 인스턴스**가
- 트랜잭션을 처리하고,
- 상태를 기록하는 것입니다.

이후에 우리가 배우게 될:

- Ganache
- Hardhat
- Truffle

같은 도구들은  
**모두 EVM을 소프트웨어 형태로 내장하고 있는 개발 환경**입니다.

> **"EVM은 네트워크마다 다르고,  
> 노드마다 존재하며,  
> 다양한 도구 속에서도 구현되어 있다."**

이 점을 꼭 기억해야 합니다.

---

그 결과,  
각 노드는

- 새로운 스마트 컨트랙트를 생성하고,
- `count = 0`이라는 상태를
- **자신들의 Storage 공간에 기록**합니다.

이 기록은  
컨트랙트가 삭제되지 않는 이상,  
**영원히 블록체인에 남게 됩니다.**

그렇다면, 이제 중요한 질문을 던져야 합니다.

> **"우리는 어떤 형태의 데이터를 남길 것인가?"**

블록체인은 자유롭게 메모장을 쓰듯 데이터를 기록할 수 있는 곳이 아닙니다.

- 공간이 한정되어 있고,
- 기록 비용(가스비)이 존재하고,
- 모두가 복제해서 영구히 저장해야 합니다.

따라서,  
**우리가 남기는 데이터는 반드시 명확하고, 필요한 형태로 선언되어야 합니다.**

그리고 그 출발점이 바로  
**기본 타입**입니다.

> **"기록의 시작은, 데이터를 어떤 형태로 설계할지 정하는 것에서 출발합니다."**

그래서 이제,  
블록체인에 남길 데이터를 설계할 때 사용하는  
가장 기본적인 데이터 타입들을 소개하겠습니다.
