# 그러면 이 변수들은 실제로 어디에 저장될까?

우리는 지금까지  
`uint public count = 0;`  
같은 변수를 선언해왔습니다.

그런데, 여기서 자연스럽게 이런 질문이 생깁니다.

> **"이렇게 선언한 상자들은 실제로 어디에 존재할까?"**

---

## 컴퓨터에서는 메모리(RAM)

블록체인에서는?

일반 프로그램에서는

- 변수를 선언하면 메모리(RAM)에 저장되고,
- 프로그램이 종료되면 메모리도 초기화됩니다.

**하지만 블록체인은 다릅니다.**

블록체인에서 변수를 만든다는 것은,  
**"전 세계 수천 대 노드들이 이 데이터를 복제하고 함께 저장한다"**는 뜻입니다.

> **"변수를 하나 만든다는 것은,  
> 블록체인 네트워크 전체에 책임을 남긴다는 것이다."**

## Storage와 Memory: 단순 저장 공간 이상의 의미

Solidity에서는 변수를 저장할 때  
**크게 두 가지 공간**을 구분합니다.

### 1. Storage (스토리지)

- 영구 저장소입니다.
- 블록체인의 "상태(state)"에 기록됩니다.
- 트랜잭션을 통해 변화하고, 영원히 남습니다.
- 가스비가 많이 듭니다.  
  (모든 노드가 이 변화를 함께 기록해야 하기 때문입니다.)

### 2. Memory (메모리)

- 임시 저장소입니다.
- 트랜잭션이 실행되는 동안만 존재합니다.
- 작업이 끝나면 메모리는 사라집니다.
- Storage에 비해 가스비가 훨씬 적게 듭니다.

한마디로 정리하면,

> **"Storage는 세상을 바꾸는 기록,  
> Memory는 순간 계산을 위한 작업 공간"**입니다.

## 그런데 여기서 정말 중요한 질문이 생깁니다.

> **"내가 컨트랙트 안에 count 변수를 0 → 1로 바꾼다면,  
> 그게 진짜 네트워크 전체 상태를 바꾸는 것인가?"**

정답은,  
**"네, 맞습니다."**

이더리움 블록체인은

- 모든 지갑(Account)와
- 모든 스마트 컨트랙트(Account)

의 현재 상태를  
**하나의 거대한 '네트워크 상태(state)'**로 관리합니다.

컨트랙트 하나도 이 전체 상태의 일부입니다.  
컨트랙트 안의 변수도 전체 상태 구조에 포함됩니다.

> **"컨트랙트 하나의 변수(count)를 바꾸는 것조차,  
> 결국 네트워크 전체 상태를 바꾸는 일이다."**

## 상태(state)는 이렇게 연결되어 있습니다.

이더리움 네트워크는  
**Merkle Patricia Trie**라는 거대한 트리 구조를 사용해  
전체 상태를 저장합니다.

각 계정(Account)은

- 잔액(balance),
- 논스(nonce),
- 코드 해시(codeHash),
- 스토리지 루트(storageRoot)

를 가지고 있고,  
컨트랙트의 변수들은 이 storageRoot 아래에 관리됩니다.

따라서,  
내가 `count` 변수를 0 → 1로 바꾸면

- storageRoot가 바뀌고,
- 컨트랙트 계정의 상태가 바뀌고,
- 전체 네트워크 상태 트리도 업데이트됩니다.

그리고 이 업데이트는  
**모든 노드가 함께 검증하고 복제**합니다.

바로 이 과정 때문에

- 블록체인은 느리고,
- 가스비가 들고,
- 신뢰성이 높은 것입니다.

## 요약

- **Storage를 수정한다** → 블록체인의 상태(state)를 바꾼다.
- **Memory만 사용한다** → 블록체인의 상태는 그대로다.
- Storage를 바꾸는 작업만이  
  진짜 트랜잭션으로 기록되고,  
  네트워크 전체에 퍼진다.
- 이 구분을 이해하는 것이  
  **EVM을 이해하는 진짜 출발점**이다.

## 최종 흐름

- Storage는 "세상의 상태"를 변화시키는 무거운 기록
- Memory는 트랜잭션 중 잠깐 쓰고 사라지는 가벼운 공간
- 단순 저장 공간 차이가 아니라, **책임과 비용 구조**를 구분하는 철학

## 그래서, 우리는 여기까지 이런 이야기를 해왔습니다.

- 변수를 선언한다는 것은,
- 블록체인 네트워크 전체에 책임을 남기는 일이고,
- 이 Storage라는 공간에 기록된다는 것을 확인했습니다.

그리고 우리는 알게 되었습니다.

> **"컨트랙트 안의 변수 하나를 바꾸는 것도,  
> 결국은 네트워크 전체 상태를 바꾸는 일이다."**

Storage는 무겁습니다.

- 변화를 기록하려면 네트워크 전체가 움직이고,
- 가스비가 발생하며,
- 영원히 흔적이 남습니다.

반대로,  
Memory는 가볍습니다.

- 트랜잭션 실행 중 잠깐만 존재하고,
- 블록체인에는 남지 않으며,
- 책임도, 비용도 거의 없습니다.

---

그런데 여기서,  
또 하나 중요한 사실이 드러납니다.

> **"우리가 메모리를 어떻게 사용하느냐에 따라,  
> 우리의 책임과 비용이 달라진다."**

단순히

- 변수를 만들었다,
- 상태를 바꿨다  
  를 넘어서,

**"이 변수를 어디에, 어떤 방식으로 저장할 것인가"**를 고민하는 순간,

**EVM 안에서 실제로 메모리가 어떻게 관리되는지**를 알아야만 합니다.

---

## 그래서, 이제는

이 질문을 던질 수밖에 없습니다.

> **"EVM 안에서는 우리가 만든 변수들이 어떻게 다뤄질까?"**

- Memory는 정확히 어떤 역할을 하고,
- Storage와는 무엇이 다르고,
- 우리의 코드 설계가 어떻게 비용에 영향을 미치는가?

이것을 이해하지 않고는,  
**Solidity를 제대로 쓴다고 말할 수 없습니다.**

## 다음 이야기

> **우리의 책임이 메모리를 만든다: EVM과 메모리 구조 이야기**

이제 이 주제로  
더 깊이 들어가겠습니다.
