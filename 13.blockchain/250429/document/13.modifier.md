# 행동에도 조건이 필요하다: modifier

이 모든 것들은 결국 하나를 가리킵니다.

**상태를 변화시키는 행동을 하고 싶다!**

**그놈의 변화, 그놈의 트랜잭션.**  
ㅋㅋㅋ

하지만 맞습니다.

스마트 컨트랙트에서 우리가 작성하는 대부분의 함수들은

- 잔액을 변화시키거나,
- 상태를 변화시키는

**"행동"** 들입니다.

그리고 우리는 이 행동들을 할 때마다  
늘 질문하게 됩니다.

> **"아무나 이 행동을 해도 되는 걸까?"**  
> **"언제든지 이걸 허용해도 괜찮을까?"**

# 행동에는 조건이 필요할 수도 있다

---

스마트 컨트랙트는 단순한 코드 덩어리가 아닙니다.

- 누가
- 언제
- 어떤 상황에서

**어떤 행동을 할 수 있는지**를  
**명확히 통제해야 하는 상황이 존재합니다.**

그리고 우리는,  
그 필요에 따라  
**직접 그 통제를 코드로 작성해야 합니다.**

왜냐하면,

- 스마트 컨트랙트 안에서 벌어지는 (거의) 모든 행동들은
- 결국 **트랜잭션(transaction)** 을 발생시키고,
- 이 트랜잭션은 블록체인에 기록되어
- **상태(state)** 를 영구히 변화시키기 때문입니다.

그래서,  
**변화가 발생할 때**  
**특정한 조건을 걸어 통제하고 싶다면,**

그럴 때 사용하는 것이 바로

**modifier**입니다.

## modifier란 무엇인가?

> **modifier는 "행동에 조건을 걸어주는 필터 장치"입니다.**

- 함수를 실행하기 전에
- 반드시 어떤 조건을 검사하게 하고
- 그 조건을 통과해야만 함수 본문이 실행되도록 만듭니다.

---

## 간단한 예시

```solidity
modifier onlyOwner() {
    require(msg.sender == owner, "Not authorized");
    _;
}

function withdraw() public onlyOwner {
    // 오직 owner만 이더를 인출할 수 있음
}
```

- `onlyOwner`라는 modifier는
- `withdraw()` 함수를 실행하기 전에
- 반드시 `msg.sender == owner`인지 검증합니다.
- 검증에 통과하지 못하면 함수는 실행조차 되지 않습니다.

---

## modifier가 필요한 이유

스마트 컨트랙트는 **"열린 세상"** 에 존재합니다.

- 누구나 함수를 호출할 수 있습니다.
- 누구나 트랜잭션을 보낼 수 있습니다.

하지만,  
**모든 행동이 모든 사람에게 허용되어야 하는 것은 아닙니다.**

---

modifier를 통해 우리는

- 어떤 함수는 "관리자만" 실행할 수 있게 만들고,
- 어떤 함수는 "특정 조건을 만족하는 경우"에만 열리게 만들 수 있습니다.

**행동을 통제할 수 있어야만,  
우리는 스마트 컨트랙트를 안전하고 신뢰성 있게 유지할 수 있습니다.**
