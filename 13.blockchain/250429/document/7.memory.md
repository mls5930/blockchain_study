## **우리의 책임이 메모리를 만든다: EVM과 메모리 구조 이야기**

우리가 어떤 스마트 컨트랙트를 배포하든,  
EVM(Ethereum Virtual Machine)은 기본적으로 **작은 메모리만 준비**해 둡니다.

처음에는,

- 거의 아무것도 저장되어 있지 않고,
- 메모리 크기도 최소한으로 설정되어 있습니다.

> **"하지만 우리의 행동(책임)에 따라 메모리는 확장된다."**

우리가 변수를 추가하고,  
상태를 변경하고,  
데이터를 기록할수록,  
EVM은 필요한 만큼 메모리를 늘려 나갑니다.

즉,  
**"네가 얼마나 많은 것을 기록하느냐"**에 따라  
**EVM의 메모리 크기와 비용도 함께 커진다**는 뜻입니다.

## **메모리(Memory) vs 스토리지(Storage)**

여기서 다시,  
**Memory**와 **Storage**의 차이를 정확히 짚어야 합니다.

| 구분      | Memory               | Storage     |
| :-------- | :------------------- | :---------- |
| 생명 주기 | 트랜잭션 동안만 존재 | 영구히 저장 |
| 비용      | 상대적으로 저렴      | 훨씬 비쌈   |
| 용도      | 일시 계산용          | 상태 기록용 |

- Memory는  
  → 함수 실행 중 잠깐 필요한 데이터를 올려두는 공간입니다.

- Storage는  
  → 블록체인에 영원히 남겨야 할 데이터를 저장하는 공간입니다.

두 개념을 구분해서 쓰지 않으면,

- 가스비 폭탄이 터지거나,
- 설계가 엉망이 될 수 있습니다.

## **저장은 Slot이라는 단위로 이루어진다**

Storage에 데이터를 저장할 때는  
무작정 쌓는 게 아니라,  
**Slot**이라는 단위로 관리됩니다.

> **"32바이트 조각으로 쪼개 저장한다."**

한 Slot은 32바이트입니다.  
(256비트 = 32바이트 = 16진수로 64자리)
uint256 public status = 1;

- `uint256` 같은 큰 데이터는 Slot 하나를 통째로 사용합니다.
- 작은 데이터(`uint8`, `bool`)는 하나의 Slot 안에 여러 개가 들어갈 수도 있습니다.

이 구조를 이해하면,  
나중에 **가스비 최적화**할 때 큰 도움이 됩니다.

## **Storage는 영구 저장소 → 비용이 많이 든다**

Storage는

- 블록체인 전체 노드에 기록되고,
- 영구히 남기 때문에,

가스비가 매우 많이 듭니다.

변수 하나를 Storage에 새로 쓰거나,  
기존 값을 바꾸거나 하면,

- 가스비가 크게 소모되고,
- 계약이 무거워집니다.

> **"Storage에 기록한다는 건, 영원히 남는 약속을 추가하는 것이다."**

그래서 Storage에 데이터를 쓸 때는  
**정말 필요한 것만** 남겨야 합니다.

## Memory는 트랜잭션이 끝나면 사라진다

반면, Memory는

- 트랜잭션 실행 중에만 존재하고,
- 작업이 끝나면 사라집니다.

그래서 Storage보다

- 훨씬 가볍고,
- 훨씬 저렴합니다.

하지만, Memory에 있는 데이터는  
블록체인에 기록되지 않기 때문에,  
**상태를 변경하는 데는 쓸 수 없습니다.**

> 계산은 Memory,  
> 기록은 Storage.

이 원칙을 분명히 구분해야 합니다.

## 우리의 코드가 메모리 사용량을 결정한다

EVM은 기본적으로 최소한의 메모리만 제공합니다.  
우리가 코드를 작성하면서

- 변수를 추가하고,
- 데이터를 다루고,
- 복잡한 로직을 구성할수록

필요한 메모리 양이 계속 늘어납니다.

결국,  
코드가 커질수록

- 메모리 확장 비용이 발생하고,
- 트랜잭션 가스비도 함께 늘어나며,
- 관리 비용까지 높아집니다.

> 설계 초기부터 메모리 사용을 고려해야 합니다.

## Storage와 Memory를 반드시 구분하라

Storage와 Memory를 혼동하면

- 불필요한 비용이 생기고,
- 데이터 손실이나 버그 위험도 커집니다.

Solidity는 이를 구분하기 위해  
`memory` 키워드를 명시적으로 요구합니다.

> **"Storage에 둘 것인가, Memory에 둘 것인가."**  
> 이 선택은 설계자의 책임입니다.

## 좋은 설계 = 비용 절감 + 책임 명확화

좋은 스마트 컨트랙트는

- 반드시 필요한 데이터만 Storage에 기록하고,
- 임시 계산은 Memory로 처리합니다.

이렇게 하면

- 가스비를 절감하고,
- 블록체인 자원을 아낄 수 있으며,
- 계약이 간결하고 안전해집니다.

> **"우리가 관리하는 것은 코드가 아니라 책임이다."**

Storage를 아끼고,  
Memory를 정확히 사용하는 것,  
그것이 Solidity 설계의 기본 철학입니다.

## 요약

- EVM 메모리는 기본적으로 작고, 우리의 코드에 따라 확장된다.
- Storage = 영구 기록 (비용 큼), Memory = 임시 계산 (비용 적음).
- Storage는 32바이트 Slot 단위로 저장된다.
- 설계할 때 Storage와 Memory를 명확히 구분해야 한다.

## 그런데, 여기서 중요한 것이 하나 빠졌습니다.

우리는 지금까지  
`function A() public pure returns (...) {}`  
처럼 자연스럽게 **함수(function)** 를 선언하고 사용해왔습니다.

하지만,  
이 **function**이 실제로 무엇을 의미하는지,  
왜 필요한지,  
어떤 책임을 가지는지에 대해서는  
한 번도 제대로 짚고 넘어간 적이 없습니다.

## 그래서 이제 다음 주제는

`## 함수는 무엇인가?`

입니다.
