# 전체 코드 분석 (3.substr.md)

```ts
class CryptoModule {
  static hashToBinary(hash: string): string {
    for (let i = 0; i < hash.length; i += 2) {
      const hexByte = hash.substr(i, 2);
      console.log(hexByte);
    }
    return "";
  }
}
```

## 작동 흐름 요약

이 함수는 다음 흐름을 따릅니다:

1. **입력값으로 해시 문자열을 받는다.**
2. 해시 문자열을 **2글자씩 끊어서 읽는다**.
3. 각 두 글자는 **16진수 1바이트**를 의미한다.
4. 지금은 각 바이트를 **출력만 하고 있음(console.log)**.
5. 아직 **2진수로 변환하거나 리턴하는 로직은 미구현 상태**.

## 예시로 해석해보기

### 입력 예시:

```ts
CryptoModule.hashToBinary("a3b91f");
```

### 문자열: `"a3b91f"`

총 길이: 6 → 2바이트씩 끊으면 3조각

### for문 작동:

| `i` 값 | `hash.substr(i, 2)` 결과 | 설명           |
| ------ | ------------------------ | -------------- |
| 0      | `"a3"`                   | 첫 번째 바이트 |
| 2      | `"b9"`                   | 두 번째 바이트 |
| 4      | `"1f"`                   | 세 번째 바이트 |

결과적으로, 콘솔에는 다음이 출력됩니다:

```ts
a3
b9
1f
```

---

## 여기서 왜 2글자씩 자를까?

- SHA-256 해시 결과는 보통 64자리 16진수 문자열입니다.
- 16진수 2자리는 **1바이트(8비트)**를 표현합니다.
- 따라서 **2자씩 자르면 정확히 바이트 단위로 처리**할 수 있게 됩니다.

---

## ✅ 요약 정리

| 요소            | 설명                                         |
| --------------- | -------------------------------------------- |
| `hash`          | 해시값 입력 (16진수 문자열)                  |
| `i += 2`        | 해시를 2자리씩 자르기 위한 인덱스 증가       |
| `substr(i, 2)`  | 현재 위치에서 2글자를 추출해 한 바이트로 봄  |
| `console.log()` | 자른 결과를 출력하여 확인 (디버깅 목적)      |
| `return ""`     | 아직 변환 결과는 반환하지 않음 (미완성 상태) |

---

## ⏭️ 이후 단계 예고

이제 다음 단계에서는 다음이 필요합니다:

1. `hexByte`를 10진수로 변환 → `parseInt(hexByte, 16)`
2. 10진수를 2진수로 변환 → `toString(2).padStart(8, "0")`
3. 변환된 값을 누적해서 완성된 2진수 문자열을 리턴

필요하시면 완성된 버전도 함께 보여드릴게요!
