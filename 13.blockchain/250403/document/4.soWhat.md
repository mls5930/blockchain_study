# 그래서 이게 채굴이랑 뭔 상관? (4.soWhat.md)

> “해시를 2진수로 바꾸는 게 도대체 채굴이랑 무슨 상관인데요?”

---

## 답변: 이진수 변환은 `검증의 기준선`을 만들기 위한 과정이다

블록을 만들려면 ‘특정 조건’을 만족하는 해시값이 나와야 함.  
그 조건이 바로:

> “해시값이 앞에서부터 몇 개의 0으로 시작해야 한다”

라는 거야.

그런데 해시값은 **기본적으로 16진수 문자열**이기 때문에, **0이 몇 개 있는지 정확히 보려면 2진수로 바꿔야 해.**

## 왜 2진수로 변환해야 하냐?

예를 들어 해시값이 아래와 같다고 해보자:

```ts
해시값: "0f23...";
```

이걸 보면, 앞에 `"0"`이 있으니까 0으로 시작하는 것 같지?  
하지만 이 `"0"`은 16진수 `"0"`일 뿐이고, 이건 **2진수로 바꾸면 `0000`**이야.

그런데 `"f"`는 16진수 `"1111"`이니까  
`0f`는 실제로 2진수로 보면 `00001111`이야.

만약 우리가 **난이도 5 (앞에 5비트가 0)**라고 한다면,  
2진수로 바꿔야 **비트 단위로 정확히 비교**할 수 있어.

## 그래서 `hashToBinary()`는 뭐하는 놈이냐?

해시값을 받아서:

```
"a3b91f" → 101000111011100100011111
```

이렇게 **비트 단위로 바꿔줘야**,  
우리가 `"00000"`처럼 앞에서부터 0이 몇 개냐를 확인할 수 있어.

```ts
if (binary.startsWith("0".repeat(difficulty))) {
  // 조건 만족! 블록 생성 성공!
}
```

## 채굴은 어디서 일어나냐?

> 채굴은 결국 "이 조건을 만족하는 해시값"을 찾기 위한 **반복 연산**이야.

1. 데이터를 구성하고
2. `nonce`를 바꿔가며
3. 해시값을 만들고
4. 그 해시값을 2진수로 바꾸고
5. 그 결과가 `00000...`으로 시작하면 성공

즉, 이진수 변환은 **5번의 판단을 위한 준비단계**야.

## 이제 직접 퍼즐을 풀어볼 시간입니다

내가 블록을 만든다는 가정 하에,  
조건을 만족하는 해시값을 찾을 때까지  
`nonce`를 바꿔가며 퍼즐을 풀어보는 코드 실습을 해보겠습니다.

이 실습의 목표는 채굴(mining) 과정을 아주 간단하게 구현해보는 것.

- 어떤 데이터를 기준으로
- SHA256 해시를 계속 만들고
- 그걸 2진수로 변환해서
- 조건을 만족하는 순간까지 반복하는 구조죠.

이제 우리가 만들 파일 이름은 mining.ts입니다.

여기에 지금까지 배운 걸 바탕으로
"정답이 나올 때까지 무식하게 해시를 시도해보는" 채굴 퍼즐을 구현할 거예요.
