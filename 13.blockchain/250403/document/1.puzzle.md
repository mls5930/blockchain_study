# 해시와 난이도의 관계, 그리고 채굴 퍼즐 (1.puzzle.md)

지난 시간에 우리는 **머클 트리**와 **머클 루트**를 배웠습니다.  
간단히 복습해볼까요?

- 데이터를 해시값으로 변환하고,
- 그 해시값들을 **쌍으로 묶어서 또 해시**하고,
- 이를 반복해서 최종적으로 **하나의 루트 해시값**을 얻는 구조였죠.

이 과정에서 중요한 건 바로 **"해시"** 였습니다.

## 해시란?

여기서 잠깐, "해시"에 대해 조금 더 짚고 넘어갈게요.

- 해시는 암호화 기술이 아닙니다.
- 단순히 문자열(데이터)을 입력하면 고정된 길이의 16진수 문자열로 변환해주는 함수입니다.

즉, 해시는 데이터를 **압축**하고, **추상화**한 값일 뿐이죠.  
그런데 이 해시값을 **블록체인에서 어떻게 활용**하느냐가 중요한 포인트입니다.

---

### 왜 해시를 2진수로 바꾸나요?

블록체인의 핵심 개념 중 하나가 바로 **난이도(difficulty)** 입니다.  
이 난이도는 “특정 조건을 만족하는 해시값”을 찾는 데 쓰이죠.

## 퍼즐 구조로 이해해보자

블록체인에서 새로운 블록을 만들 때는 **문제 풀이 과정**이 필요하다고 했었죠?

이 과정을 우리는 **채굴** 이라고 부릅니다.
그럼 우리가 문제를 푼다는건, 출제자가 있고,  
출제자는 문제를 냅니다.

---

### 출제자(네트워크)의 문제

```sh
주어진 base 값과 nonce 값을 조합해서 SHA256 해시를 만든다.
그 해시값의 **앞 N자리가 0**으로 시작하면 "성공"이다.
```

즉, "해시값의 앞 4자리가 0000이면 블록 생성 성공!"
이게 이 퍼즐의 정답 조건입니다.

근데 해시값은 16진수입니다.  
해시값의 앞 몇 자리가 `0`으로 시작해야 한다면?

해시값은 기본적으로 **16진수**이기 때문에,  
이 조건을 정확하게 비교하려면 **2진수(binary)** 로 바꿔서 확인해야 합니다.

---

### 그래서 뭘 해야하는데요?

위의 문제를 볼 때, base가 주어진다고 칠게요

base => "hello"

그럼 나는 여기에 **nonce** 라는 숫자를 계속 바꾸어서 붙히는 겁니다.

```ts
"hello0"
"hello1"
"hello2"
"hello3"
...
```

그리고 매번 이 문자열의 해시값을 확인해.

```ts
SHA256("hello0") → a23f…
SHA256("hello1") → 9120…
SHA256("hello23982") → 0000efde… ✅ 성공!
```

---

### 그래서 이게 퍼즐인거임

- 우리는 정답을 **직접 계산해서 만들 수 없음**.
- 대신 계속 바꿔보는 수밖에 없어. **운이 좋아야 빨리 나오고**, 아니면 **수십만 번 계산**해야 돼.
- 그래서 이걸 **"난이도 있는 문제"**라고 부르고,
- 그 과정을 우리는 **채굴(mining)**이라고 불러.

---

### 그래서 이게 `난이도(difficulty)`인 이유

이 퍼즐의 핵심은:

- 조건을 만족하는 해시값이 나올 확률이 매우 낮다는 것.
- 앞자리에 0이 하나 있을 확률은 1/16,
- 두 개가 00일 확률은 1/256,
- 네 개 0000이면? → 1/65536! (사실상 로또급)

앞에 0이 많아질수록  
**원하는 조건을 만족시키는 해시값을 찾기가 점점 어려워집니다.**

그만큼 더 많은 시도를 해야 하니까, 그걸 **"난이도"**라고 부르는 거예요.

---

### 이게 바로 채굴(mining)의 본질

- 출제자가 퍼즐을 냈고,
- 나는 해시값의 조건을 만족할 때까지 계속 시도해야 합니다.
- 누군가 먼저 정답을 찾으면,
  그 사람이 블록을 만들 수 있는 권한을 얻습니다.

---

### 왜 이게 “의도된 비효율”일까?

이 방식은 **엄청나게 비효율적**입니다.
전 세계 수천 대의 컴퓨터가 같은 퍼즐을 풀고 있어요.
그런데 이 무식한 구조 덕분에…

> “누가 열심히 계산했는가?”
> 이걸 중앙 관리자 없이 모두가 납득하게 됩니다.

이게 블록체인의 **가장 비효율적이면서, 동시에 가장 아름다운 구조**예요.

---

### 오늘 할 것

- 해시 → 2진수 변환기능을 갖춘 `CryptoModule`을 만들어 봅니다.
- 이 코드는 **제네시스 블록 생성**, 그리고 나중에 배울 **채굴** 개념과도 연결됩니다.

---

### 파일 만들기

이제 `src/core/crypto/crypto.module.ts` 파일을 만들어봅시다!  
그리고 여기에 `hashToBinary()`라는 함수를 직접 구현해볼 거예요.
