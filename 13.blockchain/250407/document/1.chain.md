# 왜 체인일까?

> **체인은 블록의 일련된 과정을 파악할 수 있는 ‘맥락’입니다.**

---

## 1. 블록 하나만 보면 충분해 보이죠?

블록 하나를 열어보면  
우리가 원하는 정보는 대부분 다 들어 있습니다:

- 거래 데이터
- 생성 시간 (timestamp)
- 블록의 해시값

이쯤 되면 이런 의문이 들 수 있습니다:

> “근데 굳이 **이전 블록의 해시값(previousHash)** 까지  
>  들고 다녀야 할 이유가 있을까요?”

## 2. 정답은 "연결"이 아니라, **맥락과 신뢰의 축적**

하나의 블록은 단지 **현재 상태**만 보여줄 뿐입니다.  
하지만 우리는 그 상태가 **어떤 흐름 속에서 만들어졌는지**를 알아야 합니다.

> 우리는 단순한 기록을 만들고 싶은 게 아닙니다.  
> 우리는 **“신뢰할 수 있는 기록”**,  
> 즉, **"왜 이 블록이 여기에 있어야 하는가?"**를 설명할 수 있는 맥락이 필요합니다.

## 3. 블록체인의 핵심 질문은 이것입니다

> “이 데이터가 **정당하게 쌓인 것**이며,  
> 조작되지 않았다는 걸 어떻게 증명할 수 있을까?”

## 4. 비트코인의 대답: **참조와 연결을 통한 검증**

사토시 나카모토의 대답은 단순하지만 강력했습니다:

> "과거 기록을 **참조하면서 연결**하면  
>  중간 하나만 바꿔도 \*\*전체가 깨지게 만들 수 있다."

이 철학은 기술로 이렇게 구현됩니다:

```ts
block.previousHash === 이전 블록의 hash
```

이 연결은 단순한 링크가 아닙니다.  
**"과거에 대한 증거"**이자,  
**"변조를 막기 위한 자물쇠"**입니다.

## 5. 그래서 나온 구조: Chain (사슬)

- 누군가 중간 블록을 조작하면?  
  → 해시값이 바뀌고  
  → 다음 블록의 previousHash와 충돌  
  → 이후 모든 블록이 무효화됩니다

> 하나만 건드려도 전체가 깨지는 구조  
> → 이게 바로 **Chain**, 신뢰의 사슬입니다.

## 6. 단순한 연결이 아닙니다 — **시간을 따라 쌓이는 맥락**

- 블록이 많을수록 조작은 어려워지고
- 체인이 길어질수록 그 이력은 **더 신뢰할 만한 기록**이 됩니다

이건 단순한 배열이 아닙니다.  
**시간과 검증을 따라 축적된 신뢰의 흐름**,  
즉 **블록들의 ‘맥락’**입니다.

## 오늘 수업의 진짜 목표

오늘 우리는 단순히 `Block[]` 배열을 구현하는 게 아닙니다.  
우리는 지금부터:

> **“신뢰는 어떻게 축적되는가?”**  
> **“데이터는 어떻게 역사를 갖게 되는가?”**

그 철학을 **코드로 직접 구현**해보는 시간을 갖습니다.  
그리고 그 구조가 바로, 체인입니다.
