# 자 이제 이걸 말할 차례입니다. `Pattern`

우리는 지금까지 Proxy라는 구조에 대해서 살펴봤습니다.
상태는 남기고, 로직만 바꾸는 아주 특별한 구조.
fallback을 이용해 요청을 대신 받고, delegatecall을 통해 실행을 넘기고…

그런데,
이 구조를 사람들이 **단순히 기술적 구조**라고 부르지 않습니다.
이걸 우리는 **“프록시 패턴(Proxy Pattern)”** 이라고 부릅니다.

> 그렇다면 질문이 생깁니다.
> “패턴이란 도대체 무엇인가요?”

## 현실 세계에서의 '패턴'이란?

우리가 일상에서 말하는 패턴은 이런 겁니다:

- 타일 바닥 무늬에서 반복되는 무늬
- 천장 몰딩이나 벽지에 새겨진 디자인의 반복
- 사람의 행동 습관에서 나타나는 일정한 규칙성

즉,
**패턴이란 반복적으로 나타나는 형태이자, 구조이며, 일정한 규칙을 가진 반복입니다.**

## 그런데, 프로그래밍에서의 '패턴'은 조금 다릅니다

프로그래밍에서는 "패턴"이라는 단어가 아주 중요한 의미를 갖습니다.
그건 단순한 반복이 아니라…

> **“반복해서 마주치는 문제를, 반복해서 사용할 수 있는 방식으로 해결한 구조”**

를 말합니다.

---

### 소프트웨어 패턴의 정의

- 동일한 문제가 여러 번 등장할 때,
- 매번 새롭게 해결하지 않고,
- 이미 검증된 구조를 **재사용 가능하게 만든 해결 방식**

이게 바로 **디자인 패턴(Design Pattern)** 입니다.

---

### 예: 우리가 이미 본 패턴들

- `Factory Pattern`: 똑같은 구조를 여러 번 찍어내야 할 때
  → DAO 수업에서 우리가 `new DAO()`로 찍어낸 컨트랙트가 대표적이죠.

- `Observer Pattern`: 상태가 변하면 자동으로 알림을 보내는 구조
  → 웹3 프론트엔드에서 상태 변경을 감지해 반응하는 구조가 이에 가깝습니다.

그리고 오늘, 우리가 배우는 구조는 바로 이겁니다:

> **“Proxy Pattern”**
> → 상태는 남기고, 로직만 교체할 수 있는 구조적 해결법

## 블록체인에서의 '패턴'은 무엇이 다른가?

자, 이제 중요한 질문입니다.

> “그럼 블록체인에서의 패턴은 뭐가 다르죠?”

블록체인은 기본적으로 **불변(immutable)**을 전제로 합니다.
모든 코드와 상태는 한 번 배포되면 바꿀 수 없습니다.
**바꿀 수 없다는 특성은 신뢰를 보장하지만, 동시에 진화를 막습니다.**

### 블록체인의 핵심은 '불변성'입니다

저는 이렇게 표현하고 싶습니다.

> **“모든 걸 검증 가능하게, 안전하게, 바꿀 수 없도록 기록하자.”**

블록체인의 구조는 이렇게 말하고 있는 셈입니다:

> “네가 어떤 데이터를 남기든 알 빠 아니야.
> 하지만 한 번 기록된다면,
> 너조차도 바꿀 수 없어.
> 대신 누구나 검증할 수는 있어.”

→ **검증은 열려 있고, 변경은 닫혀 있습니다.**

이 철학은 아주 합리적입니다.  
탈중앙화 시스템에서는 **중앙이 없기 때문에 신뢰는 '기록'으로부터 나옵니다.**  
그래서 모든 데이터는 **트랜잭션**으로 남기고,  
그 트랜잭션은 **해시**로 고정되고,  
누구나 확인은 가능하되, 변경은 불가능합니다.

---

### 하지만 이 구조는 ‘변화를 어렵게 만듭니다’

코드도, 상태도 쉽게 바꿀 수 없습니다.  
실수 하나에도 새로 배포해야 하고, 주소가 바뀌면 이전 상태는 무의미해집니다.  
이건 기술적 문제가 아니라, **철학적인 설계 제한**입니다.

> **“영원히 지워지지 않고, 바뀔 수 없는 시스템”** 안에서
> 우리는 이제 이렇게 묻기 시작합니다.

> _“이런 시스템 안에서, 변화는 어떻게 가능한가?”_

---

## 그 해답이 여기에서 말하는 프록시 ‘패턴’입니다

블록체인에서 말하는 패턴은 단순히 "자주 쓰는 코드 템플릿"이 아닙니다.

> **“불변이라는 제약 속에서, 변화 가능성을 확보하기 위한 구조”**

그 구조적 해법이 바로 **패턴**입니다.

---

### 그리고 Proxy는 그 대표적인 패턴입니다

- 상태를 Proxy 쪽에 남겨둡니다
- 로직은 외부 Implementation으로 분리합니다
- fallback → delegatecall로 실행을 위임합니다
- 코드는 갈아끼우지만, 저장된 값은 유지됩니다

이건 그냥 구조가 아니라,
**블록체인이 가진 철학을 거스르지 않으면서도
변화에 대응할 수 있도록 고안된 설계 패턴**입니다.

---

## 정리하면

블록체인은 기본적으로 말합니다.

> “바꿀 수 없어야 믿을 수 있다.”

그런데 우리는 이렇게 응답합니다.

> “그럼 바꾸지 않고도,
> 마치 바꾼 것처럼 만드는 방법을 생각해보자.”

이렇게 탄생한 구조.
**그게 바로 '패턴'입니다.**

그리고 Proxy는 그 대표적인 사례입니다.
불변을 거스르지 않으면서, 진화를 가능하게 만든 구조.

---

> **“블록체인은 바꾸지 않는 철학을 품고 있지만,
> 그 위에서 살아가는 우리는 늘 바꾸고 싶어 한다.”**

그 욕망과 철학의 절충점이 바로
**‘패턴’**입니다.
