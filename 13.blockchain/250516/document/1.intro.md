## **시작 – 구조를 기억했던 우리는, 이제 구조를 바꾸고 싶어진다**

지난 수업에서 우리는 DAO 컨트랙트를 직접 만들었습니다.
그리고 `new DAO()`를 호출할 때마다, 새로운 조직 하나가 탄생했습니다.

이 흐름은 단순했지만 매우 강력했습니다.
사용자가 버튼 하나만 누르면, 새로운 DAO가 하나 생성되고
그 안에는 안건을 제안하고 투표하는 모든 구조가 갖추어졌죠.

그 중심에는 Factory가 있었습니다.
우리는 Factory를 통해 **"DAO의 구조"**를 기억해두었고,
필요할 때마다 `new DAO()`를 호출해,
그 구조를 바탕으로 복제된 객체를 만들어냈습니다.

---

이때까지만 해도 문제는 없었습니다.  
우리가 만들고 싶은 구조를 코드로 짜고,  
그 코드를 기억해두고,  
필요할 때마다 똑같은 구조를 뽑아내면 되었으니까요.

하지만 시간이 지나며, 문제가 생깁니다.  
**어느 날 누군가가 말합니다.**

> “투표 기능에 찬성 이유를 적을 수 있게 하면 좋겠어요.”

그리고 우리는 다시 코드를 고쳐서, 새로운 DAO를 배포합니다.  
하지만 문제가 있습니다.

이미 기존에 배포한 DAO들은 어쩌죠?  
그 안에 담긴 **상태(state)**, 즉 투표 기록은 어쩌죠?  
새로운 기능이 필요하다고 해서 DAO를 새로 만들면  
기존의 DAO는 **버려지는 구조**가 됩니다.

이건 단순한 코드 문제가 아닙니다.  
**신뢰와 책임의 문제**입니다.  
“누가 이 기능을 추가했는가?”,  
“기존 데이터는 어디에 남는가?”  
“그 변경을 사용자에게 어떻게 알릴 것인가?”

---

우리는 깨닫습니다.  
**"구조를 기억하는 것"만으로는 충분하지 않다.**  
**"구조를 바꿀 수 있어야 한다."**

하지만,  
블록체인은 구조를 쉽게 바꾸게 허락하지 않습니다.  
한 번 배포된 컨트랙트는 바꿀 수 없습니다.  
아예 **코드 자체가 바뀌지 않도록 고정**됩니다.

---

그래서 오늘의 수업은 이 질문으로 시작합니다.

> **“바꿀 수 없는 컨트랙트,
> 그 상태를 유지한 채 로직만 바꿀 수 있을까?”**

우리는 이 질문을 쫓아갑니다.  
그리고 오늘,  
**Proxy 패턴**이라는 새로운 구조를 마주하게 될 것입니다.

그 구조 안에서는,  
코드는 바뀔 수 있고,  
주소는 유지되며,  
사용자의 상태는 그대로 남습니다.

---

이제,
**“기억해서 생성하는 구조”**에서
**“기억해서 대신 실행하는 구조”**로
