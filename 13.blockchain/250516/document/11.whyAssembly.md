# 그럼 fallback 안에 그냥 함수 호출 쓰면 안 되나요?

여러분, 우리는 지금까지 Proxy 구조에서
`fallback()` 함수가 **모든 호출을 대신 받아준다**는 사실을 배웠습니다.

그리고 이 fallback은 이렇게 생겼죠?

```solidity
fallback() external payable {
    delegate(getImpl());
}
```

어딘가 이상하죠?

> “delegate라는 함수가 왜 따로 필요하죠?”
> “그냥 이렇게 쓰면 안 되나요?”

```solidity
fallback() external payable {
    getImpl().increment();
}
```

아주 합리적인 질문입니다.
그리고 이 질문은 우리가 **delegatecall의 정체**를 이해하는 데 결정적인 역할을 합니다.

## 안 되는 이유 – Proxy는 어떤 함수가 호출될지 모른다

첫 번째 이유입니다.

Proxy는 **자기 자신 안에 어떤 함수가 호출될지 전혀 모릅니다.**

```solidity
function increment() public {}
function decrement() public {}
```

이건 모두 **Implementation 컨트랙트에만 존재하는 함수**입니다.
Proxy는 이런 함수의 **이름도, 인자도, 리턴값도 모릅니다.**

→ 즉, Proxy 안에서 `impl.increment()`라고 하려면
**먼저 increment라는 함수가 정의돼 있어야 하고**,
**그 파라미터 형식도 알아야 하고**,
**그 리턴 타입도 알아야 합니다.**

하지만 지금 Proxy는 이런 걸 **전혀 모른 채**,
그냥 **사용자가 어떤 함수든 던져준 걸 전부 중계**해야 합니다.

## 그래서 필요한 방식 – “그냥 전부 다 넘겨줘”

우리가 지금 만들고 싶은 Proxy는 이런 구조입니다:

> “사용자가 어떤 ABI 인코딩 데이터든 던지면,
> 그걸 있는 그대로 가져다가 로직 컨트랙트에게 넘기고,
> 결과도 그대로 사용자에게 전달해주자.”

이건 마치 이런 겁니다:

- “무슨 함수가 올지 몰라요.”
- “그냥 받은 데이터를 있는 그대로 delegatecall에 넘기고,
  그 결과도 가공 없이 그대로 반환할래요.”

이걸 Solidity 문법만으로는 구현할 수 없습니다.

## 그래서 Assembly가 필요한 구조입니다

우리는 다음과 같은 요구사항을 만족해야 했죠:

1. 어떤 함수든 받아야 한다 (`increment`, `decrement`, `setTitle`, 등)
2. 어떤 인자든 알아서 처리해야 한다 (없을 수도 있고, 3개일 수도 있음)
3. 리턴값도 어떻게 생겼든 **그대로** 전달해야 한다

Solidity는 이렇게 추상적인 호출을 직접 처리하지 못합니다.
**반드시 타입을 알고 있어야 하기 때문**입니다.

그래서 우리는 저수준 언어, **Assembly**로 직접 처리해야 합니다:

```solidity
calldatacopy(0, 0, calldatasize())            // 인코딩된 데이터 그대로 복사
delegatecall(gas(), impl, 0, size, 0, 0)      // 그대로 실행
returndatacopy(0, 0, returndatasize())        // 결과 그대로 복사
```

→ 이 코드는 **함수 이름, 파라미터, 리턴 타입을 전혀 몰라도**,
단지 “데이터를 통째로 넘기고 받기”만 하면 되기 때문에 가능한 겁니다.

## 정리: 왜 Solidity 함수 호출로는 불가능한가?

| 방식                        | 설명                                                                 |
| --------------------------- | -------------------------------------------------------------------- |
| `impl.increment()`          | ✅ 명확한 함수 호출. 하지만 타입과 함수 이름을 알고 있어야만 가능    |
| `delegate(impl)` (assembly) | ✅ 어떤 함수가 올지 몰라도 전부 수용. calldata, returndata 모두 다룸 |
| Solidity 함수 기반 fallback | ❌ fallback은 타입을 몰라서 직접 호출할 수 없음                      |

## 무리 – Proxy는 _모르는 걸 대신 처리해야_ 합니다

Proxy는 아주 독특한 구조입니다.
**스스로는 아무 함수도 정의하지 않았지만**,
사용자가 보내는 모든 요청을 **대신 받아서 실행**해야 합니다.

→ 그걸 가능하게 만드는 유일한 방법이 바로
**“타입도 이름도 모른 채, 전체 calldata를 전달하는 delegatecall 구조”**입니다.

---

다음 시간에는 이 delegate 구조를 실제로 **한 줄씩 Assembly로 뜯어보며**,
**Proxy가 진짜 어떻게 중계자 역할을 수행하는지** 확인해봅시다.
이게 바로 블록체인 세계에서
**“몸은 Proxy, 뇌는 Implementation”** 구조를 가능케 하는 비밀입니다.
