# Proxy 패턴 수업 – 실행 흐름 가이드

> “우리는 상태를 유지하면서 로직만 바꾸고 싶습니다.
> 그 구조를 눈으로 보고, 손으로 체험해보는 것이 오늘 실습의 목적입니다.”

## 1단계 – 맨 처음, 어떤 컨트랙트부터 배포할까?

> 구조의 뼈대를 먼저 세웁니다.
> **상태(state)를 기억하고, 외부 로직을 대신 실행할 주체**, 즉 **Proxy**부터 배포합니다.

### 해야 할 일:

- `Proxy.sol`을 컴파일합니다.
- 배포할 환경을 선택합니다 (Remix 기준: JavaScript VM / Injected Provider).
- **Proxy 컨트랙트를 먼저 Deploy**합니다.

### 왜 이렇게 시작할까?

- Proxy는 “로직”이 아니라 “기억하고 실행할 틀”입니다.
- 이 틀이 먼저 있어야 나중에 로직(Implementation)을 연결할 수 있습니다.
- 마치 ‘뇌’가 아니라 ‘몸’을 먼저 만든다고 생각하면 됩니다.

## 2단계 – 로직 컨트랙트 (Count) 만들기: Version 1

> 이제 Proxy가 “무엇을 실행할지”를 기억해야 합니다.
> 실행할 코드는 어디에 있어야 할까요?
> → 바로 `Count.sol`입니다.

### 해야 할 일:

- `Count.sol`을 열고 컴파일합니다. (`increment()`만 있는 버전)
- 별도로 `Count`를 **직접 Deploy**합니다.

### 왜 이걸 따로 배포할까?

- 이건 실제 사용자가 호출할 함수 로직을 담고 있는 “진짜 코드”입니다.
- Proxy는 이 주소를 기억해두고, delegatecall로 “대신 실행”하게 됩니다.

## 3단계 – Proxy에 로직 연결하기 (`setImpl()`)

> 이제 Proxy에게 알려줘야 합니다.
> “이 주소에 있는 함수를 대신 실행해줘!”

### 해야 할 일:

- Proxy 인스턴스에서 `setImpl()` 호출
- 파라미터로는 방금 배포한 `Count`의 주소를 넣습니다.

### 무슨 일이 일어나나?

- Proxy는 내부 슬롯(IMPL_SLOT)에 이 주소를 저장합니다.
- 이후 Proxy에 어떤 함수 호출이 오든
  → 그 요청을 해당 주소로 delegatecall하게 됩니다.

## 4단계 – Proxy를 통해 함수 호출해보기 (기본 로직 확인)

> 이제부터 핵심 실습입니다.
> **Proxy는 로직을 직접 갖고 있지 않습니다.**
> 하지만 우리는 Proxy에게 직접 요청을 보냅니다.

### 해야 할 일:

- Proxy 인스턴스 주소를 복사
- Remix에서 `Count` 컨트랙트를 선택
- **At Address** 버튼을 누르고 Proxy 주소를 붙여넣습니다

→ 이제 Proxy에게, Count의 ABI로 접근하게 됩니다.

### 테스트:

- `increment()` 호출
- `count()` 조회 → 값이 올라간 것을 확인

### 왜 이게 가능할까?

- 함수는 Proxy에 존재하지 않음
- fallback() → delegate() → Count의 `increment()` 호출
- 상태는 Count가 아니라 Proxy에 저장됨 (이게 핵심)

## 5단계 – 새로운 로직으로 교체해보기 (CountV2)

> 자, 세상이 변했습니다.
> 사용자 요청: “이제 `decrement()`도 넣어주세요.”

→ 로직은 바뀌지만, **상태는 유지되어야** 합니다.

### 해야 할 일:

- `Count.sol`을 `CountV2`로 복제해서, `decrement()` 함수 추가
- 컴파일 후 배포

### 그리고:

- Proxy에서 다시 `setImpl()` 호출
  → 이번엔 `CountV2`의 주소를 넘깁니다

## 6단계 – Proxy는 로직이 바뀌었는데 상태는 그대로?

### 테스트:

- 다시 Proxy에 `increment()` 호출
- `count()` 값 확인 → 기존 상태 그대로 유지
- 이번엔 `decrement()` 호출도 테스트
- 상태가 Proxy에 남아 있기 때문에, **기존 값에 변화가 이어지는 것**을 확인할 수 있음

## 7단계 – 마무리 체험: Proxy 없이 CountV2를 직접 호출해보면?

> 이제 궁금한 실험 하나

- Proxy 안 쓰고, CountV2에 직접 `increment()` 호출하면?
- → Proxy의 `count`는 안 바뀜
- 이유: 상태 저장소가 다르기 때문
  → 즉, **Proxy는 상태를 가진 몸이고, Count는 로직만 가진 뇌**인 셈

## 오늘 실습의 핵심 인식

> Proxy 구조란,
> **“상태는 그대로, 로직만 바꿀 수 있는 구조”를 코드로 구현한 것**입니다.

- Proxy는 함수 하나 없이도 작동합니다.
- delegatecall 덕분에 실행은 다른 주소에서 이뤄집니다.
- 그런데도 상태는 내가 갖고 있습니다.
