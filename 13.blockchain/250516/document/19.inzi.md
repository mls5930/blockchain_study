# 여러분들에게 바라는 최소한의 지식과 태도

우리는 이번 주에 Proxy 패턴을 배웠습니다.
그리고 다음 주에는 본격적으로 **계정 추상화(ERC-4337)**로 넘어갑니다.

그런데 한 가지 말씀드리자면…

> **이걸 모른 채로 계정 추상화를 배우는 건, 지도를 보지 않고 낯선 도시를 걷는 것과 다를 바 없습니다.**

## 여러분이 꼭 인지하고 계셔야 할 것들

다음 주 수업을 **조금이라도 덜 고통스럽게**,
**좀 더 깊이 있게** 받아들이기 위해서는
이번 주에 배운 **개념들 몇 가지는 반드시 체화되어 있어야 합니다.**

이건 그냥 예습 수준이 아닙니다.
**“이걸 인지하지 못한 상태”로 다음 단계를 배우는 건 비효율의 연속일 뿐입니다.**

## 반드시 알고 있어야 할 실행 흐름의 본질

다음 항목들은 머리로만 아는 게 아니라,
“실제로 손으로 짜봤고, 실행해봤고, 이해한 적이 있다”는 수준이길 바랍니다.

---

### 1. **컨트랙트는 다른 컨트랙트를 호출할 수 있다**

- 컨트랙트 A가 컨트랙트 B를 `call()`하거나 `delegatecall()` 하는 것은
  함수 호출과 똑같은 수준으로 **자연스럽게 이루어지는 구조**입니다.

- 이건 "특별한 기능"이 아니라 **EVM이 처음부터 그렇게 설계된 것**입니다.
  (참고: Yellow Paper - Execution Environment 구조)

- 이걸 이해하지 않으면 다음 주 구조도, 흐름도 모두 불투명해집니다.

---

### 2. **delegatecall은 ‘코드는 빌리고, 상태는 내 것’ 구조다**

- Proxy 패턴에서의 핵심:
  → 코드 실행은 Implementation이 하지만,
  → 상태 저장은 Proxy의 컨텍스트에서 이뤄진다.

- 이게 곧 **실행 컨텍스트를 유지한 채, 외부 코드를 실행하는 방식**입니다.

- delegatecall의 실행 원리는 calldata 전달, returndata 복사 흐름까지
  assembly 기반에서 정확히 한 줄 한 줄 뜯어봤습니다.

---

### 3. **EVM은 호출할 때마다 Execution Context를 생성한다**

- 하나의 외부 트랜잭션 안에서도 컨트랙트 간 호출이 발생하면
  → EVM은 **call stack을 쌓고**,
  → 각각의 호출마다 **msg.sender, value, storage context**를 따로 관리합니다.

- 이런 컨텍스트 전환이 자연스럽게 이해되어야
  다음 주 EntryPoint → Account → App 호출 구조를 따라갈 수 있습니다.

---

### 4. **트랜잭션은 단 하나지만, 호출은 여러 번 일어난다**

- 외부 트랜잭션은 EOA에서 단 한 번 일어납니다.

- 그러나 그 트랜잭션 하나가 Proxy → Impl → 또 다른 컨트랙트로 이어질 수 있고,
  이 과정은 모두 내부 message call로 처리됩니다.

- 그래서 서명은 한 번, 실행은 여러 번.
  이게 바로 **계정 추상화에서 EntryPoint가 전부 처리하는 구조**와 연결됩니다.

---

### 5. **컨트랙트는 직접 서명하지 않는다. 하지만 호출은 한다**

- CA는 개인키가 없기 때문에 **서명은 불가능**합니다.
  하지만 **EVM 안에서는 다른 컨트랙트를 호출하고, 값도 넘기고, 실행도 합니다.**

- 이 원리를 모르면,
  → “컨트랙트가 실행되는데 왜 서명 안 했지?”
  같은 혼란에 빠질 수 있습니다.

## 마무리 – 이번 주의 지식은 다음 주 수업의 GPS입니다

여러분, 우리는 단순히 delegatecall이나 fallback 함수를 배우고 끝난 게 아닙니다.

> 우리는 지금,
> **EVM이 실행을 어떻게 관리하는지**,
> **실행 주체와 코드 실행 위치가 분리될 수 있는 구조가 어떻게 가능한지**,
> 그 뼈대를 체험한 것입니다.

다음 주 수업은 이 구조 위에 새로운 기능을 더하는 것입니다.
즉, Proxy가 익숙하다면 → 계정 추상화의 흐름도 자연스럽게 이어질 것입니다.

## 다음 주 계정 추상화 수업에 들어가기 전까지

여러분에게 요청드립니다:

- 위 5가지 개념을 **다시 복습하고, 말로 설명할 수 있을 정도로 정리**해두세요.
- 가능하다면 직접 `delegatecall`, `returndatacopy`, `msg.sender` 변화 등을 다시 실습해보세요.

---

> 다음 주는 단순히 “지갑 없이 로그인할 수 있어요” 수준의 이야기가 아닙니다.
>
> **“계정(Account)을 스마트 컨트랙트로 재정의하고,
> 검증과 실행 책임을 코드로 설계하는 구조”**에 들어갑니다.

그 시작은 바로 여러분이 이번 주에 배운 **Proxy 구조를 얼마나 진지하게 받아들였는가**에 달려 있습니다.
