# **구조적 해결 – 상태와 로직을 분리하자 (Proxy 등장)**

우리는 방금, 하나의 중요한 딜레마를 마주했습니다.  
**로직은 진화해야 하지만, 상태는 유지되어야 한다.**

이건 단순한 기술 문제가 아닙니다.  
스마트 컨트랙트의 **존재 방식 전체를 다시 설계**해야 한다는 요구입니다.

---

그렇다면 질문을 이렇게 바꿔보겠습니다.

> “정말로, 로직만 바꾸고 상태는 그대로 남길 수 있을까?”

정답은 **“예”**입니다.
하지만 기존의 방식으로는 불가능합니다.
그래서 우리는 **새로운 구조**를 도입하게 됩니다.

그 구조의 이름이 바로 **Proxy**입니다.

## **Proxy란?**

그렇다면 이 구조의 이름인 **Proxy**란 무엇일까요?

> 먼저 단어부터 살펴봅시다.

**Proxy**는 원래 **대리인, 대행자, 대신 처리해주는 존재**를 뜻합니다.
현실에서도 우리는 종종 이런 말을 쓰죠.

- "출석을 proxy로 대신해줘"
- "위임장을 작성해 proxy에게 처리 맡겼어"

즉, Proxy란 **진짜 당사자를 대신해서 행동하거나 응답하는 존재**입니다.

## **프로그래밍에서의 Proxy**

이 개념은 프로그래밍에서도 동일하게 등장합니다.  
실제 객체를 직접 다루지 않고, **그 앞단에 놓여서 대신 중계하거나 제어하는 구조**를 말합니다.

예를 들어:

- 사용자가 어떤 객체의 메서드를 호출하면,
- Proxy가 그 요청을 가로채고,
- 필요하면 가공하거나, 조건을 검사하거나, 다른 대상에게 넘깁니다.

이걸 통해 우리는 **접근 제어, 로깅, 캐싱, 지연 실행(lazy loading)** 같은 다양한 기능을 구현할 수 있죠.

즉, Proxy는 **“실행의 중개자”**라는 패턴으로
**OOP (객체지향)** 세계에서도 흔히 쓰이는 구조입니다.

## **그럼 블록체인에서의 Proxy는?**

이제 블록체인에서 Proxy를 사용할 때의 맥락으로 돌아와 봅시다.

블록체인에서 Proxy는 이렇게 말합니다:

> “나는 진짜 로직은 가지고 있지 않아.
> 하지만 네 요청을 대신 받아서,
> 내가 기억하고 있는 **Implementation(실제 로직)**에게 넘겨줄 수 있어.”

그리고 더 놀라운 건,

> **“그 로직은 바꿔가면서도,
> 내 주소와 상태는 절대 바뀌지 않도록 지킬 수 있어.”**

이게 가능한 이유는
우리가 앞에서 본 `delegatecall`이라는 명령 덕분입니다.
로직은 외부 코드에게 위임하지만,
**상태는 Proxy 자신 기준으로 유지되기 때문이죠.**

## 그래서 정리하면…

> **Proxy는 "중간에서 대신 실행해주는 중계자"입니다.**

그리고 이 개념은:

- 네트워크에서도 (HTTP Proxy 등)
- 객체지향에서도 (접근 제어용 Proxy 객체)
- 블록체인에서도 (불변 구조 속 유연성을 확보하기 위한 설계 방식)

→ **모두 동일한 핵심 원리를 공유하고 있습니다.**

**다만 블록체인에서는 이 구조가 철학적인 제약(불변성)을 해결하는 실질적인 기술로서 더욱 중요해지는 것이죠.**

## **개념 정리: Proxy 구조의 원리**

Proxy 패턴은 구조적으로 다음 두 가지를 **완전히 분리**합니다:

- **Proxy:** 상태를 보관하는 주체. 사용자가 직접 호출하는 주소.
- **Implementation:** 기능을 담은 코드만 존재. 직접 호출되지 않음.

사용자의 눈에는 Proxy만 보입니다.  
사용자는 Proxy에게 `increment()`, `decrement()` 같은 함수를 호출합니다.  
하지만 실제로 Proxy 안에는 그런 함수들이 없습니다.

---

### **함수는 없지만, 대신 실행할 구조는 있다**

Proxy는 호출된 함수가 없을 때 **`fallback()` 함수**로 응답합니다.
그리고 이렇게 말하죠:

> “나한테 그 함수는 없어.
> 하지만 내가 기억하고 있는 로직 컨트랙트 주소(Implementation)가 있어.
> 그쪽 코드 대신 실행할게.”

이때 실행되는 명령이 바로 **`delegatecall`**입니다.
