# **fallback이란?**

지난 시간, 제가 **스마트 컨트랙트에는 ‘필수 함수’들이 있다**고 말씀드렸죠?

그중 하나가 바로 `receive()` 함수였습니다.

이 함수는 단 하나의 역할을 합니다.

> 누군가 이더(ETH)를 전송했을 때,
> 어떤 특별한 데이터를 붙이지 않고 단순히 `send`, `transfer`로 보냈을 때,
> 이 컨트랙트가 이더를 받을 수 있도록 허용해주는 **입구**입니다.

```solidity
receive() external payable {
    // 이더를 수신했을 때 실행되는 코드
}
```

즉, 이 함수가 없으면
컨트랙트 주소로 직접 이더를 보내도
**거절당하거나 실패**하게 됩니다.

---

그런데 질문이 하나 생깁니다.

> “그럼 데이터를 붙여서 보냈을 때는 어떡하죠?”  
> “또는 누군가 함수 이름을 잘못 호출하거나,  
> 없는 함수를 호출하면 무슨 일이 생기나요?”

바로 이때 필요한 함수가 있습니다.

그게 바로 오늘의 주인공,
**`fallback` 함수**입니다.

## **fallback은 '무슨 일이든 대신 처리하는 백업 함수'입니다**

`fallback()` 함수는 다음과 같은 상황에서 작동합니다:

1. 사용자가 호출한 함수가 존재하지 않을 때
2. 데이터가 존재하는 이더 전송이 들어올 때 (`call`, `send`, `transfer` + data)

즉, 이 컨트랙트에는 `transfer()` 함수가 없는데
누군가 `transfer()`를 호출했다면?

> “죄송하지만 transfer는 없어요…
> 그래도 혹시 모르니 내가 받아줄게요.”
> → 이 역할을 하는 게 `fallback()`입니다.

## **구조적으로 보면 이렇게 됩니다:**

```solidity
fallback() external payable {
    // 함수가 없을 때 실행됨
}
```

이 `fallback` 함수는
함수 이름이 존재하지 않거나,
ABI로 해석할 수 없는 데이터가 전달되었을 때
마지막으로 호출되는 **“최후의 처리자”**입니다.

이게 없으면? → **해당 트랜잭션은 실패합니다.**

## **Proxy에서는 fallback이 핵심입니다**

그리고 Proxy 구조에서는 이 `fallback` 함수가
사실상 **전부입니다.**

왜냐고요?

Proxy는 자기 자신 안에 `increment()`, `decrement()` 같은 함수가 없습니다.  
그래서 누군가 Proxy에게 이런 함수를 호출하면,  
당연히 **없다고 에러가 나야 합니다.**

하지만 Proxy는 이렇게 말합니다:

> “걱정 마세요.
> 저는 fallback을 가지고 있으니까요.
> 그 요청, 제가 대신 넘겨드릴게요.”

그리고 `fallback()` 함수 안에서
우리는 이렇게 처리합니다:

```solidity
fallback() external payable {
    delegatecall(implementationAddress, msg.data);
}
```

- 사용자가 호출한 모든 함수는
  결국 이 fallback 함수 안으로 들어오고,
- Proxy는 그 요청을 진짜 로직이 있는 Implementation에게 넘겨주는 겁니다.

## **정리: receive vs fallback**

| 함수         | 호출 조건                             | 목적                           |
| ------------ | ------------------------------------- | ------------------------------ |
| `receive()`  | **이더 전송만** 있을 때 (데이터 없음) | 순수 이더 수신용               |
| `fallback()` | **데이터가 있거나**, 함수가 없을 때   | 최후의 함수 처리자 / 위임 구조 |

---

**fallback은 이름 그대로입니다.**  
“내가 너를 위해 준비된 함수는 없지만,  
혹시 모르니 내가 대신 처리해줄게.”

## **Proxy를 실행 주체로 삼는다는 것**

오늘 우리는 두 개의 컨트랙트를 배포합니다.

1. `Counter.sol` – `increment()` 함수가 있는 실제 로직 컨트랙트
2. `Proxy.sol` – 아무런 함수도 없는, 단지 위임을 담당하는 프록시 컨트랙트

이쯤 되면 의문이 들 수 있습니다.

> “increment()를 실행하고 싶으면
> 당연히 Counter 컨트랙트를 호출해야 하는 거 아닌가요?”

> “근데 왜 Proxy를 호출하고, Proxy가 실행 주체라고 하나요?”

이게 바로 오늘 우리가 **몸으로 체험해야 할 핵심 구조**입니다.

## **실행의 주체는 Proxy입니다.**

비유를 들어볼게요.

- `Counter`는 **지시서를 담은 책**입니다.
- `Proxy`는 **지시서를 보고 행동하는 사람**입니다.

사용자는 책을 보지 않습니다.
사용자는 항상 사람(Proxy)에게 말합니다.
“카운트를 올려줘!”

그러면 Proxy는 이렇게 말합니다:

> “내 안엔 그런 기능이 없는데...
> 대신, 내가 알고 있는 책(Implementation)의 지시서에 따라
> 정확히 실행해줄게.”

이게 바로 `fallback()`의 동작 원리입니다.

## **왜 Counter가 아닌 Proxy를 호출하는가?**

정리하자면 다음과 같습니다.

| 비교 항목            | Proxy.sol                | Counter.sol                      |
| -------------------- | ------------------------ | -------------------------------- |
| 코드(로직)           | 없음 (오직 delegatecall) | 있음 (increment, decrement 등)   |
| 상태(storage)        | 있음                     | 없음 (실행되지만 상태 안 바뀜)   |
| 사용자가 호출할 대상 | ✅ 호출 대상             | ❌ 직접 호출 X (상태 연결 안 됨) |
| 실행 주체            | ✅ Proxy가 대신 실행     | ❌ 실행되더라도 Proxy와 단절됨   |

즉, Counter에 있는 `increment()` 함수는  
단독으로 실행하면 아무런 의미가 없습니다.  
왜냐면 그 함수는 **자신이 아닌 Proxy의 상태를 조작해야** 하기 때문입니다.

하지만 `delegatecall`은 바로 그걸 가능하게 합니다:

- **다른 컨트랙트의 코드를 실행하면서**,
- **현재 Proxy의 상태를 바꿉니다.**

## **그래서 정리하면...**

오늘 실습에서 우리가 할 일은 다음과 같습니다.

1. `Counter`를 배포합니다 – 로직 저장소
2. `Proxy`를 배포합니다 – 상태 보관소 + 실행 위임자
3. `Proxy.setImplementation()`으로 Counter의 주소를 기억시킵니다
4. 이제부터는 `Proxy`에게만 요청합니다 – increment, decrement 등

---

> **“코드와 상태는 나뉠 수 있다.”**  
> **“코드는 바뀌어도, 상태는 이어진다.”**  
> **“사용자는 하나의 창구만 보면 된다.”**

그 창구가 바로 Proxy입니다.
오늘 우리가 실습하는 모든 호출은
함수가 하나도 없는 Proxy에게 보내는 것이고,
그 요청은 delegatecall을 통해 로직 컨트랙트로 향하고,
결과는 Proxy 자신의 상태에 기록됩니다.
