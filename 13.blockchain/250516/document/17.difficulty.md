# 자, 이런 질문이 나올 수 있습니다

> “아니 교수님... 이거 너무 어렵잖아요.”
> “실제로 이렇게까지 복잡한 구조, 현업에서는 많이 안 쓰지 않나요?”

하하하하.
좋은 질문이에요.
아주 많이 받는 질문이고요.

그런데…
**이 질문은 솔직히 조금 괘씸합니다. 😄**

그래서 저도 조금 현실적으로 말해보겠습니다.

## 옵션이 아닙니다. 이건 **필수입니다.**

네, 맞습니다.
이거 **몰라도 개발은 할 수 있어요.**
하지만,

> **“이걸 모르면, 진짜 ‘서비스 운영’은 못 합니다.”**

그게 현실입니다.

## 현업에서는 왜 Proxy 패턴을 반드시 써야 하나요?

블록체인 서비스는 단순히 컨트랙트를 "한 번 배포하고 끝"이 아닙니다.
오히려 배포 이후부터가 진짜 시작입니다.

- 사용자 유입 → 기능 추가 필요
- 보안 이슈 발생 → 패치 필요
- 가스비 최적화 → 내부 구조 조정 필요

그런데, 블록체인은 한 번 배포하면 끝이라고요?

그렇기 때문에, 현업에서는 **99.9%의 경우, 아래와 같은 구조를 사용합니다:**

## 현업의 배포 플로우

### 1. 로직 컨트랙트는 따로 작성합니다 (`Implementation`)

→ `Token.sol`, `DAO.sol`, `Marketplace.sol` 등

### 2. Proxy 컨트랙트를 따로 작성합니다

→ Proxy는 항상 고정된 주소
→ 사용자는 이 주소만 알고 있으면 됩니다

### 3. 배포 시엔 항상 이렇게 합니다

1. `Implementation`을 배포한다
2. `Proxy`를 배포한다 (초기 owner는 팀이 가져감)
3. `Proxy`에 `Implementation` 주소를 연결한다
4. 사용자들은 Proxy만 호출하게 한다

→ 그리고 시간이 지나면?

### 4. 로직을 바꾸고 싶을 때는…

- 새로운 `ImplementationV2`를 배포하고
- `Proxy.setImpl(V2 주소)` 한 줄이면 끝

→ 상태는 그대로
→ 주소도 그대로
→ UI도 안 바뀜
→ 사용자도 눈치 못 챔

## 중요한 건 이겁니다

> “업그레이드 가능한 스마트 컨트랙트”를 만들려면
> **Proxy 패턴을 몰라서는 아예 출발도 못 합니다.**

## 오히려 반대로 생각해야 합니다

- “이거 어려운데 써요?” → ❌
- “이거 안 쓰면 운영 가능해요?” → ❌
- “이거 모르면 어때요?” → ❌

> **“이거 모르고는 시작조차 못 합니다.”**
