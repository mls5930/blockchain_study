# 개발의 흐름이 달라집니다 – Truffle 도입

지금까지 우리는 나만의 **ERC-20 토큰**을 만들었습니다.
토큰의 이름, 심볼, 소수점 자릿수, 총 발행량까지 설정하고,
`mint()` 함수를 통해 배포자에게 초기 발행량을 넣어주는 구조도 완성했죠.

그런데...

> **이걸 매번 배포할 때마다 `deploy.js`를 직접 작성해야 한다면 어떨까요?**

- `web3`, `fs`, `path`로 ABI와 바이트코드 불러오기
- 트랜잭션 구성
- 개인키로 서명
- 전송

솔직히 말해서, **너무 번거롭습니다.**
우리는 토큰을 *개발*하고 싶은데, *배포 환경 세팅*에 에너지를 다 쓰고 있습니다.

## 그래서 등장한 도구 – Truffle

이 문제를 해결하기 위해 등장한 것이 **Truffle**입니다.

Truffle은 단순히 "편리한 도구"가 아닙니다.
**스마트 컨트랙트를 개발하고 배포하고 테스트하는 전 과정을 체계적으로 관리하는 프레임워크**입니다.

---

### Truffle의 철학과 역사

Truffle은 2015년, Ethereum 초기 개발자였던 **Tim Coulter**에 의해 만들어졌습니다.
그는 블록체인 개발의 현실을 이렇게 바라봤습니다:

> "개발자는 코드를 짜고 싶어하지, 반복 설정에 시간을 버리고 싶지 않다."
> "테스트하고 배포하는 게 익숙해지고, 단순 반복 노동이라고 느꼈다면, 배포 설정까지는 개발 단계가 아닐 것이다. 노동이다."

그래서 그는 다음 두 가지를 목표로 Truffle을 설계했습니다:

- **개발자는 개발에만 집중하자.**
- **반복 작업은 자동화하자.**

Truffle은 Ethereum 생태계에서 가장 널리 쓰이는 개발 프레임워크 중 하나가 되었고,
수많은 프로젝트들이 Truffle을 기반으로 개발과 테스트를 이어가고 있습니다.

---

### 중요한 인식 하나: **"Truffle은 deploy.js를 대체하지 않는다."**

우리가 `deploy.js`를 직접 만들고, ABI와 바이트코드, 개인키 서명 과정을 손으로 다뤄봤던 이유는
**트러플이 그 안에서 무엇을 대신 처리해주는지를 이해하기 위해서였습니다.**

> 트러플은 단순히 단축키가 아닙니다.
> 내부 동작을 모른 채 쓰면, ‘리모컨만 누르는 사용자’에 불과합니다.
> 우리는 ‘기계 내부가 어떻게 작동하는지 아는 개발자’가 되어야 합니다.

---

## Truffle이 해주는 일

- 배포 스크립트 자동화
- Solidity 파일 자동 컴파일
- 테스트 구조 지원 (Mocha + Chai 기본 제공)
- 프로젝트 구조 통일 (컨트랙트, 테스트, 마이그레이션)

> 매번 web3로 배포할 필요 없이, **한 줄**로 배포할 수 있습니다.

---

## 설치 및 초기화

```bash
npm install --save-dev truffle
```

설치 후 초기화:

```bash
npx truffle init
```

이제 프로젝트 구조는 이렇게 정리됩니다:

```
contracts/         ← 스마트 컨트랙트 파일
migrations/        ← 배포 스크립트
test/              ← 테스트 코드
truffle-config.js  ← 네트워크 및 컴파일 설정
```

## 우리가 만든 코드와 어떻게 연결되나요?

이제 우리가 직접 만든 `ERC20.sol` 컨트랙트를 트러플로 배포해보겠습니다.
하지만 단순히 "파일 넣고 명령어 입력하면 배포됩니다"가 아니라,
**"왜 이렇게 해야 하는가?"**, **"무슨 일이 일어나는가?"** 를 정확히 짚고 넘어가야 합니다.

---

### 1단계. 배포 스크립트를 작성합니다 – `migrations/1_deploy_token.js`

```js
const ERC20 = artifacts.require("ERC20");

module.exports = async function (deployer) {
  await deployer.deploy(ERC20, "MyToken", "MTK", 1000000);
};
```

#### 그런데 여기서 질문 하나:

> `artifacts.require()`는 도대체 뭘까요?

이 구문은 트러플이 컴파일한 `.json` 파일(ABI와 바이트코드가 담긴 **컴파일 결과물**)을 자동으로 찾아 연결해주는 역할을 합니다.

즉, `build/contracts/ERC20.json` 파일을 읽어와서
**스마트 컨트랙트를 자바스크립트 객체로 다룰 수 있도록** 만들어주는 트러플 전용 함수입니다.

#### 다시 말해:

- `ERC20`은 **ABI + Bytecode가 포함된 컨트랙트 정의 객체**
- `deployer.deploy(...)`는 **이 정의 객체를 블록체인에 배포**

우리는 여기서 생성자 인자도 전달해주고 있죠:

```js
"MyToken", "MTK", 1000000;
```

→ 이 값들은 그대로 Solidity의 생성자에 전달됩니다:

```solidity
constructor(string memory _name, string memory _symbol, uint256 _amount) { ... }
```

---

### 2단계. 명령어 실행 → 내부 흐름 따라가기

이제 다음 명령어를 입력해 봅니다:

```bash
npx truffle migrate
```

이 한 줄 명령어는 **굉장히 많은 일을** 자동으로 처리해줍니다.
그 내부의 흐름을 요약하면 다음과 같습니다:

1. `truffle-config.js` 파일을 읽어와서 네트워크 설정 및 컴파일러 버전 확인
2. `contracts/` 폴더의 `.sol` 파일을 모두 읽고 **Solidity 컴파일** 실행
3. `build/contracts/`에 각 컨트랙트에 대한 JSON 생성 (ABI + Bytecode 포함)
4. `migrations/` 폴더에서 배포 스크립트를 순차적으로 실행 (번호 순)
5. 각 배포 결과를 Ganache 로컬 블록체인에 트랜잭션으로 제출
6. 트랜잭션이 채굴되면 결과를 `.json`과 콘솔 로그로 출력

---

### 3단계. 배포 결과 해석 – 터미널 로그를 보는 방법

`npx truffle migrate`를 실행하면, 다음과 같은 결과가 출력됩니다:

```
1_deploy_token.js
=================
   Deploying 'ERC20'
   -----------------
   > transaction hash:    0xabc123...
   > Blocks: 0            Seconds: 0
   > contract address:    0x456def...
   > block number:        5
   > gas used:            1,237,812
```

#### 여기서 눈여겨볼 항목:

- `transaction hash`: 실제 블록체인에 기록된 트랜잭션의 해시값
- `contract address`: **컨트랙트가 배포된 주소**
- `gas used`: 배포에 사용된 가스량 (최적화 확인할 수 있음)
- `block number`: 해당 트랜잭션이 포함된 블록 번호

이 정보는 단순한 출력값이 아니라,
**우리가 만든 컨트랙트가 실제로 블록체인에 존재하게 되었다는 증거**입니다.

---

### 핵심 요약

| 구성 요소             | 역할 설명                                 |
| --------------------- | ----------------------------------------|
| `artifacts.require()` | 컴파일된 JSON(ABI+Bytecode) 불러오기      |
| `deployer.deploy()`   | 컨트랙트를 배포하고 생성자에 인자 전달    |
| `migrations/*.js`     | 배포 스크립트의 실행 순서를 결정 (번호로) |
| `truffle migrate`     | 컴파일 + 배포 전체 실행을 단 한 줄로 수행 |

---

이렇게 정리하면 학생들은 단지 "트러플 쓰니까 간편하네요"가 아니라,
**"트러플은 어떤 내부 구조로 컴파일하고 배포를 도와주는가?"**,
**"우리는 어떤 부분만 직접 작성하고, 어떤 부분은 자동화에 맡겨도 되는가?"**를 명확히 이해할 수 있습니다.

## 그다음 단계는?

이제 우리가 만든 토큰 컨트랙트가
정말 우리가 의도한 대로 작동하는지, 직접 테스트해봐야겠죠?

> 다음 글에서는 `mint()` 이후,
>
> - `totalSupply`가 올바르게 설정되는지
> - 배포자 계정에 토큰이 들어갔는지
>   등 주요 기능을 **TDD 방식**으로 검증합니다.
