## 이더를 보내면 토큰을 준다고? — `receive()` 함수의 의미와 재구성

우리가 지금까지 만든 ERC-20 컨트랙트는
`mint()`, `transfer()`, `approve()`처럼 **명시적으로 호출되는 함수**를 통해서만 토큰을 발행하거나 전송할 수 있었습니다.

그런데 이런 생각을 해볼 수 있습니다.

> “누군가 이더를 컨트랙트에 보내기만 해도,
> 자동으로 정해진 수량의 토큰을 지급받을 수 있다면?”

이런 구조를 가능하게 만들어주는 특수한 진입점이 바로 **Solidity의 `receive()` 함수**입니다.

---

## 1. `receive()` 함수란?

Solidity에서 다음 조건을 만족하는 트랜잭션이 들어올 때:

```ts
await web3.eth.sendTransaction({
  from: ...,
  to: contractAddress,
  value: ...  // 이더만 존재
});
```

- 함수 호출 데이터(`data`)는 없음
- 오직 `to`와 `value`만 존재

→ 이때 컨트랙트에 다음과 같은 `receive()` 함수가 정의되어 있다면:

```solidity
receive() external payable { ... }
```

**해당 함수가 자동으로 실행됩니다.**

즉, `receive()`는 **별도의 함수 호출 없이 CA로 이더를 보낼 때 호출되는 유일한 진입점**입니다.

> 단, 이 함수는 **자동으로 존재하지 않으며**, 명시적으로 작성되어야 합니다.

---

## 2. 우리는 이 구조를 “ERC-20 스타일로” 재해석했습니다

단순히 이더를 받는 것이 아니라,
**이더를 보내면 토큰을 자동으로 받을 수 있는 구조**로 바꾸는 것이죠.

```solidity
receive() external payable {
    uint amount = msg.value * 20;

    if (msg.sender == owner) {
        _mint(amount); // 오너는 이더를 보내면 자동으로 토큰을 발행
    } else {
        require(balances[owner] >= amount, "Not enough tokens from owner");
        balances[owner] -= amount;
        balances[msg.sender] += amount;
    }
}
```

---

## 3. 이 receive() 함수는 이렇게 작동합니다

| 상황                    | 처리 방식                                           |
| ----------------------- | --------------------------------------------------- |
| 오너가 이더를 보낸 경우 | `_mint()`가 호출되어 토큰이 새롭게 발행됨           |
| 일반 사용자가 보낸 경우 | 오너의 잔고에서 토큰 차감 → 이더 보낸 사람에게 전송 |
| 오너 잔고가 부족한 경우 | `require`에 걸려서 트랜잭션은 revert (실패)         |

---

## 4. 이 구조는 어디에 사용될까?

이런 형태는 보통 다음과 같은 구조에서 사용됩니다:

- **ICO(Initial Coin Offering)**
- **Token Sale (토큰 자동 판매기)**
- **Crowdsale 구조**

예를 들어:

> “1 ETH를 보내면 20개의 토큰을 지급합니다.”

이런 흐름을 컨트랙트로 자동화하고 싶을 때 receive를 활용하는 것이죠.

---

## 5. 주의할 점

- `receive()`는 **모든 호출자가 접근 가능한 공개 함수**이며
  **자동 호출 조건을 갖기 때문에 보안적으로 매우 민감**합니다.
- 반드시 `msg.sender`에 따라 동작을 분기해야 하며,
  `mint()` 호출 여부, 잔액 검증, 오버플로우 등 모든 리스크를 제어해야 합니다.
- 특히 **owner의 잔고가 충분하지 않은 상황**은 반드시 대비해야 합니다.

---

## 마무리

> “이더를 보내면 토큰을 받는다.”

이 단순한 구조는 **사용자에게는 직관적**이지만,
**개발자에게는 ERC-20의 철학 위에 맞춤형 흐름을 설계하는 작업**입니다.

우리는 `receive()`를 통해, **명시적 함수 호출 없이도 자산을 이동시키는**
이더리움의 고유한 구조를 학습하고, 이를 실제 프로젝트에 맞게 **재해석**한 것입니다.

이제 이 구조를 실제로 구현하고,
“이더 전송 → 자동 토큰 지급” 흐름이 정확하게 동작하는지 **TDD 기반 테스트로 검증**할 수 있어야 하겠습니다.
