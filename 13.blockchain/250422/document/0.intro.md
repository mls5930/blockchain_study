# 오늘 수업, 흐름대로 같이 가보자

자, 우리가 어제 뭘 했냐면…  
Solidity로 스마트 컨트랙트를 짜고,  
그걸 컴파일하고, Ganache에 배포하는 흐름까지 직접 해봤지.  
근데 사실... 그게 다는 아니야.  
우리가 진짜로 이해하고 싶은 건 이거야:

> “**내가 작성한 코드가, 도대체 어떻게 해서 블록체인 위에서 ‘살아있는 계약’이 되는가?**”

---

## 1단계 – 스마트 컨트랙트는 왜 ‘배포’되어야 할까?

우리는 자바스크립트 쓰던 시절처럼 `node counter.js` 하고 실행하면 다 되는 줄 알았잖아.  
근데 블록체인에선 그게 아니야.  
**여기는 '나 혼자 실행해서 끝'이 아니라, 모든 노드가 실행하고, 저장하고, 공유해야 하는 세계**야.

그러니까, 그냥 실행이 아니라 **배포**가 필요한 거야.  
배포란, “이 코드가 진짜 블록체인 위에 존재하게 만드는 행위”고,  
그 순간부터 이 컨트랙트는 진짜 ‘주소’를 갖고 살아가게 되는 거지.

---

## 2단계 – Ganache는 왜 필요해?

그럼 우리 이걸 어디에 배포했더라?  
**Ganache**, 맞아.  
근데 학생이 이렇게 말할 수도 있어.

> “저 Ganache 설치한 적 없어요. 근데 배포되고 실행돼요.”

Ganache는 **내 컴퓨터 안에서 돌아가는 ‘가짜 이더리움 네트워크’**야.  
진짜 메인넷은 아니지만, EVM도 들어있고, 10개의 지갑도 자동 생성돼.  
완전 실험용 블록체인이야.  
그러니까 우리가 아무 걱정 없이 스마트 컨트랙트를 올려보고, 실행도 해보는 거야.

→ 진짜 메인넷에 올리기 전에 연습하는 곳이 바로 Ganache야.

---

## 3단계 – 컴파일? 어제는 compile.js로 했죠?

어제 우리가 막 길게 `compile.js` 만들어서  
파일 읽고, JSON 만들고, solc로 컴파일하고…  
결과 저장하고… 와우 복잡했지?

근데 사실은 말이지…  
`solcjs --bin --abi Counter.sol` 이 한 줄이면 끝나.  
그럼 학생들이 물어봐.

> “아니 그럼 어제 왜 그렇게 복잡하게 짰어요?”

좋은 질문이야.  
**우리는 단순히 컴파일만 하려고 한 게 아니라, ‘내부 동작’을 뜯어보려고 했던 거야.**  
실제로 어떤 옵션이 들어가고, 어떤 구조로 출력이 되고, 그 안에 뭐가 있는지를 직접 확인하는 게 목적이었어.

그냥 `--bin`으로 끝나면, 나중에 Web3로 연결할 때 진짜 감이 안 와.  
→ 우리가 스스로 **abi가 뭔지, bytecode가 왜 필요한지** 느끼게 하려는 흐름이었어.

---

## 4단계 – ABI와 Bytecode: 왜 이런 이름일까?

자, 그럼 어제 나왔던 `.abi`, `.bin` 파일.

이걸 그냥 “이더리움에서 쓰는 파일임~” 하고 넘기면 안 돼.

- ABI는 **Application Binary Interface**
  → 쉽게 말해서 **“이 컨트랙트는 이런 함수들을 갖고 있어요”라는 메뉴판**이야.
  → 프론트엔드가 이걸 보고, 버튼 클릭 시 어떤 함수 호출할지 판단해.

- Bytecode는 **EVM이 진짜로 실행할 수 있는 코드 덩어리**
  → 이게 실제로 배포될 코드야. 블록체인 위에서 돌고 있는 진짜 계약의 몸체라고 보면 돼.

📌 지금 단계에선 **Bytecode가 더 중요해.**  
→ 우리가 Solidity로 쓴 코드를, EVM이 이해할 수 있도록 번역한 결과니까.

→ 즉, “코드를 진짜로 살아 있게 만드는 준비물들”이 바로 ABI와 Bytecode야.

---

## 5단계 – Web3로 배포 & 함수 호출 (TDD 흐름으로)

이제 우리가 만든 `.abi`, `.bin` 파일을 활용해서  
**Web3.js를 통해 실제로 배포**해볼 거야.

중요한 건 여기서도 그냥 "해보기"가 아니라,  
**하나하나 테스트하듯** 점검하면서 실행한다는 거야.  
즉, TDD처럼 구조적으로 흐름을 정리하면서 확인하는 거지.

```plaintext
1단계: 컴파일 진행 → abi, bytecode 생성
2단계: 배포 진행 → Contract Address 생성됨
3단계: getCount() 호출 → 함수 호출, 상태 변경
4단계: increment() 함수 호출 후 상태 변경 확인 → 현재 count 상태 확인
```

이 흐름이 몸에 익으면,  
다음엔 어떤 컨트랙트를 짜더라도 **“내가 짠 코드가 진짜 블록체인에서 실행되는 전체 흐름”**을 따라갈 수 있게 돼.

## 6단계 – `web3.eth`란?

---

### 1. 이더리움 노드에 "말 걸기" 위한 리모컨

우리가 지금 이더리움 컨트랙트를 배포하거나 함수 호출할 때 쓰는 대부분의 명령어는  
다 이렇게 시작하죠:

```ts
await web3.eth.getAccounts();
await web3.eth.getBalance(...);
await web3.eth.sendTransaction(...);
```

이게 다 **`web3.eth`**라는 모듈에서 제공하는 함수들이에요.

---

### 2. 근데 왜 하필 `.eth`일까?

처음에 `web3.js` 라이브러리가 만들어졌을 때,  
그 목적은 **"이더리움(Ethereum) 네트워크와 통신할 수 있게 하자!"** 였어요.

그래서 내부 모듈 이름도 이렇게 붙었습니다:

- `web3.eth`: 이더리움 관련 기능 모음 (eth 계열 RPC 호출들)
- `web3.shh`: Whisper (이더리움 메시징 프로토콜)
- `web3.bzz`: Swarm (이더리움 파일 저장 네트워크)

즉, **Ethereum 생태계를 기준으로 설계된 네이밍**이었죠.

---

### 근데 우리는 지금 어디에 연결돼 있죠?

- 로컬의 Ganache?
- 퍼블릭 테스트넷인 Sepolia?
- 심지어 Polygon 같은 Layer2?

**그런데도 여전히 `web3.eth`를 쓰죠.**

---

### 왜 그럴까?

`web3.eth`는 이제는 **"EVM 기반 블록체인과의 인터페이스"**라는 의미로 확장된 거예요.

- Ganache도 EVM
- Sepolia도 EVM
- Polygon도 EVM
- Arbitrum, Optimism, Avalanche도 다 EVM

📌 즉, **이름은 `eth`지만, 의미는 ‘EVM과 소통하는 모듈’로 확장**된 상태입니다.

---

## 이해해야 할 진짜 핵심

> `"web3.eth는 단순히 Ethereum mainnet과만 연결되는 게 아니라"`  
> **"EVM이라는 구조 자체와 대화하는 창구"** 라는 관점으로 이해해야 해요.

---

## 요약 버전 정리

| 이름                   | 원래 의미                                  | 현재 의미                |
| ---------------------- | ------------------------------------------ | ------------------------ |
| `web3.eth`             | Ethereum 계층과 소통하는 모듈              | EVM과 소통하는 공통 모듈 |
| `Ganache`도?           | 네, 내부에 EVM 있음 → `web3.eth` 사용 가능 | ✅                       |
| `Sepolia`도?           | 테스트넷이지만 구조는 EVM → 그대로 사용    | ✅                       |
| 왜 이름은 안 바뀌었나? | 역사적 명칭 그대로 유지됨                  | ✅                       |

---

### 3. 그래서 `web3.eth`가 하는 일은?

> **"EVM에게 요청을 보낼 수 있게 도와주는 리모컨 역할"**

📌 우리는 직접 EVM에게 "야, 트랜잭션 보내줘!" 라고 못 해요.  
📌 그래서 대신 `web3.eth.sendTransaction({...})`을 쓰는 겁니다.

---

### 4. 이렇게 바라보면 됨!

| web3.eth는 뭐냐?  | → 노드 내부의 이더리움 계층(EVM)에 명령을 내릴 수 있게 해주는 "통신 창구"다. |
| ----------------- | ---------------------------------------------------------------------------- |
| 뭘 할 수 있음?    | 계정, 잔액 조회, 트랜잭션 보내기, 컨트랙트 호출 등등…                        |
| 어떤 식으로 동작? | 내부적으로는 JSON-RPC 메시지를 만들어서 연결된 노드에 요청 → 노드가 응답함   |

---

### 5. 우리가 직접 구현했던 로직과 연결해보면?

> 우리가 예전에 `getLatestBlock()`, `getTransactionById()` 같은 함수 직접 만들었지?

- 그때는 직접 블록체인 구조를 짜고
- 직접 상태를 저장하고
- 직접 트랜잭션 풀을 관리했음.

근데 web3는?

> **그걸 대신 해주는 자동화된 리모컨이 `web3.eth`인 거임!.**

---

## 한 줄 요약

> `web3.eth`는  
> **"이더리움 노드에 요청을 보내고, EVM의 상태와 상호작용할 수 있게 해주는 리모컨이다."**

## 7단계 – 트랜잭션 확인 & 전체 흐름 익히기

우리가 `increment()`를 실행한 순간,  
Ganache에선 **진짜 트랜잭션**이 발생했어.

- `from` 주소 → EOA
- `to` 주소 → CA
- method → increment
- result → 상태 변경 (count += 1)

그리고 이건 단순한 변수 증가가 아니라,

> **EVM이 opcode로 실행해서 storage를 바꾸고,  
> 그 결과를 블록으로 기록한 진짜 상태 변화**야.

이 감각, 오늘 확실히 익혀두자.  
단순히 코드를 짠 게 아니라,  
**스마트 컨트랙트가 작동하는 구조 전체를 내가 통제하고 있다는 감각**이야.
완벽해.  
이제 여기에 네가 말한 **7단계: 오늘 수업을 복습하고 체화하는 방법**까지  
흐름을 자연스럽게 이어서 추가해줄게.

---

## 8단계 – 오늘 수업 공부하는 방법

자, 오늘 수업은 문서 거의 안 썼죠?  
그 이유가 있어요.

어제 우리가 이미 **EVM이 뭐고**,  
**Ganache가 어떤 역할을 하고**,  
**opcode가 어떻게 실행되는지**까지 전부 정리해뒀어요.

그래서 오늘은 굳이 그런 설명 없이,  
**진짜로 실행해보고 체감하는 흐름**에 집중했어요.  
그럼 이제 **이 수업을 어떻게 복습하고 체화해야 할까?**

---

### 1. 전체 흐름 다시 떠올리기

우리가 오늘 손으로 따라한 흐름은 사실 단순해요.

1. 스마트 컨트랙트 코드 작성 (`Counter.sol`)
2. 컴파일 → ABI와 Bytecode 추출
3. Web3로 배포 → Contract Address 생성
4. `increment()` 호출 → 상태 변경
5. `getCount()` 호출 → 상태 확인
6. 전체 흐름을 TDD처럼 나눠서 확인

---

### 2. 이걸 ‘검증 리스트’로 만들어보자

그냥 흘러가듯 따라가지 말고,  
**“내가 뭘 확인했지?”**  
**“어디서 무슨 트랜잭션이 발생했지?”**  
이걸 리스트로 만들어보는 게 중요해요.

---

예시: **오늘 수업을 TDD 관점에서 검증한다면**

1. 컴파일 진행 → abi, bytecode 생성
2. 배포 진행 → Contract Address 생성됨
3. getCount() 호출 → 함수 호출, 상태 변경
4. increment() 함수 호출 후 상태 변경 확인 → 현재 count 상태 확인

### 추가로 검증할 내용

1. `increment()` 호출 후 실제로 블록 하나가 생겼는가? |
2. Contract Address로 EVM 내 코드를 추적할 수 있는가? |

---

### 3. 그 리스트를 가지고 흐름을 떠올려보기

그럼 이제 진짜 공부는 여기서 시작이에요.

- `여기서 이걸 왜 구현하지?`
- `왜 이 시점에 트랜잭션을 날리지?`
- `Web3는 EVM에게 어떤 방식으로 명령을 보내지?`
- `이때 발생한 트랜잭션은 무슨 상태를 바꾸고, 그건 어디 저장될까?`

이런 질문들을 하나씩 **“생각해보는 훈련”**이  
결국 스마트컨트랙트를 이해하는 진짜 기반이 돼요.

---

### 4. 정리하고, 문서를 다시 참고하자

- 오늘은 문서 거의 안 봤다고 해서,  
  문서가 쓸모없어진 건 아니에요.

- 오히려 지금 이 흐름을 몸으로 느낀 다음에,  
  **어제 정리한 문서를 다시 읽으면 완전 다르게 보일 거예요.**

- 모르는 키워드가 생기면 무조건 정리한 문서를 먼저 확인해보고,  
  그래도 안 되면 검색!  
  검색 결과가 맘에 안 들면 나한테 다시 질문!

---

## 마지막 한 줄

> **"이더리움은 그냥 코드를 실행하는 시스템이 아니에요.  
> 내가 작성한 코드가 전 세계적으로 어떻게 살아 있고,  
> 어떻게 상태를 만들고 바꾸는지를 이해하는 게 핵심이에요."**

---

## 마지막 정리

오늘은 단순히 "배포 성공~"에서 끝나는 게 아니었어.

- 왜 배포가 필요한지
- Ganache가 뭐하는 도구인지
- Compile이란 게 단순 명령어가 아니라, ABI와 Bytecode를 추출하는 과정이고
- 이 파일들을 바탕으로 Web3를 통해 트랜잭션을 날리는 흐름
- 그리고 그 트랜잭션이 어떻게 EVM을 타고 실행되는지까지

---

다음 시간엔 이제 **이걸 진짜 퍼블릭 테스트넷인 세폴리아(Sepolia)**에 배포해서,  
**Etherscan에서도 확인 가능한 실전 흐름**으로 나아갈 거야.
