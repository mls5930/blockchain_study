## **컴파일?**

어제 우리가 했던 걸 떠올려보자.  
`compile.js` 하나 만들고,  
`fs.readFileSync()`로 Solidity 파일 읽고,  
`solc.compile()` 함수에 옵션 넣고,  
결과를 파싱해서 `.abi`, `.bin` 파일로 저장했지.

근데 사실…  
그거 한 줄이면 끝났던 거였어.

```bash
npx solcjs --bin --abi contracts/Counter.sol
```

그럼 다음과 같은 질문이 나오겠지?

> “선생님, 이거 한 줄이면 되는데  
> 왜 굳이 그렇게 복잡하게 `compile.js`로 짠 거예요?”

---

### 2. 우리는 그냥 실행하려던 게 아니었어

**우리는 컴파일 자체가 목적이 아니라, 그 내부 구조를 직접 ‘몸으로 느끼고’ 확인하는 게 목적이었어.**

- Solidity 파일을 어떻게 읽고,
- `solc`에 어떤 JSON 구조를 넘기고,
- 결과물이 어떤 형태로 나오는지,
- `abi`와 `bytecode`가 어떤 역할을 하는지

나는 이걸 **명령어로 감춰두고 싶지 않았던 거야.**

---

### 3. 그냥 `.bin`이 아니라 구조다

단순히 결과만 보면 아무 생각이 안 나.  
그런데 `compile.js`를 직접 짜다 보면 느끼게 돼.

- `"Contract.sol"`이 컴파일되면 내부에 어떤 구조로 결과가 나오는지
- `contract.abi`, `contract.evm.bytecode.object` 이걸 꺼내야 우리가 Web3에서 쓸 수 있다는 걸 (나중에 배울거임!)
- 즉, 컴파일은 **Web3와 연결되는 출발점**이라는 걸

그래서 우리는 일부러 복잡하게 짠 거야.  
그 복잡함이 네가 직접 배포하고 함수 호출까지 이어갈 수 있게 해주거든.
