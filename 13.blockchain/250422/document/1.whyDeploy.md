# 스마트 컨트랙트는 왜 ‘배포’되어야 할까?

## 1. 걍 실행하면 안댐? 배포 안하고?

우리가 일반적으로 코드를 짠다고 하면, 이렇게 생각하죠.

> “자바스크립트 파일 하나 만들고, `node counter.js`로 실행하면 되잖아.”

그런데 블록체인은 완전히 달라요.  
**이건 혼자만 쓰는 프로그램이 아니에요.**

> 이더리움에서는 “내가 실행한 결과”를  
> **모든 노드가 공유하고 검증**해야 합니다.

그럼 그걸 어떻게 공유하냐고요?  
바로 **"배포"**라는 과정을 통해서입니다.

어디에 공유함?

블록체인 네트워크! => 세폴리아, 이더리움 등등

## 2. 개념 설명 – 배포란 무엇인가?

스마트 컨트랙트의 **배포(Deploy)**란,

- 내가 작성한 Solidity 코드를
- EVM이 이해할 수 있는 **바이트코드(Bytecode)**로 변환해서
- **블록체인 네트워크에 올리는 과정**을 말합니다.

그리고 이 과정을 통해 컨트랙트는

- **주소(Address)**를 갖게 되고
- **누구나 접근 가능한 상태**가 됩니다.

즉, “코드가 존재만 하는 상태”에서 → “네트워크가 인식하는 계약”으로 바뀌는 거죠.

## 3. 코드 연결 – 배포 코드가 의미하는 것

```ts
const contract = new web3.eth.Contract(abi);
await contract.deploy({ data: bytecode }).send({ from: account });
```

이 한 줄의 의미는?

> “이 컨트랙트를 이더리움(세폴리아...등등) 네트워크에 올려주세요.”  
> “그리고 고유한 주소를 만들어주세요.”  
> “이제 누구든 이 주소 => CA를 통해 계약을 사용할 수 있게요.”

📌 그리고 이걸 실제로 실행하면  
→ **트랜잭션이 발생하고**,  
→ **EVM이 실행해서**,  
→ **블록에 저장됩니다.**

## 4. 철학적 연결 – 왜 실행이 아니라 ‘배포’인가?

블록체인은 단순 실행 시스템이 아니에요.  
**모든 노드가 공유하는 ‘상태’ 기반 시스템**입니다.

그래서:

- 그냥 실행해서 끝나는 게 아니라
- **네트워크 전체가 인정하는 실행 결과**를 만들어야 하고
- 그 결과는 블록체인에 **기록되어야** 합니다.

그러려면 이 컨트랙트가 네트워크 안에 **“존재”**해야겠죠?

→ 그래서 “배포”가 필요한 겁니다.

## 5. 블록체인 네트워크는 '주소 기반 상태 머신'이다

우리가 작성한 스마트 컨트랙트를 블록체인에 **배포했다**고 해도,  
그걸 **식별할 수 있는 고유한 단서**가 없다면 아무 의미가 없어.

> 그래서 우리는 **CA (Contract Address)** 가 필요해.  
> 배포를 하면 EVM은 이 컨트랙트에 대해 **유일한 주소**를 만들어줘.  
> → 이 주소를 통해 **누구든**, 언제든, 이 계약에 접근할 수 있게 되는 거야.

---

## 그럼 ‘호출’은 어떻게 이뤄지는 걸까?

> 웹은 페이지 주소(URL) 기반으로 동작해.  
> 근데 블록체인은 페이지가 아니라 **“함수 단위로 호출”**되는 구조야.

### 이더리움에서의 함수 실행 흐름:

1. **사용자(혹은 다른 컨트랙트)** 가 특정 컨트랙트의 함수 호출을 요청함
2. 요청에는 **CA(Contract Address)** 와 **ABI 기반 입력값(data)** 이 담겨 있음
3. EVM이 이 주소에 해당하는 **바이트코드(bytecode)** 를 불러와 실행함

---

## 상태를 변화시키는가? 그럼 트랜잭션이야.

예를 들어, 우리가 만든 `Counter` 컨트랙트의 `increment()` 함수는  
`count += 1`이라는 **상태 변경**을 일으키지.

→ 이건 **EVM의 storage 상태**를 바꾸는 일이기 때문에  
→ 반드시 **트랜잭션이 발생**해야 해

📌 블록체인의 모든 상태 변경은 **트랜잭션으로만 가능**함

---

## 단순 조회는 트랜잭션이 아님

`getCount()` 함수처럼 상태를 단순히 **읽기만 하는 함수**는  
EVM의 storage를 읽을 뿐, 변경은 없기 때문에

→ 트랜잭션이 발생하지 않아  
→ 이건 **트랜잭션이 없는 함수 호출(call)** 로 처리됨

---

web3.eth.increment().send({
from: 함수를 요청하는 주소가 누구인가?
})

web3.eth.getAccount().call();

## `call()` vs `send()` 정확하게 구분하자

| 목적      | 상태 변화 | 트랜잭션 발생 | 사용하는 메서드 |
| --------- | --------- | ------------- | --------------- |
| 단순 조회 | ❌        | ❌            | `call()`        |
| 상태 변경 | ✅        | ✅            | `send()`        |

---

## 최종 정리

- 스마트 컨트랙트는 **CA(주소)** 를 통해 네트워크에서 식별됨
- EVM은 그 주소를 기준으로 바이트코드를 불러와 실행함
- 함수가 상태를 바꾸면 → **send()**, 트랜잭션 발생
- 함수가 상태를 바꾸지 않으면 → **call()**, 트랜잭션 없음
- 이 구조는 **모든 EVM 기반 네트워크(Ganache, Sepolia, Ethereum 등)** 에서 동일하게 적용됨

## 6. 그럼 배포 후엔 뭘 해야 할까?

이제 이 컨트랙트가 블록체인에 올라갔습니다.  
그럼 우리는 어떤 방식으로 이 컨트랙트에 명령을 내려야 할까요?

> 그냥 코드를 실행하면 될까요?  
> 아니면, 특정 주소로 접근해서 함수를 호출해야 할까요?

→ 이게 바로 다음 단계로 연결되는 질문이에요.
