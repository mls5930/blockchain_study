## **ABI와 Bytecode: 왜 이런 이름일까?**

---

### 1. 근데 abi bin은 알긴 하겠는데....

우리가 어제 `compile.js`를 돌리고 나서  
결과로 `.abi`, `.bin` 파일이 생겼잖아?

근데 막상 그 파일을 보고 든 생각은 이거였지.

> “이게 뭐죠? 그냥 이더리움에서 쓰는 파일인가요?”

그렇게 넘겨버리면 안 돼.  
이 이름 하나하나가 실제로 **EVM이 어떻게 작동하는지**,  
그리고 **우리가 Web3로 어떻게 명령을 내리는지**와 연결돼 있어.

---

### 2. 개념 설명 – 단어 속에 숨은 의미 뜯어보기

#### ABI = Application Binary Interface

- 우리가 만든 함수들(`increment`, `getCount`)이  
  외부에서 어떻게 호출되는지를 설명하는 **설계도**야.
- 프론트엔드 입장에선 버튼을 누르기 전에  
  이게 어떤 함수고, 어떤 인자를 줘야 하고, 반환값이 뭔지  
  다 이걸 통해서 이해하는 거야.
- 결국 **“프론트엔드 ↔ 스마트컨트랙트” 사이의 메뉴판**이라고 보면 돼.

#### Bytecode = 컴퓨터가 이해할 수 있는 코드

- 이건 진짜 **EVM이 직접 실행할 코드 덩어리**야.
- 우리가 Solidity로 작성한 코드를 기계어로 번역한 결과.
- 트랜잭션이 발생할 때 EVM이 읽고 실행하는 건 이 Bytecode야.

---

### 3. 흐름 감각 – 둘은 함께 움직인다

Solidity → `compile.js` → `.abi`, `.bin` 생성  
→ `.abi`는 Web3가 컨트랙트를 사용할 수 있게 도와주고  
→ `.bin`은 실제로 블록체인 위에 올라가는 코드 본체

📌 즉, 둘 다 없으면 아무것도 못 해.  
**Web3 입장에서 보자면**,

- `.abi`가 있어야 컨트랙트를 "어떻게 사용할지"를 알 수 있고
- `.bin`이 있어야 실제로 "무엇을 실행할지"를 알 수 있어.

---

### 4. 오늘의 질문

> “왜 그냥 solidity 파일 하나만 있으면 안 되나요?”

이유는 분명해.

> **Solidity는 사람이 보는 코드고,  
> EVM은 기계가 보는 코드야.**  
> → 그래서 변환이 필요하고, 그 결과물이 바로 `abi`와 `bytecode`야.

---

### 5. 다음 구조 연결

이제 이걸 가지고

- `Web3.eth.Contract(abi)`로 컨트랙트를 생성하고
- `deploy({ data: bytecode })`로 배포할 거야.

앞으로 어떤 컨트랙트를 만들든,  
**항상 이 둘은 기본 베이스가 됨.**
