# 오늘 뭐가 어려웠나?

일단 TDD부터 봐주셈

ㅇㅇ

## gas: (await deployTx.estimateGas()).toString()

이 아이는 뭐라고 설명할 수 있어?

## 마 견적 좀 보자!

맞는데....주체를 설명해보라고...

## ? 뭔소리임?

## 교강사가 다시 질문함: 그럼 deployTx에

```ts
const deployTx = contract.deploy({ data: bytecode, arguments: [] });
```

얘는 뭐라고 설명할 수 있어?

이건 딱 잘라서 말하면 **“트랜잭션을 날리기 전 준비된 배포 요청 객체”**, 즉 **"Deployment 트랜잭션 객체"**라고 부를 수 있음.

## 1. 이건 뭐냐?

> `deployTx`는 **실제로 배포를 실행한 게 아니고**,  
> **배포를 요청하기 위한 트랜잭션 데이터를 준비한 상태**입니다.

## 정확한 설명: **Deploy 트랜잭션 빌더 객체**

- `contract.deploy()`는 **컨트랙트를 배포하기 위한 초기값 셋팅 객체**
- 내부적으로는 `data`에 **bytecode**가 들어감
- `arguments`는 생성자(constructor)에 들어갈 인자 배열
- 이건 아직 **네트워크에 보내진 게 아님**
- 이걸 `send()` 해줘야 **트랜잭션이 네트워크에 전송되고**,  
  실제로 **컨트랙트가 배포**됨

## 구성 흐름

```ts
const deployTx = contract.deploy({ data, arguments }); // 배포 준비 (트랜잭션 객체 생성)
await deployTx.send({ from, gas }); // 진짜 배포 실행
```

## 비유

- `contract.deploy(...)` → **“택배를 포장한 상태”**
- `deployTx.send(...)` → **“포장한 택배를 진짜 배송 보내는 행위”**

## 결론

> `contract.deploy(...)`는 **“컨트랙트를 배포하기 위한 트랜잭션을 생성하는 빌더 객체”**이며,  
> **이 객체는 send()를 호출해야 실제 네트워크에 배포가 이뤄진다.**

---

이해 포인트 요약:

| 구분                | 설명                                                             |
| ------------------- | ---------------------------------------------------------------- |
| `contract.deploy()` | 트랜잭션 준비 객체 생성 (아직 네트워크 요청은 아님)              |
| `.send()`           | 트랜잭션 실제 전송, 배포 실행                                    |
| `deployTx`          | 트랜잭션 빌더 객체, 이걸 통해 gas 측정도 가능 (`.estimateGas()`) |

---

즉, 배포하기전에 마! 견적 좀 보자!  
배포 트랜잭션 객체 까봐라.
좋습니다. 이 질문, 아주 근본적이고 깊이 있어요.

```ts
const contract = new web3.eth.Contract(abi, contractAddress);
```

> ❓ **여기서 왜 Bytecode는 안 넣어요?**  
> → “이미 배포돼 있어서요.” ← 이건 **결과적으론 맞는 말이지만**, **설명은 부족해요.**

우리는 여기서 **더 근본적인 관점**을 가져야 합니다.  
**EVM이 어떤 구조로 작동하는지**,  
그리고 **Web3가 EVM과 어떻게 대화하는지** 이해하면 완벽하게 설명할 수 있어요.

---

## 바이트코드는 언제 필요한가?

바이트코드는 **배포할 때만** 필요합니다.  
왜냐하면 이 코드는 **EVM의 코드 저장소(Code Storage)에 영구히 저장**되기 때문이에요.

한 번 저장되면?

- 이후엔 EVM 내부에 저장되어 있는 이 코드만 바라보면 됩니다.
- 다시 bytecode를 줄 필요가 없어요.

---

## web3.eth.Contract(abi, address) 이 코드의 의미는?

- 이건 **“이미 배포된 컨트랙트와 상호작용을 준비하는 객체”**를 생성하는 거예요.
- 즉, 이미 존재하는 CA(Contract Address)를 기준으로,  
  **Web3가 해당 주소에 저장된 바이트코드를 가정하고**,  
  우리가 넘겨준 **ABI를 참고해서 함수 호출 인터페이스만 구성**해주는 거예요.

---

## 세련된 설명 방식

> “이건 이미 EVM 안에 코드가 저장돼 있으니까,  
> 우리는 그 코드의 외형만 알고 있으면 돼요.  
> 그 외형이 바로 ABI고,  
> 이걸 통해서 함수 이름, 인자 타입, 반환값 구조를 알 수 있으니까요.”

즉:

| 요소         | 역할                          | 필요한 시점                   |
| ------------ | ----------------------------- | ----------------------------- |
| **Bytecode** | 코드 자체                     | **배포 시점**에만 필요함      |
| **ABI**      | 외부에서 컨트랙트 함수 호출용 | **호출/상호작용 시점**에 필요 |
| **CA 주소**  | 코드가 저장된 장소            | 상호작용 시점에 필요          |

---

## 한 문장 요약

> **배포 후엔 이미 EVM 내부에 코드가 존재하므로,  
> 우리는 해당 주소와 ABI만 알면 그 컨트랙트의 기능을 사용할 수 있다.**  
> Bytecode는 오직 **처음 올릴 때**만 필요한 거다.

## 결국 분산형 데이터베이스다.

### 1. **분산형 데이터베이스 = 블록체인**

- 우리는 중앙 서버가 아닌 **분산된 노드들의 집합**에 데이터를 저장하고,
- 그 상태(state)는 **전 세계 모든 노드가 합의한 하나의 정본(source of truth)**입니다.

---

### 2. **API 방식으로 동작한다**

HTTP에서 `GET /users/1` 하면 →  
사용자 정보를 요청하죠?

그런데 Web3에서는:

```ts
await contract.methods.getCount().call();
```

이게 곧 이런 구조로 추상화된 겁니다:

```
127.0.0.1:8545/<CA주소>/getCount
```

- `127.0.0.1:8545` → RPC 서버 (Ganache or 노드)
- `<CA주소>` → 스마트 컨트랙트의 위치 (컨트랙트 주소)
- `getCount()` → 이 컨트랙트 안의 함수 (함수 셀렉터)

즉, 이건 **RESTful 구조처럼 작동하는 RPC 방식 API 호출**이에요.

---

### 3. **CA 주소가 핵심이다**

> 스마트 컨트랙트는 블록체인에서 "파일 경로"가 아니라 "주소(CA)"로 접근합니다.

- `bytecode`는 그 주소 안에 저장된 코드.
- `ABI`는 그 주소의 "사용 설명서".
- 우리는 이 주소를 기준으로 **함수를 호출**하거나 **트랜잭션을 날림**.

---

### 4. 한 문장 요약

> **스마트컨트랙트를 호출하는 건 결국 "블록체인 위에 올려진 API 서버를 사용하는 것"이며,  
> 이 주소 기반 호출 방식은 Web3가 분산 데이터베이스에서 제공하는 함수 호출 방식이다.**

## 1. `let gas` 전역 재활용 문제

### ❗ 문제점 1: 배포된 컨트랙트마다 `gas` 비용은 변할 수 있음

```ts
gas = (
  await result.methods.increment().estimateGas({ from: account })
).toString();
```

이 `gas` 값은 **한 번의 컨트랙트 인스턴스**를 기준으로 측정된 거야.  
하지만 이후에:

```ts
describe("다른 account로 배포 및 함수 호출", ...)
```

같은 블록체인 내에서라도 **다른 계정으로 컨트랙트를 새로 배포한 다음** 또 같은 `gas` 값을 재사용하면, 그때는 상황이 다를 수 있어.

- 네트워크 상태
- 계정의 nonce
- 상태 변화 여부

등등에 따라 estimateGas 결과는 조금씩 달라질 수 있고, 실제로도 **"조금만 부족해도 트랜잭션은 실패"** 하게 돼. 그런데 이걸 `let` 변수 하나로 재활용한다? 안정성에 문제가 생기지.

### ❗ 문제점 2: "다시 계산하지 않음"이라는 암묵적 전제가 숨어 있음

- 코드를 처음 보는 사람은 `beforeEach`가 실행된 이후의 모든 테스트들이 동일한 `gas` 값을 사용할 거라고 생각 못 할 수 있어.
- 즉, **테스트 간의 의존성이 생겨버리는 구조**가 되어버림.

---

## 2. `let`을 남용하는 패턴

```ts
let gas: number;
```

이걸 위쪽에 빼두고 이후에 값만 덮어쓰기하는 건 **전형적인 "제어 흐름 공유" 부작용을 유발하는 패턴**이야.

- 값을 언제 바꿨는지 추적하기 어렵고
- 나중에 코드 수정 시, **어느 테스트가 어떤 값에 의존하는지 명확히 파악하기 어려움**
- 특히 `beforeEach()`는 매 테스트마다 다시 실행되기 때문에, `gas`를 공유하려는 의도가 어색해짐

---

## ✔️ 대안

### ✅ 각 테스트 안에서 명시적으로 `estimateGas()`를 호출하자

예를 들어:

```ts
const gas = await result.methods.increment().estimateGas({ from: account });
await result.methods.increment().send({ from: account, gas });
```

### ✅ 또는 공통 함수로 감싸도 좋음

```ts
const sendIncrement = async (instance, sender) => {
  const gas = await instance.methods.increment().estimateGas({ from: sender });
  return await instance.methods.increment().send({ from: sender, gas });
};
```

각 테스트에서 이렇게 호출하면 됨:

```ts
await sendIncrement(result, account);
```

---

`let`의 남용은 단순한 변수 선언 습관 문제를 넘어서 **불변성(immmutability)**, **추상화(abstraction)**, **타입 안정성(type safety)**에까지 간접적으로 영향을 미쳐. 아래에서 그 연결고리를 하나씩 풀어볼게.

---

## 1. `let` 남용은 **불변성 위반**을 쉽게 만든다

### ❗ 문제

`let`은 변수의 값을 **언제든지 재할당할 수 있는** 구조이기 때문에, 의도치 않은 상태 변화가 발생하기 쉽다.

```ts
let counter = 0;
counter = 1;
counter = 2;
```

이렇게 되면 "언제", "왜", "누가" 값을 바꿨는지 추적하기 어려워지고, 특히 여러 함수/로직이 `counter`를 공유하고 있다면 **사이드 이펙트가 생기기 쉬운 코드**가 된다.

---

## 2. 타입스크립트의 철학: **예측 가능성과 타입 추론**

타입스크립트는 `const`를 우선시하는 걸 권장한다. 이유는:

- `const`로 선언된 변수는 **변하지 않는다는 보장이 있으므로 타입 추론이 더 정확하게 작동**한다.
- 코드의 **의도를 명확히 표현**해준다 ("이 값은 바뀌지 않는다").

```ts
const name = "Alice"; // TS는 타입을 'Alice'로 고정(Literal Type)
let name = "Alice"; // TS는 타입을 string으로 추론
```

즉, **`let`은 타입 시스템에 "이 값은 바뀔 수도 있다"는 신호**를 주는 것인데,  
그 자체로 추상화 수준을 낮추고, 불필요한 상태 변화 가능성을 암시하게 돼.

---

## 3. 추상화와의 연관성

추상화의 핵심은 "불필요한 상태나 세부사항을 숨기고, 의미 있는 개념만 드러내는 것"이야.

### `let`을 남용하면 추상화가 깨지는 예:

```ts
let userAge = 30;
if (isBirthday) {
  userAge += 1;
}
```

→ 외부에서 `userAge`의 상태가 여러 군데서 바뀌고 있다면, `userAge`라는 개념 자체가 **"나이"인지 "생일 포함한 나이 계산 결과"인지 명확히 추상화되지 않음.**

### 반대로:

```ts
const getUserAge = (baseAge: number, isBirthday: boolean) =>
  isBirthday ? baseAge + 1 : baseAge;
```

→ 이런 방식은 **불변성 유지**, **기능 명확화**, **타입 안정성 보장**, **추상화 강화**를 모두 만족시키는 구조야.

---

## 4. 요약

| 관점        | `let` 남용 시 문제                       | 관련 개념                 |
| ----------- | ---------------------------------------- | ------------------------- |
| 불변성      | 값이 쉽게 변경됨 → 상태 추적 어려움      | 함수형 프로그래밍, 안정성 |
| 타입 안정성 | 타입 추론이 느슨해짐 → `any` 위험성 증가 | TypeScript의 핵심 가치    |
| 추상화      | 상태 관리가 흩어짐 → 개념 모델이 흐려짐  | 설계 철학, 코드 의도 표현 |
| 테스트      | 예측 불가능한 상태 → 테스트 독립성 붕괴  | 단위 테스트 신뢰성        |

---

그래서 결론은:

> **`let`은 꼭 필요한 곳에만 제한적으로 사용하고, 기본은 `const`를 쓰는 것이 좋다.**  
> 이는 코드의 예측 가능성, 타입 추론 정확도, 추상화 수준, 유지보수성에 모두 영향을 준다.

필요하면 `let`이 정말 필요한 예외적인 상황에 대해서도 예시 줄 수 있어. 계속 이어서 정리해줄까?
