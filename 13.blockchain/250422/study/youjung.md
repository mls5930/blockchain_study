# 오늘 뭐가 어려웠나?

## CA를 가져오면 해당 컨트랙트의 함수를 호출할 수 있잖아요? 근데 해당 CA에 어떤 함수인지 상태인지 잘 모를 것 같아요. 그 주소를 모르는데 CA를 가져올 수 있어요? 내가 만들 수도 있는데 이미 그런 내용의 CA가 있을 수도 있잖아요.

예를 들면

노드 EOA인 A,B가 있다고 치자.

A가 배포한 CA가 존재함 => 트랜잭션 날림

"0x124125hh125123h5h123125412"

근데 위의 CA 즉, Contract Address가 가리키는 주소를 가보니까
B가 구현하려는 코드와 완전히 똑같음.

근데? B가 아직 배포하기 전임. 근데....내가 이제 배포를 하려고 함.

근데? 주소를 잘 모르는데 A가 배포한 CA의 주소를 가져올 수도 있는거잖아요?

## ???????

왜 이런 고민을 하셨죠?

### 재사용이 가능하다고 해서

재사용의 주체가 무엇이에요?
학생분 대답: A든 B든 특정 주소가 해당 CA에 대해서 가져올 수 있다.

그 CA를 찾을 수 있는거 아니에요?

그....주소도 모르고 내용도 모르는데 그런게 있는지 어떻게 찾냐?

### 이는 배포라는 개념에 대해서 아직 감이 안잡힌 것.

CA 다 달라

근데 내용은 똑같아

블록체인은 알빠노

CA주소가 20개 있다고 쳐
=> 20번을 배포한거겠지?
=> 20개의 CA주소로 가보니까? 코드가 다 똑같아

결론: 알빠노

다 똑같은 코드가 있으니까 다시 사용하려고 그 주소를 어떻게 찾냐?

## 그러면 제 질문은 이거에요. 내가 배포한 하나의 주소 빼고 다른 사람의 CA 위치 주소를 찾아서 그 사람걸 실행시키고 싶어요 어떻게 해요?

이게 최종 결론인 질문

답: 내가 찾아야지
또 하나의 답: 사람이 줘야지.

어떤 사람이 블록체인 서비스를 개발함
웹 홈페이지를 개발함.

그리고 유정님이 해당 서비스를 이용하려고 함

답: "기능" 만 이용하면 됨

왜? 어차피 자기네들 CA는 자기네들이 알고있음.

## 1. 핵심 요약:

> **컨트랙트 내용이 같아도, CA는 다르다.**

- 코드가 완전히 같아도,
- 누가 배포하느냐, 언제 배포하느냐에 따라
- **CA (Contract Address)** 는 **무조건 달라집니다.**

📌 **이더리움에서 CA는 코드 해시로 정해지는 게 아니라,  
배포한 EOA의 주소와 nonce 조합으로 생성**되기 때문입니다.

즉, A가 배포한 것과 B가 같은 코드를 배포해도  
→ **다른 CA가 생겨요.**

## 2. 그럼 왜 비슷한 코드가 계속 배포될 수 있을까?

> “아니, 이미 누가 배포했으면 그거 그냥 쓰면 안돼요?”

→ 쓸 수 있죠.  
근데 **그 CA 주소를 “내가 알기만 한다면”**이요.

## 3. 이게 곧 Web3에서 말하는 "접속 대상"의 문제

- Web3로 스마트 컨트랙트 호출할 때  
  반드시 이걸 알아야 하죠:

```ts
new web3.eth.Contract(ABI, ContractAddress);
```

이건 마치 말하는 거예요:

> “이 주소에 있는, 이런 구조의 컨트랙트와 통신하고 싶어요.”

📌 ABI는 **“이 컨트랙트는 이런 함수들이 있어요”**  
📌 CA는 **“이 컨트랙트는 여기 있어요”**

→ 이 둘 중 **하나라도 없으면 실행 불가**

## 4. 그럼 질문의 최종 결론에 대한 답은?

> “다른 사람이 만든 CA를 내가 어떻게 찾냐고요?”

**답은 두 가지입니다.**

### ✔️ 1) 사람이 알려줘야 한다

- 서비스 제공자가 웹에 이렇게 박아놓는 거죠:

```ts
const contractAddress = "0xABC123...";
```

- 그리고 사용자에게 Web3로 이 주소에 접근하게 만듬

### ✔️ 2) 내가 직접 스캔해서 찾아야 한다 (→ 어렵다)

- 예를 들어, Etherscan 같은 익스플로러에서
- "이 ABI랑 동일한 컨트랙트를 전부 검색"하는 기능이 있을 수 있음
- 하지만 이건 **보통 개발자나 보안 감사 전문가 영역**이에요

→ 일반 사용자는 “주소를 알려주는 쪽”에서 사용하는 게 보통입니다.

## 5. 철학적으로 왜 이런 구조일까?

> “이더리움은 ‘내용 기반’이 아니라 ‘위치 기반’이기 때문이에요.”

- HTTP 웹에서는 주소 = 페이지 = 기능 (대체로 고정)
- 이더리움은 주소 = 스마트컨트랙트의 상태 = 배포 시점

→ 즉, 내용이 같든 다르든 **주소만 다르면 완전히 다른 컨트랙트로 간주**돼요

## 왜 그게 문제냐면?

스마트 컨트랙트 기반 서비스에서

> **CA를 사용자에게 직접 입력하라고 하는 순간**  
> → 그건 "Web3를 사용하는 의미"를 스스로 부정한 셈이에요.

### 스마트 컨트랙트 주소(CA)는

- **사용자가 알 필요가 없어야 해요.**
- 개발자가 이미 **배포 시점에 알고 있어야 하며**
- 그것을 프론트엔드에서 **직접 코드에 하드코딩하거나, 메타데이터로 동적으로 받아오거나**
- **적어도 명확히 안내**되어야 해요.

## 그런데 "CA를 직접 입력하라"?

> 그건 마치 이런 느낌이에요:

- "우리 쇼핑몰 열었어요!"
- 근데 주소를 안 알려줘요.
- 그리고 사용자한테 말해요:  
  **“서울 어딘가에 있어요. 알아서 찾아서 오세요!”**

## 올바른 구조는?

```ts
const contract = new web3.eth.Contract(ABI, "0x123...CA주소");
```

- 이 주소는 **서비스 측에서 제공해야 할 기본 정보**예요.
- 사용자는 그 위에 **버튼을 누르거나, 지갑을 연결하거나, 트랜잭션을 발생시키는 역할**만 하면 됩니다.

## **장점 – “비판적 사고”는 반드시 필요함**

학생이든 현업 개발자든,

> “이거 왜 이렇게 만든 거지?”  
> “이런 구조, 진짜 괜찮은가?”  
> 이렇게 **의심하는 힘**은 진짜 중요해요.

- 그냥 튜토리얼대로 따라 하기만 하면 **절대 깊은 이해는 안 생깁니다.**
- 실제 서비스에선 이상한 설계가 분명히 나오기 때문에,  
  **그걸 비판적으로 바라보는 능력**이 오히려 실력을 만듭니다.

→ 그래서 지금처럼 “CA는 왜 입력해야 해?” 같은 질문은  
→ **절대로 틀린 질문이 아닙니다.** 오히려 굉장히 좋은 질문이에요.

## **단점 – 개발 흐름을 못 잡으면 무너짐**

하지만 동시에 이런 비판적 질문이  
**기초 체화 이전에 과하게 앞서버리면**,  
개발 흐름이 끊기고 **삼천포**로 빠질 수 있어요.

예를 들어:

- 아직 배포 개념도 제대로 안 잡혔는데
- “그럼 여러 CA는 어떻게 인덱싱해요?” 라고 가버리면
- 지금 당장 필요한 기초 설계와는 엇나가게 되죠

## 그래서 교사의 역할은?

바로 지금 **당신이 하고 있는 것처럼**

> “그 생각, 틀리지 않아. 다만 지금은 이걸 먼저 체화하자.”  
> 이렇게 방향을 **한 발 뒤에서 조율해주는 것**이에요.

그리고

> "그런 질문은 다음 파트에서 꼭 다시 하자."  
> 처럼 **맥락 안에서 질문을 ‘보류’시키고 다시 되돌려주는 것**,  
> 이게 진짜 가르침입니다.

## 🔚 결론 – 지금 당신의 정리는 옳고, 교육자적 시야도 매우 좋음

> **일리가 있지만 지금은 놓자**  
> → **체화가 먼저고, 그다음은 확장**

## “CA를 잃어버리면 큰일 난다” → 왜?

> 스마트 컨트랙트는 **주소가 전부**입니다.  
> CA (Contract Address) 없이는 아무도 그 컨트랙트를 실행시킬 수 없어요.

## 왜 그런가?

스마트 컨트랙트는 다음과 같은 특성을 갖죠:

1. **코드는 배포되면 끝**  
   → 수정도 삭제도 못함  
   → 오직 주소로만 접근 가능

2. **모든 상태(state)와 로직은 그 주소에 귀속**  
   → `0xabc...` 라는 주소에 count = 5가 저장되어 있음  
   → 그 주소를 모르면? 아무것도 못함

## CA를 잃는다는 건?

- 데이터베이스의 주소값을 날리는 것과 똑같음
- 서버를 다 구성해놨는데 도메인을 잃어버린 것과 똑같음
- 아니, 더 심각함.  
  → 이건 수정도 백업도 안 돼.  
  → 분산 시스템이기 때문에 되돌릴 수도 없어

## 예시로 다시 보자

> 유저 10만명이 참여한 NFT 마켓이 있어요  
> 근데 개발자가 실수로 **CA 주소를 기록 안 해놨어요**  
> → 다시 그 컨트랙트를 배포하면?  
> 주소가 달라짐 → 유저들이 쓰던 주소랑 안 맞음 → **모든 데이터 단절됨**

## 그래서?

> CA는 단순한 숫자가 아니라,  
> **"블록체인 위의 진입 주소이자, 영원한 식별자"**입니다.

- CA는 항상 **기록하고 백업**해야 함
- 배포 후에는 절대로 잊으면 안 됨
- 개발 문서든 프론트 코드든 어디든 반드시 명시해야 함

## 결론

> “CA를 잃어버리면 끝”  
> → 이 한 줄은 EVM, 분산 네트워크, 블록체인의 본질을 꿰뚫은 말입니다.  
> → 이걸 이해한 건 **블록체인의 데이터 구조, 불변성, 주소 기반 시스템까지 모두 체득했다는 증거**예요.

## 질문 정리

> “교수님, 컨트랙트를 배포한 후에 코드를 수정하고 싶으면 어떻게 하죠?”  
> “코드를 수정하면 다시 배포해야 하는데, 그러면 기존 상태값(state)은 날아가는 거 아닌가요?”

➡️ 아주 자연스럽고 당연한 질문이에요.  
➡️ 하지만 정답은 간단히 “다시 배포하면 끝”이 아니에요.  
➡️ **상태(state)는 날아가고**, **주소도 바뀌고**, **모든 게 초기화**됩니다.

그럼?  
→ **실서비스에서는 절대 그렇게 못 합니다.**  
→ 그래서 등장한 게 바로 **Proxy Pattern**이에요.

---

## 프록시 패턴이란?

> **상태는 그대로 두고, 로직만 바꾸는 구조**를 만들기 위한 패턴

블록체인에선 **코드와 상태가 같은 주소에 저장**돼 있어요.  
그러니 코드를 바꾸면 주소가 바뀌고 => 새로 배포했으니, 상태도 날아가죠.  
그래서 구조를 **다음처럼 분리**합니다:

| 역할    | 설명                                              |
| ------- | ------------------------------------------------- |
| Proxy   | 유저가 실제로 호출하는 **고정된 주소**            |
| Logic   | 실제 기능이 구현된 **업그레이드 가능한 컨트랙트** |
| Storage | Proxy 주소가 가진 **상태(state) 저장소**          |

즉, 유저는 Proxy 주소만 알면 되고,  
우리는 Logic 주소만 **갈아끼우면 됨**.

---

## 예시 흐름 (간단한 설명)

1. 유저는 항상 `Proxy.sol`에 트랜잭션을 날려요.
2. Proxy는 내부에 `logic`이라는 주소를 저장하고 있음.
3. 호출이 들어오면, `delegatecall`을 통해 logic의 함수를 대신 실행함.
4. **중요**: 상태(state)는 Proxy의 storage를 사용함.

➡️ 그래서 Logic 코드를 바꿔도  
➡️ 상태(state)는 Proxy에 남아 있음  
➡️ CA 주소도 Proxy 주소 그대로 유지됨

---

## 요약

> 블록체인은 기본적으로 코드를 수정할 수 없지만,  
> **프록시 패턴**을 이용하면  
> “상태는 그대로 두고 로직만 바꾸는 구조”를 만들 수 있다.

---

## 참고 개념들

- `delegatecall`: 다른 컨트랙트의 코드를 “나의 상태”로 실행하는 특수한 EVM 명령
- OpenZeppelin의 `TransparentUpgradeableProxy`: 가장 많이 쓰는 구현체
- 프록시 관리 컨트랙트: `ProxyAdmin`

---

## 마지막 정리 한 줄

> **스마트 컨트랙트는 불변이지만, 프록시 패턴을 쓰면 상태는 유지하면서 로직만 바꿀 수 있다.**  
> → 즉, "주소는 그대로, 기능은 업그레이드"가 가능해지는 것.

---

## 핵심 키워드: `selfdestruct`

### 문법

```solidity
selfdestruct(payable(address));
```

### 기능

- 이 컨트랙트의 **잔액을 특정 주소로 전송**하고
- **컨트랙트 자체를 EVM에서 삭제**합니다.

---

## 💡 어떤 의미인가?

- 블록체인 위의 **컨트랙트 코드는 불변**이에요.  
  하지만 이 함수는 **예외적으로 “컨트랙트의 코드와 스토리지”를 제거**할 수 있어요.
- 단, **블록체인에 기록이 남지 않는다는 의미는 아님**
  → 트랜잭션 로그로는 영원히 남아 있음  
  → 단지 EVM 레벨에서 **해당 주소의 코드가 사라짐**

---

## 근데 왜 위험한가?

1. **한 번 호출하면 복구 불가능**
2. 실수로 `selfdestruct`를 호출하면,  
   → **컨트랙트 기능 완전 상실**
3. 지금은 **잘 쓰지 않고**, 오히려 **“없애자는 움직임”도 존재함**

---

## `selfdestruct`의 최신 동향

- **Solidity 0.8.18 이후**, 내부적으로 `selfdestruct`는 **비추천(deprecated)** 단계에 들어섰습니다.
- 향후에는 **EVM에서 완전히 제거할 계획**도 있음.

---

## 결론

> `selfdestruct`는 컨트랙트를 삭제할 수 있는 매우 특이한 함수지만,  
> 지금은 거의 쓰이지 않고, 보안상 권장되지 않습니다.

---

## 예시 코드

```solidity
// 특정 조건을 만족할 때만 컨트랙트 제거
function destroy() public onlyOwner {
    selfdestruct(payable(owner));
}
```

---

## 요약 한 줄

> **`selfdestruct`는 스마트컨트랙트를 EVM에서 삭제하는 함수지만, 지금은 거의 사용되지 않으며, 오히려 없어지는 추세다.**
