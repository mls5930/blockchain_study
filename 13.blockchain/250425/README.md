## 오늘 수업은 뭐할까?

어제 여러분은 실습에서 `reset()` 함수를 직접 만들어보고,  
그 함수가 **누가 호출할 수 있는지**, **어떻게 권한을 제한할지** 고민했었죠.

그 과정에서 우리는 단순한 한 줄짜리 코드 —

```js
count = 0;
```

— 이 그저 실행되기만 하면 되는 게 아니라,  
**누가 실행하는가**, **무슨 조건에서 실행되는가**라는 구조를 함께 짚었습니다.

그리고 이 질문을 마주하게 됩니다:

> “이 함수가 실제로 실행되기 위해선,  
> **어떤 정보와 책임과 자원이 필요한가?”**

---

여기서부터 우리는 트랜잭션을 구성하는  
**숨겨진 속성들**을 하나씩 해체하고 들어가게 됩니다.

- 누가 실행했는가 → `from`
- 어디에 보낼 것인가 → `to`
- 무엇을 실행할 것인가 → `data`
- 얼마나 많은 자원이 필요한가 → `gas`
- 얼마나 빨리 처리되길 원하는가 → `gasPrice`
- 몇 번째 요청인가 → `nonce`
- 돈을 함께 보낼 건가 → `value`

이 각각은 단순한 옵션이 아니라,  
**EVM이 실행을 판단하고 질서를 유지하는 근거**입니다.

---

그리고 여기서 우리는 또 하나의 의문을 갖게 됩니다:

> 트랜잭션 금액은 ETH 단위로 쓰면 되지 않나요?

근데 이상하게도,  
우리가 쓰는 코드는 항상 이런 식입니다:

```js
gasPrice: web3.utils.toWei("30", "gwei");
```

ETH도 아니고, 뭔가 자꾸 보이는 이상한 단위들 —  
**Gwei, Wei**

---

오늘 수업에서는 이 단위들의 등장 배경까지 포함해서  
**실제로 트랜잭션을 보낼 수 있는 전제 조건들**을  
**철학부터 실습까지 완전히 정리**해봅니다.

---

## 오늘 수업의 목차

1. **내가 만든 함수를 실행하려면, 어떤 정보가 필요한가?**  
   → 트랜잭션이란 구조를 해체하며 `from`, `to`, `data`, `gas`, `gasPrice`, `nonce`, `value`의 역할 이해

2. **Web3.js로 직접 트랜잭션 구성해보기**  
   → `estimateGas()`, `getGasPrice()`, `getTransactionCount()`  
   → 그리고 직접 `.send()`로 트랜잭션 전송

3. **트랜잭션 실행 결과 추적**  
   → Etherscan에서 `transactionHash`, `status`, `input data`, `gasUsed`, `nonce`, `value` 분석

4. **왜 Gwei라는 단위가 등장했을까?**  
   → ETH는 너무 크고, Wei는 너무 작다  
   → Gwei는 수수료에 최적화된 UX 단위  
   → `gas * gasPrice`의 현실적인 계산이 가능해지는 이유

5. 실습이 있습니다.

   - 어제 reset() 함수를 기준으로 실습을 할겁니다.

---

## 오늘 수업의 핵심

- 트랜잭션은 단순 실행이 아닌 **책임 있는 요청**이다
- 이 요청에는  
  → **정체성** (`from`)  
  → **목표지** (`to`)  
  → **행동 내용** (`data`)  
  → **책임 자원** (`gas`, `gasPrice`)  
  → **순서** (`nonce`)  
  → **금전 거래 여부** (`value`)  
  가 모두 포함된다

- 이더리움은 **기계는 Wei로 계산하고, 사람은 Gwei로 조정하는 구조**다

---

> 오늘 수업이 끝날 때쯤 여러분은  
> `.send()`라는 한 줄에  
> **얼마나 많은 철학, 기술, 구조가 숨어 있었는지**  
> 정확히 설명할 수 있을 겁니다.
