# 실습: 트랜잭션 구조를 내 손으로! => `reset()` 함수를 실행하며 Web3 철학을 체화하기

## 실습 목표

- 단순히 자동으로 실행되는 `send()`를 넘어서,  
  **트랜잭션이 구성되는 구조를 스스로 만들어보는 경험**을 한다.

- 트랜잭션을 이루는 **핵심 속성들**이  
  **어떤 이유로 필요하고, 어떻게 설정되는지를 몸으로 익힌다.**

## 실습 흐름

### 1. 스마트 컨트랙트를 컴파일해봅시다

먼저 우리가 사용할 스마트 컨트랙트가 준비되어 있어야 합니다.  
파일에는 `reset()`이라는 함수가 선언되어 있는지 확인해봅시다.

이제 이 컨트랙트를 **바이트코드와 ABI로 변환**해볼 차례입니다.  
어떤 도구를 사용하든 상관없지만, 결과적으로 두 가지 파일이 나와야 합니다:

- **.abi**: 스마트 컨트랙트의 함수 정보가 담긴 인터페이스
- **.bin**: 블록체인 위에 올릴 실제 바이트코드

이 작업은 뒤에서 **배포 시점**에 사용됩니다.

### 2. 컨트랙트를 블록체인에 배포해보세요

이제 컴파일된 코드를 **네트워크 위에 배포**해야 합니다.  
배포 과정은 Web3 라이브러리를 통해 수행하게 되며,  
그 안에서는 특정한 정보들이 필요해집니다:

- **내가 누구인지** → 계정 정보
- **어떤 코드인지** → 바이트코드
- **배포를 실행하기 위해 얼마나 연산이 필요한지** → gas
- **이 요청을 처리할 때 얼마나 우선권을 둘 것인지** → gasPrice

이 배포가 성공하면  
**새로운 컨트랙트 주소가 생성되고, 그 안에 reset() 함수가 포함됩니다.**

### 3. MetaMask 연결과 계정 연동 확인

브라우저에 MetaMask가 설치되어 있다면,  
브라우저는 이미 여러분의 지갑 정보를 담은 객체를 제공하고 있을 것입니다.

이제 여러분이 해야 할 일은  
**지갑을 통해 연결된 계정을 하나 선택하고,**  
그 계정이 실제로 Web3 환경에서 실행 주체로 활동할 수 있도록 연결을 확인하는 것입니다.

### 4. reset 함수 실행해보기 (기본 방식)

자, 배포가 완료되었다면  
그 안에 포함된 `reset()`이라는 함수를 한번 실행해볼 차례입니다.

여기서 중요한 건,  
우리가 함수를 실행한다는 건 단순히 “코드를 호출한다”는 게 아니라,

> **네트워크에 트랜잭션을 전송하는 것**이며,  
> **실제로 블록체인의 상태를 바꾸자는 요청을 보내는 일**이라는 점입니다.

이 시점에서는 별다른 속성 없이 기본적인 `send()` 방식으로 함수 실행을 진행해봅니다.

그리고 실행 이후,  
Etherscan에서 트랜잭션 해시를 조회해보면  
`from`, `to`, `gasUsed`, `input`, `status` 같은 정보들이 기록되어 있음을 확인할 수 있습니다.

### 5. 그렇다면… 자동이 아니라, 직접 구성한다면?

이제 진짜 실습의 핵심입니다.  
여태까지는 Web3와 MetaMask가 알아서 처리해줬습니다.  
하지만 **내가 이걸 직접 구성해야 할 상황이라면?**

다음과 같은 질문들이 떠오를 겁니다:

- 지금 이 코드를 실행하려면, **얼마나 많은 연산(gas)**이 필요할까?
- **네트워크가 혼잡할 땐**, 어느 정도 속도로 처리되길 원하는 걸까?
- **트랜잭션을 여러 번 연속해서 날릴 땐**, 어떤 기준으로 순서를 정해야 할까?
- 내가 실행하려는 함수는 코드상으로는 reset인데,  
  **EVM은 그걸 어떻게 알아들을까?**

이 질문에 하나하나 답을 하다 보면,  
**트랜잭션 객체라는 구조를 직접 구성**할 수밖에 없습니다.

이 트랜잭션 객체에는 다음과 같은 정보들이 담기게 됩니다:

| 속성       | 설명                                                            |
| ---------- | --------------------------------------------------------------- |
| `from`     | 이 요청을 누구의 계정에서 실행하는가                            |
| `to`       | 이 코드를 실행할 대상 컨트랙트 주소는 어디인가                  |
| `gas`      | 실행에 필요한 연산량은 얼마인가                                 |
| `gasPrice` | 이걸 얼마나 빠르게 처리받고 싶은가                              |
| `nonce`    | 이 계정의 트랜잭션 순번은 몇 번째인가                           |
| `data`     | 어떤 함수를 실행할 것인지, 그걸 어떻게 인코딩해서 전달할 것인가 |

---

### 6. 이제 여러분이 할 일

이제 여러분이 해야 할 일은 단 하나입니다:

> **위의 속성들을 스스로 구해보고**,  
> 하나의 트랜잭션 객체를 구성하여  
> `reset()` 함수를 실행하는 코드를 완성해보는 것.

이 과정을 통해  
자동화된 `send()` 호출이  
실제로는 얼마나 많은 준비와 책임, 조건 위에 작동하는지를  
**직접 경험하게 될 것**입니다.

---

### 7. 실행 결과 확인 및 Etherscan 분석

트랜잭션이 전송되면,  
트랜잭션 해시가 생성될 것입니다.

이 해시를 복사해서 Etherscan에 붙여넣으면,  
여러분이 직접 구성한 속성들이 어떻게 반영되었는지  
다음 항목을 기준으로 확인할 수 있습니다:

- `from`: 서명한 계정
- `to`: 실행된 컨트랙트 주소
- `input`: 함수 호출 바이트 인코딩
- `gasUsed`: 실제 소모된 연산량
- `status`: 성공/실패 여부
- `nonce`: 이 계정의 트랜잭션 순번

## 실습 점검 체크리스트

| 항목                         | 상태    |
| ---------------------------- | ------- |
| 스마트 컨트랙트 컴파일 완료  | ✅ / ❌ |
| 컨트랙트 배포 성공           | ✅ / ❌ |
| MetaMask 계정 연동 완료      | ✅ / ❌ |
| 기본 `send()` 실행 완료      | ✅ / ❌ |
| 트랜잭션 속성 직접 구성 시도 | ✅ / ❌ |
| Etherscan 트랜잭션 분석 완료 | ✅ / ❌ |

## 마무리 정리

> 이제 여러분은 `contract.methods.reset().send(...)` 이 한 줄 뒤에  
> **얼마나 많은 철학과 구조가 숨어 있었는지를 직접 확인한 사람**입니다.

우리는 지금 **Web3 환경에서 책임 있는 실행을 구성하는 개발자** 입니다.
