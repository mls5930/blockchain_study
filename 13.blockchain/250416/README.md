## 저번 시간에는 뭐했을까?

오늘의 주제는 바로  
**“코인베이스 트랜잭션(Coinbase Transaction)”**입니다.

블록체인은 이렇게 약속해요:

> **“누구든 블록을 유효하게 만들면,  
> 그 블록 안에 자신에게 보상을 주는 트랜잭션을 넣어도 좋아!”**

바로 이 트랜잭션이 `코인베이스`예요.

## 저번 수업의 핵심 질문

- **보상은 누가 주는가?**
- **그 보상은 시스템적으로 어떻게 표현되는가?**
- **TxIn 없이 TxOut만 있는 트랜잭션은 어떻게 가능한가?**
- **우리가 만든 트랜잭션 구조에서 코인베이스는 어떻게 특별한가?**

## 저번 수업의 목차

1. **코인베이스 트랜잭션이 왜 필요한가?**  
   → 블록 보상의 원리와 시스템적 역할

2. **TxIn 없이 TxOut만 있는 구조 만들기**  
   → `createCoinbase(account, height)` 메서드 구현

3. **코인베이스 + 일반 트랜잭션 → 블록 트랜잭션 구성**  
   → `txsForBlock = [coinbaseTx, ...getPool()]` 구조 확인

4. **트랜잭션 풀 동기화 및 UTXO 반영**  
   → `sync()`, `update()`로 블록 반영 시뮬레이션

5. **TDD: “Bob이 Alice에게 7코인을 보내는 거래 + 보상받는 채굴자” 시나리오 구현**

## 저번 수업의 목적

이제 우리는  
**"트랜잭션은 누가 만들고, 누가 검증하고, 누가 보상받는가"**까지 다룰 수 있어야 합니다.

오늘 이 흐름이 완성되어야  
다음 시간에 배울 **P2P 구조**가  
**"왜 필요한가"**를 자연스럽게 이해할 수 있습니다.

## 이번 시간에는 뭐할까?

지난 시간에 우리는  
트랜잭션이 **어떻게 만들어지고**,  
그 안에 **어떻게 보상이 포함되는지**까지 직접 다뤘어요.

하지만...  
**그걸 나 혼자 알고 있으면 무슨 소용이죠?**

> “블록체인은 탈중앙 시스템이에요.”  
> → 즉, **내가 만든 트랜잭션을 다른 노드들도 알아야 해요.**

이제부터는  
**“내가 가진 정보를 네트워크 전체에 어떻게 전파할 것인가?”**  
그 질문에 답할 차례입니다.

---

## 이번 시간의 목차

1. **HTTP vs TCP – 통신 구조의 차이 이해하기**  
   → 왜 단순한 HTTP 요청만으로는 충분하지 않은지

2. **P2P 네트워크 구조 설계하기**  
   → 소켓 기반 구조, 각 노드가 서버/클라이언트가 되는 구조

3. **메시지 구조(MessageType, IMessage) 정의하기**  
   → "나 블록 만들었어" 같은 메시지를 통일된 구조로 전송

4. **P2P 서버(P2P.ts), 클라이언트(Client.ts) 구현하기**  
   → 연결 수립, 메시지 수신/응답, 체인 요청/응답 흐름 직접 만들기

5. **Express + HTML을 통한 체인 시각화 및 테스트**  
   → 웹에서 블록 만들고, 다른 노드에 전파되는지 확인

---

## 이번 시간의 핵심

이번 수업의 핵심은 단 하나입니다:

> **“내 블록을 다른 노드에게 전파하라”**  
> → 그리고 동시에  
> **“다른 노드가 만든 블록도 받아들여라”**

---

❓ 이쯤에서 이런 질문이 나올 수 있어요:

> “꼭 블록을 만든 사람만 비트코인 네트워크에 참여하는 건가요?”

그건 아니에요!

- **나는 블록을 만들지 않아도**,  
  **다른 노드가 만든 블록을 받고 동기화에 참여**할 수 있어요.

- 동시에, **내가 만든 블록도 다른 노드들에게 전파**되어야 해요.

---

즉, **내가 이 네트워크의 일원이 되려면** 두 가지를 해야 합니다:

1. **나도 트랜잭션을 전파할 수 있어야 하고**
2. **다른 누군가가 만든 블록도 수신해서 반영할 수 있어야 해요**

---

우리는 오늘  
다음과 같은 구조를 실시간으로 구현할 거예요:

- `나 → 다른 노드들`  
  → **내가 만든 블록을 네트워크에 전파**
- `다른 노드들 → 나`  
  → **다른 노드가 만든 블록을 내가 받아들임**

---

이 흐름을 완성하면, 우리는 드디어  
**진짜 “분산 네트워크”**,  
**서로 신뢰를 주고받는 노드 구조**를 갖추게 됩니다.
