# "오늘 수업에서 소켓 하나만 열어서 통신하는 것도 가능하지 않나요?"

---

## 결론 먼저!

> **맞아요. 실제로 “소켓 하나”만 열어서 통신하는 것도 충분히 가능합니다.**

하지만 지금 우리는 단순한 소켓 통신이 아니라,  
**"블록체인 네트워크 노드"를 학습 중이에요.**

그래서 지금처럼 **서버/클라이언트 역할을 구분해서 따로 구성하는 게**  
학습 목적에 훨씬 더 도움이 됩니다.

---

## 이 질문의 본질은?

학생이 묻는 건 사실 이거예요:

> “어차피 양방향 통신이 되는 거면,  
> 굳이 서버/클라이언트 역할을 나눌 필요가 있을까요?”

즉,

> “노드마다 그냥 `socket.connect()`만 써도 되는 거 아닌가요?”

---

## 그런데 블록체인은 "한 방향 통신"이 아니에요

블록체인은 단순히

> A가 B에게 메시지 한 번 보내고 끝  
> 이런 구조가 아니에요.

- A가 블록을 만들면 → B에게 보내고
- B는 그걸 받자마자 → C, D, E에게 다시 전파하고
- B는 또 **자기 체인을 A에게도 보내줄 수 있어야** 해요

즉, **지속적이고 상호적인 연결이 유지**돼야 해요.

---

## 그래서 우리는 이렇게 설계한 거예요

| 역할         | 사용 이유                                                           |
| ------------ | ------------------------------------------------------------------- |
| `P2P Server` | **다른 노드의 연결을 수신**하기 위해. 항상 열려 있어야 함           |
| `Client`     | **필요할 때 다른 노드에게 연결을 시도하고 요청을 보내기 위해** 사용 |

이 둘을 분리해서 쓰면 얻는 이점:

1. **내가 받은 요청과, 내가 보내는 요청을 구분**해서 처리할 수 있음
2. **초기 연결은 Client가 시작하고**, 이후엔 Server가 계속 수신함
3. **네트워크 토폴로지(구조)를 시각적으로 파악하기 쉬움**  
   → “이 노드는 얘에게 연결했고, 누군가 얘에게 들어왔다” 를 추적하기 쉬움

---

## 🧪 그럼 정말 "소켓 하나만"으로도 가능할까?

→ 가능은 해요.  
**WebSocket처럼 연결만 열면 양방향이 가능한 구조**에서는 특히 그렇죠.

하지만 조건이 붙어요:

- 누가 먼저 연결을 시작할지 항상 정해져 있어야 함
- 한쪽은 항상 `connect()`, 한쪽은 항상 `listen()`
- 역할이 명확히 정해지지 않으면 **연결 순서 꼬이면 통신 자체가 실패함**

---

## 지금은 학습 목적에 더 적합한 구조로 이해하면 돼요

> 우리가 지금 수업에서 구조를 나눈 이유는  
> **현실적인 블록체인 네트워크 구조를 시뮬레이션**하기 위해서예요.

- 노드마다 `서버 역할`과 `클라이언트 역할`을 모두 구현해보는 경험
- 연결, 수신, 전송 구조가 각각 어떻게 분리되고 동작하는지 체험
- 나중에 WebSocket, pub/sub 구조로 확장할 때도 이해가 쉬움

---

## 한 줄 정리

> 소켓 하나만으로도 통신은 가능해요.  
> 하지만 블록체인처럼 **쌍방 간 지속적 통신**이 필요한 시스템에선  
> 서버와 클라이언트를 **분리해서 구조를 명확히 표현**하는 게 더 안전하고 교육적으로도 효과적이에요.
