# 6. 왜 메타데이터가 필요한가? (`tokenURI` 구조 이해를 위한 전제)

---

앞에서 우리는 NFT를 발행하면 `tokenId`가 생긴다고 했습니다.
그러면 이제 이런 질문이 자연스럽게 떠오릅니다.

---

## ❓ 그럼 이 tokenId는 어떤 NFT인가요?

예를 들어, `tokenId = 1`.
이게 대체 뭘 의미하죠?

> 이게 고양이인가요?
> 강아지인가요?
> 빨간 모자를 쓴 원숭이인가요?

답은 없습니다.

---

왜냐하면,
**tokenId라는 숫자는 단지 ‘정렬’의 의미를 가진 index일 뿐이기 때문입니다.**

> **index = 정렬** > **tokenId = 정렬을 위한 최소 단위, 식별을 위한 번호표**

즉, 이 숫자는
어떤 특별한 정보를 담고 있는 게 아니라,
**그냥 "이건 첫 번째 NFT입니다"라는 구별 정보에 불과한 겁니다.**

---

## ✅ tokenId는 단순한 숫자일 뿐입니다

tokenId 자체에는

- 이름도 없고
- 설명도 없고
- 이미지도 없고
- 속성도 없습니다.

이 숫자는 **식별자이지, 정보가 아닙니다.**

---

좀 더 명확히 말하면,
`tokenId`는 **해당 NFT(토큰)에 대한 고유한 인덱스**일 뿐이고,
우리가 말하는 고양이든, 원숭이든, 특성이든…
**그 어떤 정보도 tokenId 안에는 들어 있지 않습니다.**

---

### 그래서 이 질문이 반드시 등장합니다:

> “이 tokenId는 어떤 정보를 가리키고 있나요? 혹은 어떤 정보를 가리키는 것인가요?”

바로 이 질문에 답해주는 함수가 **`tokenURI()`**입니다.

---

## tokenURI는 ‘정보의 참조점’입니다

이 함수는 다음과 같이 생겼습니다:

```solidity
function tokenURI(uint256 tokenId) public view returns (string memory);
```

이 함수가 반환하는 건 바로
**그 tokenId가 참조해야 할 외부 메타데이터의 주소**입니다.

예를 들어,

- tokenId = 1 → `"ipfs://bafy.../1"`
- tokenId = 2 → `"ipfs://bafy.../2"`

이렇게 **고유한 JSON 데이터의 주소를 만들어냅니다.**

---

## 그럼 이 주소에는 뭐가 있을까요?

정답: **JSON 포맷의 메타데이터**입니다.

대표적인 구조는 다음과 같습니다:

```json
{
  "name": "Red Monkey #1",
  "description": "A unique monkey with a red cap.",
  "image": "ipfs://Qmabcdef.../monkey1.png",
  "attributes": [
    { "trait_type": "Background", "value": "Blue" },
    { "trait_type": "Hat", "value": "Red Cap" }
  ]
}
```

---

### ✅ 이 JSON 파일이야말로 NFT의 실체입니다

- 이 JSON이 없으면, NFT는 **그저 숫자 하나짜리 토큰**입니다.
- 이 JSON이 있어야만 NFT가 **이름**, **설명**, **이미지**, **속성**을 갖습니다.

즉,

> 우리가 보는 NFT의 모습은 **온체인에 있는 게 아니라, 블록안에 저장하는데이터
> 오프체인 JSON에 존재합니다.** 블록밖에 저장하는데이터

## 정리하자면

| 구성 요소        | 의미                                            |
| ---------------- | ----------------------------------------------- |
| `tokenId`        | NFT를 구분하기 위한 숫자 인덱스                 |
| `tokenURI()`     | 해당 tokenId가 참조해야 할 외부 메타데이터 주소 |
| 메타데이터(JSON) | 이름, 설명, 이미지, 속성 등 NFT의 모든 정보     |

## 다시 한 번 강조합니다:

### **ERC-721은 온체인에 모든 정보를 저장하지 않습니다.**

- 온체인에는 **누가 무엇을 소유하고 있는지만** 저장됩니다.
- 실제 NFT의 의미와 정체성은
  → `tokenURI()`가 가리키는 **외부 메타데이터 JSON 파일**에 존재합니다.

## 그런데 왜 정보를 온체인이 아닌, 외부에 따로 저장할까요?

블록체인 개발을 처음 접하면 이런 의문이 생길 수 있습니다:

> “그냥 이름이랑 이미지 URL 같은 것도 컨트랙트에 상태값으로 저장하면 되지 않나요?”
> “굳이 왜 외부에 저장하고, tokenURI로 주소만 들고 있는 거죠?”

이 질문은 아주 중요합니다.

---

### 결론부터 말하면: 저장해도 됩니다.

- 컨트랙트 안에 JSON 전체를 저장해도 되고,
- 이름, 설명, 이미지 URL을 따로 상태값으로 저장해도 됩니다.

이건 **개발자의 자유**입니다.

> 하지만 대부분의 블록체인 개발자들은
> 그렇게 **하지 않습니다.**

---

### 왜냐하면, 온체인 저장은 현실적으로 “비용이 너무 비싸기 때문”입니다.

블록체인은

- 데이터를 블록에 저장할 때마다
- 그 데이터 크기만큼
- **가스(Gas)**라는 수수료를 지불해야 합니다.

```solidity
string public name = "Red Monkey #1"; // 이 한 줄도 gas를 먹습니다
```

이게 1개라면 괜찮지만,
NFT 1만 개를 발행할 때,
그 모든 이름, 설명, 이미지 URL, 속성을 **다 온체인에 저장**한다면?

> 👉 **엄청난 가스비**가 발생합니다.
> 👉 실제로도 유지보수가 어렵고, 수정도 불가능합니다.

---

그래서 블록체인에서는 이런 판단을 합니다:

> “온체인에는 핵심적인 상태값만 남기고,
> 부가적인 설명 정보는 외부에서 관리하자.”

## 이 판단은 마치 “데이터베이스 설계”와 같습니다

- 핵심 상태: tokenId, owner, balance, approval (→ **온체인**)
- 부가 설명: 이름, 설명, 이미지, 희소성 속성 등 (→ **오프체인**)

즉, NFT의 온체인 구조는 **RDBMS에서 정규화된 데이터베이스처럼**
**핵심 키만 들고 있고, 나머지는 외부 참조를 통해 불러오는 방식**과 유사합니다.

## 그래서 대부분의 개발자들은 어떻게 하나요?

- 메타데이터(JSON)를 AWS, Firebase 같은 클라우드에 저장하거나
- **IPFS**처럼 변경 불가능한 구조를 가진 분산 저장소에 업로드합니다

왜 IPFS가 특별한지는 다음 장에서 살펴보겠지만,
공통된 목적은 다음과 같습니다:

- 저장 비용을 줄이고
- 신뢰 가능한 참조 구조를 만들고
- 컨트랙트를 작고 가볍게 유지하며
- 메타데이터를 더 유연하게 관리하기 위해서입니다

## 제가 강조하고 싶은 건 이겁니다:

> **메타데이터를 온체인에 저장할 수도 있지만,
> 블록체인의 철학과 운영비용 구조를 고려했을 때,
> 대부분의 개발자와 설계자는 오프체인을 선택합니다.**

그리고 그 오프체인의 대표격이 바로 **IPFS**입니다.

이건 8장에서 자세하게 설명하고, 다음을은

"그래서 메타 데이터들은 어떻게 생겼고, 각 속성마다 무슨 뜻인데?"
