# `GENESIS` 객체 생성

자, 이제 우리가 만든 블록 설계도(interface)를 기준으로  
진짜 블록 하나를 객체로 만들어볼 시간입니다!

## 파일 경로

`250404/src/core/config.ts`

## 코드 작성

```ts
import { IBlock } from "./interface/block.interface";

export const GENESIS: IBlock = {
  version: "1.0.0",
  height: 0,
  timestamp: new Date().getTime(),
  hash: "0".repeat(64),
  previousHash: "0".repeat(64),
  merkleRoot: "0".repeat(64),
  difficulty: 0,
  nonce: 0,
  data: ["tx01"],
};
```

- `version`: 블록의 버전
- `height`: 체인의 첫 블록이므로 0
- `timestamp`: 블록이 생성된 시간 (실시간 값)
- `hash`: 블록의 해시값 (지금은 임시로 0으로 설정)
- `previousHash`: 이전 블록의 해시. 제네시스는 이전이 없으므로 0
- `merkleRoot`: 데이터 요약값. 이 역시 아직은 계산 안 했으니 0
- `difficulty`: 블록 생성 난이도. 지금은 기본값 0
- `nonce`: 해시 계산을 위해 반복한 횟수. 기본값 0
- `data`: 블록에 담긴 내용. 간단하게 ["tx01"] 으로 시작

## 블록체인의 첫 번째 조각

이 객체가 바로 우리가 만든 제네시스 블록,  
블록체인의 ‘첫 번째 조각’이에요.

여기까지 과정을 보면서 우리가 계속 강조했던 말 기억나죠?  
'블록은 객체다.'  
바로 이렇게, 하나의 체계적인 설계도(interface)를 기준으로  
객체처럼 명확하게 데이터를 담고 표현할 수 있습니다.

---

## 디렉토리 구조

### 디렉토리 구조 설명

```sh
250403/
├─ src/
│  ├─ core/                         # 블록체인의 핵심 기능 구현
│  │  ├─ _test/                         # 테스트 파일 모음
│  │  │  └─ block.test.ts                   # 블록 관련 유닛 테스트
│  │  ├─ block/                         # 블록 및 블록헤더 정의
│  │  │  ├─ block.ts                        # 블록 클래스 정의
│  │  │  └─ blockHeader.ts                  # 블록 헤더 정의 (이전 해시, 머클루트 등 포함)
│  │  ├─ crypto/                        # 암호 관련 기능 (해시 등)
│  │  │  └─ crypto.module.ts                # SHA256 등 해시 함수 모듈화
│  │  ├─ interface/                     # 공통 인터페이스 정의
│  │  │  ├─ block.interface.ts              # 블록 구조 타입 정의
│  │  │  └─ faillable.interface.ts          # 실패/예외 처리를 위한 인터페이스
│  │  └─ config.ts                      # 환경설정값, 제네시스 블록 정의 등
├─ jest.config.ts                       # Jest 테스트 환경 설정
├─ package.json                         # 의존성, 실행 스크립트 정의
├─ package-lock.json                    # 정확한 패키지 버전 기록
└─ tsconfig.json                        # 타입스크립트 컴파일 설정
```

그렇다면, 다음 작성할 파일은

- block.ts
- blockHeader.ts

위의 두 가지 파일이 될 것 같은데?
지금은 하나의 파일 (block.ts)로 추천하고 있잖아?
