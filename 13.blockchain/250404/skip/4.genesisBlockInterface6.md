# 제네시스 블록 구조 – 인터페이스부터!

## 수업 흐름

- 자, 우리가 실제 블록을 코딩으로 표현하려고 해요.
- 우리가 앞으로 만들 블록들, 그리고 블록체인 전체는 결국 이 한 덩어리 객체 구조에서 시작해요.
- 그래서 이 블록이 어떻게 생겼고, 왜 그렇게 설계됐는지를 제대로 이해하는 게 진짜 중요합니다.

## 1. 블록은 '객체'다!

> "블록이라고 해서 뭔가 특별한 건 아니에요. 그냥 객체예요.  
> 그 안에 어떤 정보가 담길지를 정하는 게 핵심이죠."

---

## 2. 블록은 사람 몸처럼 생겼다?!

> "비유하자면, **블록은 사람의 몸뚱아리처럼 두 부분으로 나뉩니다.**"

- **헤더(Header)**: 겉에서 보이는 정보들  
  → 예: 언제 태어났는지, 어떤 조건으로 만들어졌는지 => 이 블록이 누군지 말해주는 정체성
- **바디(Body)**: 속에 담긴 실제 내용 => 기록
  → 예: 거래 데이터

---

## 3. 설계도 만들기

> "이제 이 블록을 설계도처럼 추상화해볼게요.  
> **interface**, 즉 '이 객체는 이런 구조로 생겼습니다!' 라고 정의하는 작업입니다."

`src/core/interface/block.interface.ts` 생성

### 먼저 헤더 먼저 만들게요

```ts
export interface IBlockHeader {
  version: string;
  height: number;
  timestamp: number;
  previousHash: string;
}
```

- `version: string;`: 블록의 버전
- `height: number;`: 블록의 높이 0 ~ 부터 시작 블록의 순서
- `timestamp: number;`: 블록의 생성 시간
- `previousHash: string;`: 이전 블록의 해시

### 그 다음 몸뚱아리를 만들겠습니다.

```ts
export interface IBlock extends IBlockHeader {
  merkleRoot: string;
  hash: string;
  nonce: number;
  difficulty: number;
  data: string[];
}
```

- `merkleRoot: string;`: 머클루트 해시값
- `hash: string;`: 블록의 내용을 모두 더해서 해시화 시킨 문자열
- `nonce: number;`: 블록을 채굴하기 위해서 몇번이나 연산작업을 시도했는지
- `difficulty: number;`: 블록의 난이도. POW 알고리즘을 연산작업할때 맞춰야될 퀴즈 2 000
- `data: string[];`: 블록의 기록되는 트랜젝션들..

- 자, 이제 우리가 만드는 블록은 **IBlock이라는 설계도** => 체계를 따르기로 한 거예요.
- 앞으로 어떤 블록을 만들든, 이 구조를 따라야 하고,
- 이 틀에 맞춰서 제네시스 블록도 만들고, 다음 블록도 만들어질 겁니다.

---

이렇게 작성했는데

뭔가 놓치고 있는게 있는 것 같아.

정확히는 중요한 핵심을 말해야 할 것 같은 감이야.

예를 들면

값이 좀 많죠?  
기본적으로 9개의 속성을 기준으로 헤더, 바디로 나뉘어졌습니다.

집중적으로 보아야 할 것은 nonce...previousHash 등등의 속성이에요.

이 값이 왜 중요하냐면...

헤더와 바디를 왜 나뉘어 놓았을까?  
쉽습니다 => 단순히 이것 때문에 나뉜거에요.  
근데 그냥 나뉘어 놓은 것은 아닙니다.  
이러한 핵심 내용 때문에 나뉜거에요.  
자! 지금 이 시점에서는 이런 시선으로 봐야하고 이런 것이다!! 라는 것이 핵심입니다.
