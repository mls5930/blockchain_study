# 수업

## 목표: 코드 흐름을 따라가며 구조를 만드는 방법

### 1. **제네시스 블록이란 무엇인가?** — 개념 설명 (5~10분)

> "**제네시스 블록**은 블록체인의 첫 번째 블록입니다.  
> 모든 블록은 그 이전 블록을 참조하지만, 제네시스 블록은 예외입니다.  
> 그래서 제네시스 블록은 고정된 값으로 수동 생성되며,  
> 블록체인의 시작점이자 기준점이 됩니다."

- 왜 필요한가?
- 왜 수동으로 생성되는가?
- 어떤 값을 가지는가? (prevHash = "0", height = 0, timestamp 등)

➡ 학생들에게 이론적 베이스를 짧게 깔아주고 넘어가기

---

### 2. **`config.ts`부터 확인** — 제네시스 블록 정의 확인 (실습 진입)

```ts
// config.ts
export const GENESIS = {
  version: "1.0.0",
  timestamp: "2025-04-01T00:00:00Z",
  height: 0,
  previousHash: "0".repeat(64),
  merkleRoot: "GENESIS_MERKLE_ROOT",
};
```

- `GENESIS` 값이 어떻게 정의되어 있는지 확인
- 블록을 만들 때 이 데이터를 어떻게 사용할 것인지 미리 생각하게 하기

✅ **이 단계의 목표**:  
→ **우리가 만들 첫 번째 블록에 들어갈 값이 무엇인지** 알고 있어야 이후에 블록을 만들 수 있다.

---

### 3. **`block.interface.ts` & `blockHeader.ts` 연결 구조 확인**

- 블록이 어떤 속성들을 가지는지 인터페이스로 확인
- 블록 헤더가 어떤 역할을 하는지 간단히 리뷰  
  → `previousHash`, `merkleRoot`, `timestamp` 등이 왜 중요한가?

➡ 여기까지 보면 학생들은 **"어떤 속성으로 블록이 구성되는지"** 감이 생김

---

### 4. **`block.ts`에서 제네시스 블록 생성 메서드 만들기**

```ts
class Block {
  static createGenesisBlock(): Block {
    const genesisData = GENESIS;
    const header = new BlockHeader(
      genesisData.version,
      genesisData.timestamp,
      genesisData.height,
      genesisData.previousHash,
      genesisData.merkleRoot
    );
    return new Block(header, []);
  }
}
```

- 제네시스 블록을 생성하는 정적 메서드를 구현
- `BlockHeader`와 `Block` 클래스 간 구조 연결

**이 단계의 목표**

→ 제네시스 블록은 하드코딩된 데이터를 기반으로 수동 생성됨  
→ 이 과정이 모든 블록체인의 시작점이라는 걸 직접 체험하게 하기

---

### 5. **`block.test.ts`로 제네시스 블록 테스트**

```ts
describe("Genesis Block 생성 테스트", () => {
  it("제네시스 블록이 올바르게 생성되어야 한다", () => {
    const genesis = Block.createGenesisBlock();
    expect(genesis.header.height).toBe(0);
    expect(genesis.header.previousHash).toBe("0".repeat(64));
  });
});
```

- 학생들이 직접 `jest` 테스트로 검증해보며 수업 마무리
- “제네시스 블록의 무결성”을 단위 테스트로 확인
