# 8. 전체 기능 구현 흐름 정리

자, 오늘은 머리 아프지 않게 갑시다.  
**이제까지 만들었던 기능들을 한 줄로 쭉 꿰는 시간입니다.**

## 1단계부터 차근차근 따라가 봅시다.

### 1. 상태 선언

- 우리가 만들어야 할 변수는 총 세 가지입니다.  
  → `progress`, `reward`, `gameState`

이 변수들이 각각 무엇을 의미하냐면:

| 변수        | 의미                              |
| ----------- | --------------------------------- |
| `progress`  | 지금까지 몇 번 시도했는가         |
| `reward`    | 현재 쌓인 보상금 (오답일 때 누적) |
| `gameState` | 지금 게임이 진행 중인가? 끝났나?  |

---

### 2. 사용자 입력 흐름

- 사용자가 버튼을 누르고 숫자를 입력합니다.
- `gameStart()` 함수가 실행되며 내부 흐름이 시작됩니다.

## 자, 여기서부터가 중요합니다.

### 이 함수 안에서 "무슨 일이 벌어지는가?"

```solidity
require(progress < GAME_COUNT, "GameOver");
require(msg.value == ticket, "ticket amount error");
progress += 1;
```

- 먼저, 게임이 끝났는지를 **progress**로 판단합니다.
- 그리고 돈이 정확히 들어왔는지를 **ticket**으로 검증합니다.
- 조건이 통과되면 시도 횟수를 **progress += 1**로 올립니다.

그 다음 분기.

---

### 답을 맞췄다면?

```solidity
if (_value == random) {
  payable(msg.sender).transfer(address(this).balance);
  reward = 0;
  gameState = GameState.gameOver;
}
```

- 이더를 다 줍니다. → **보상**
- 보상 기록은 0으로 초기화합니다. → **정리**
- 게임 상태는 종료됩니다. → **마무리**

### 오답라면?

```solidity
else {
  reward += msg.value;
}
```

- 보상금만 누적되고 다시 도전 가능

## 여기서 조심할 점

> “그냥 progress가 10 되면 게임 오버 아닐까요?  
> 굳이 `GAME_COUNT`까지 선언할 필요 있나요?”

→ 네, 그렇게 생각할 수 있습니다.  
→ 그런데 이게 단순히 "숫자 10"이 아니라  
**“시스템 전체가 어떤 기준으로 동작하느냐”**를 정의하는 값이라는 걸 알아야 합니다.

---

### 핵심은 여기입니다:

> `progress`, `reward`, `gameState`는 서로 연동되어 있으며,  
> **이 중 하나라도 어긋나면 전체 흐름이 망가질 수 있습니다.**

## 관계 구조를 다시 정리하면

| 상태        | 언제 변하나?                       | 다른 상태와의 관계                        |
| ----------- | ---------------------------------- | ----------------------------------------- |
| `progress`  | 사용자가 시도할 때마다 +1          | `GAME_COUNT`와 비교 → 게임 종료 조건 판단 |
| `reward`    | 오답일 때마다 `msg.value`만큼 +    | 정답일 때 `0`으로 초기화                  |
| `gameState` | 정답 맞추거나 10번 다 시도 시 종료 | 종료되면 → 다시 입력 못하게 막음          |

## 이걸 잊지 마세요

- **reward만 쌓이고 gameState가 끝나지 않으면, 무한정 돈이 들어갈 수 있습니다.**
- **progress가 10을 넘어서도 gameState가 playing이면, 사용자는 계속 버튼을 누를 수 있습니다.**
- **상태 변수 하나만 봐선 안 되고, 이 셋은 반드시 “서로 연결된 상태 집합”으로 봐야 합니다.**

## 정리

오늘 수업에서 배운 핵심은 이겁니다:

> **컨트랙트 상태는 항상 "서로의 맥락 안에서" 관리돼야 한다.**  
> 단일 변수만 보고 판단하면, 게임은 언제든 망가질 수 있습니다.

이제 우리는

- 어떤 값이 어떻게 상태를 바꾸고
- 어떤 흐름에서 무엇이 위험한지를
- 전체적으로 연결된 구조로 이해할 수 있게 되었습니다.

다음은 이 흐름을 실제 실행으로 옮기는 전체 시나리오를 정리해봅시다.
