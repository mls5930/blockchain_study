# 5. 티켓 가격 상태 선언 및 활용

자, 과제 문제 2번을 다시 떠올려봅시다.

> **“0.01 ETH가 아닌 값을 보내면 게임이 시작되지 않도록 확인하세요.”**

이 말은 무슨 뜻일까요?

## 게임은 공정해야 합니다.

그래서 우리는 **모든 플레이어가 동일한 조건으로 참여하도록 만들고 싶습니다.**

- 어떤 사람은 0.005 ETH
- 어떤 사람은 0.1 ETH

이렇게 입장료가 다르면 시스템이 무너지겠죠?

그래서 우리는 **입장료를 고정**합니다.  
바로 이때 등장하는 것이 **`ticket` 상태 변수**입니다.

```solidity
uint256 private ticket = 10000000000000000;
```

## 그런데... 이 숫자, 너무 크지 않나요?

맞습니다. **일반적으로 보기에 말도 안 되게 큰 숫자**입니다.  
하지만 이건 **이더리움에서 매우 정확한 숫자 표현** 방식입니다.

> **EVM은 ETH를 다루지 않습니다.**  
> 정확히 말하면, **EVM은 “Wei”라는 최소 단위로만 금액을 처리**합니다.

### 다시 복습해볼까요?

| 단위 | 이름  | 값(Wei)                           |
| ---- | ----- | --------------------------------- |
| 1    | Wei   | 1                                 |
| 1e3  | Kwei  | 1,000                             |
| 1e6  | Mwei  | 1,000,000                         |
| 1e9  | Gwei  | 1,000,000,000                     |
| 1e18 | Ether | 1,000,000,000,000,000,000 (10^18) |

즉,

```solidity
0.01 ETH = 0.01 * 10^18 Wei = 10000000000000000 Wei
```

그래서 우리는 이렇게 쓰는 겁니다:

```solidity
uint256 private ticket = 10000000000000000;
```

### 그런데 이걸 자바스크립트로 넘길 때는?

EVM은 `Wei`를 쓰지만, 우리는 사용자를 위해  
**입력값을 쉽게 만들고 싶습니다.**

그래서 JavaScript에서는 이런 방식으로 전송합니다:

```js
value: web3.utils.toWei("0.01", "ether");
10000000000000000;
```

> 즉, 사람이 알아보기 쉬운 0.01 ETH를  
> 컴퓨터가 이해할 수 있는 10000000000000000 Wei로 변환해서 전송하는 겁니다.

## 그럼 이걸 어떻게 검증할까요?

컨트랙트 안에서 우리는 트랜잭션이 들어올 때  
**이더를 함께 보냈는지**,  
그리고 **그 양이 정확히 ticket과 일치하는지** 확인합니다:

```solidity
require(msg.value == ticket, "ticket amount error");
```

- `msg.value`는 방금 사용자가 보낸 ETH의 양 (단위는 Wei)
- `ticket`은 우리가 고정해놓은 정확한 참가비 (단위도 Wei)

## 그런데 왜 이걸 require로 막을까요?

> EVM은 ‘메세지 기반 상태 머신’입니다.  
> 사용자가 무언가를 실행한다는 건  
> 결국 **EVM에게 하나의 메세지를 보내는 일**입니다.

```js
contract.methods.gameStart(321).send({
  from: myAccount,
  value: web3.utils.toWei("0.01", "ether"),
});
```

이건 이런 뜻입니다:

> "나는 `321`이라는 숫자를 게임 정답으로 제출하고 싶어.  
> 그리고 0.01 ETH를 입장료로 낼게!"

이런 메세지를 받으면 EVM은  
이 안의 정보 중 하나인 `msg.value`를 확인하고  
우리가 설정한 `ticket`과 같은지를 비교합니다.

```solidity
require(msg.value == ticket, "ticket amount error");
```

이걸 통해 **참가비가 맞는 사람만 게임에 들어올 수 있게 됩니다.**

## 정리하면

| 항목           | 의미                                           |
| -------------- | ---------------------------------------------- |
| `ticket`       | 컨트랙트 내부에 정의된 **정확한 입장료**       |
| `msg.value`    | 사용자가 트랜잭션을 보낼 때 **함께 보낸 이더** |
| `require(...)` | 금액이 맞지 않으면 게임 거절                   |
| `toWei(...)`   | 사람이 보낸 0.01 ETH를 Wei로 변환하는 JS 함수  |

## 이걸 체화해야 합니다

- Solidity에서는 모든 금액 처리가 **정수이며, Wei 단위**입니다.
- 프론트엔드에서는 사람이 보기 편한 ETH 단위 → Wei로 변환이 필수입니다.
- `ticket`과 `msg.value`가 같은지를 항상 비교해야  
  **자산 흐름을 통제할 수 있는 컨트랙트**가 됩니다.

> 이제 우리는 단순히 돈을 주고받는 게 아니라,  
> **블록체인의 자산 흐름을 스스로 제어하는 코드**를 직접 설계하고 실행한 것입니다.

다음은 이 흐름을 **시도 횟수(GAME_COUNT)**와 연결해보겠습니다.  
넘어가볼까요?
