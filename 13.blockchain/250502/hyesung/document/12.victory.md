# 흐름 다시 잡기

자!  
지금까지 우리가 `gameStart`를 구현하다가…

갑자기 **msg**, **payable**, **EVM이 메세지를 해석하는 구조**,  
그리고 **이더를 CA가 받는 이유**까지  
**꽤 많은 내용이 한꺼번에 들어왔죠?**

어지럽죠?

어지럽다고 말하지 마세요 ^^  
**아직도 많이 남았으니까요.** ^^

## 자, 그러면 여기까지 **구현 흐름을 다시 정리**해봅시다.

1. **상태(state)를 선언**했습니다.

   - 정답(random), 시도(progress), 보상금(reword), 게임 상태(gameState)

2. **HTML 화면을 만들고**,

   - account, progress, reward가 화면에 보이도록 구성했습니다.

3. **gameStart 함수**를 만들었고,

   - 사용자가 입력한 숫자를 받아서
   - 조건에 맞는지 확인하고,
   - 시도 횟수를 1 늘리는 것 까지는 했습니다!

---

자, 이제 **다시 본론으로 돌아옵니다.**

우리가 **진짜 게임**을 만들고 싶다면  
**정답을 맞췄을 때, 보상을 줘야겠죠?**

그래서 다음 목표는 아주 단순하고도 중요합니다.

# **두 번째 목표: 승리하면 이더를 받는다 (gameStart 메서드 안)**

## 게임을 실행했다면, 이제 결과를 판단해야 한다

Baseball 게임의 핵심은 단순히 숫자를 입력하는 것이 아닙니다.

"**정답을 맞히면 보상을 받는다**"는 것이  
게임의 가장 큰 동기부여입니다.

사용자가 숫자를 입력하고  
그 숫자가 정답이라면,

- 스마트 컨트랙트는 즉시 보상을 지급해야 합니다.

이 과정을 통해  
**게임이 단순한 시뮬레이션이 아니라, 진짜 자산을 다루는 시스템**이라는 것을 경험할 수 있습니다.

## 정답을 맞췄을 때 해야 할 일

게임 규칙에 따라, 정답을 맞췄다면 다음 세 가지 행동을 해야 합니다.

| 순서 | 해야 할 일                                    | 이유                           |
| ---- | --------------------------------------------- | ------------------------------ |
| 1    | Contract에 쌓여 있는 이더를 플레이어에게 전송 | 보상 지급                      |
| 2    | 보상금 기록(reword)을 초기화                  | 다음 게임을 위해 리셋          |
| 3    | 게임 상태(gameState)를 종료(gameOver)로 변경  | 더 이상 게임이 진행되지 않도록 |

# **그럼, 어떻게 코딩할까요?**

## 1. 입력값과 정답을 비교한다

```solidity
if (_value == random) {
    ...
}
```

- 사용자가 입력한 `_value`가
- 컴퓨터가 저장해둔 `random` 값과 같으면
- 안쪽 로직을 실행합니다.

✅ 입력값이 정답인 경우에만 보상이 지급됩니다.

## 2. Contract에 쌓인 이더를 전부 전송한다

```solidity
payable(msg.sender).transfer(address(this).balance);
```

- `payable(msg.sender)` : 이더를 받을 수 있도록 주소를 변환합니다.
- `address(this).balance` : 이 스마트 컨트랙트가 가지고 있는 모든 이더를 가져옵니다.
- `transfer()` : 해당 이더를 플레이어에게 전송합니다.

✅ 정답을 맞춘 사용자는 **Contract 안의 모든 이더를 보상으로 받게 됩니다.**

## 3. 보상금(reword)을 초기화한다

```solidity
reword = 0;
```

- 상금을 지급했기 때문에
- Contract 안의 보상금 기록도 초기화해야 합니다.

다음 게임을 위해 준비하는 과정입니다.

## 4. 게임 상태를 gameOver로 변경한다

```solidity
gameState = GameState.gameOver;
```

- 게임은 끝났습니다.
- 더 이상 새로운 입력을 받을 수 없어야 합니다.

gameState를 `playing`에서 `gameOver`로 변경합니다.

## 최종적으로 gameStart() 안 코드는 이렇게 됩니다

```solidity
function gameStart(uint256 _value) public payable {
    require((_value >= 100) && (_value < 1000), "_value error (100 ~ 999)");

    progress += 1;

    if (_value == random) {
        require(reword <= address(this).balance, "reword overflow");

        payable(msg.sender).transfer(address(this).balance);

        reword = 0;
        gameState = GameState.gameOver;
    } else {
        reword += msg.value;
    }
}
```

## 흐름 요약

| 순서 | 행동                  | 설명                              |
| ---- | --------------------- | --------------------------------- |
| 1    | 입력값 검증 (require) | 잘못된 입력 차단                  |
| 2    | 진행도(progress) 증가 | 시도 기록                         |
| 3    | 정답 맞췄을 때        | 보상 지급, 기록 초기화, 게임 종료 |
| 4    | 틀렸을 때             | 입장료 누적 (reword += msg.value) |

## 학생분들에게 꼭 강조할 점

- 스마트 컨트랙트는 **조건을 정확히 판단하고**,  
  그에 따라 **자산을 다루는 행동(이더 전송)**을 해야 한다.
- **payable**, **transfer**, **require**, **enum** 등의 개념이 모두  
  실제 서비스 로직에 연결된다는 것을 체감해야 한다.
- 틀렸을 때도 기록이 남고, 실패할 때마다 보상금이 쌓이는 구조를 자연스럽게 이해해야 한다.

## 요약

- gameStart는 단순한 입력 함수가 아니다.
- 입력 → 검증 → 보상 → 상태변경까지  
  게임 전체의 핵심 흐름을 책임지는 메서드다.
