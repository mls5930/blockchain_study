# 지난주 Counter 프로젝트 복습

우리는 지난주에 **Solidity의 기본 구조와 문법을 체화하는 아주 중요한 실습**을 진행했습니다.

## 실습 주제: **Counter** — 책임이 있는 숫자 올리기

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract Counter {}
```

이 단순한 컨트랙트를 기반으로  
**"책임이 있는 숫자 관리"**, 그리고  
**Solidity의 핵심 함수 유형(view, pure, modifier 등)**을 실제로 작성하고 실험해보았죠.

## 지난 실습에서 우리는 이런 걸 했어요

1. `constructor(uint _initial)`로

   - 배포자가 **초기 숫자(count)를 설정**할 수 있도록 만들었고,

2. `increment()` 함수에는

   - **`modifier onlyOwner`를 설정해서**
   - **오직 배포자만 숫자를 증가시킬 수 있도록 제한**했죠.

3. `getCount()`는 `view` 함수로 선언해서

   - 상태는 바꾸지 않고, **읽기 전용으로 값을 반환**하도록 했고,

4. `isOver(uint target)`이라는 비교용 함수도 만들었어요.

   - `count`가 특정 값보다 큰지를 확인하고, true/false를 반환했습니다.

5. `sum(uint a, uint b)`는
   - 외부 입력값만을 이용해서 결과를 계산하는 `pure` 함수였습니다.

---

## 이 실습을 통해 배운 것은?

=> 스마트 컨트랙트는 단순히 숫자만 저장하는 도구가 아닙니다.  
=> **권한, 책임, 상태 조회, 계산 등 다양한 행위가 분리된 구조**로 존재해야 합니다.  
=> 그리고 각각의 함수는 **어떤 종류의 함수인지**, **누가 실행할 수 있는지**, **무엇을 변화시키는지**에 따라 책임이 명확해야 하죠.

## 결과적으로 우리는

- 단순한 숫자 컨트랙트를 통해
- Solidity의 함수 구조, 실행 조건, 상태 관리 방식을
- **"내가 직접 구현하고, 실험하고, 확인하는 방식"**으로 배웠습니다.

## 그런데, 다시 한 번 생각해봅시다

**진짜 세상에 존재하는 서비스들**은 이렇게 단순할까요?

- 사용자 입력
- 조건 비교
- 상태 변화
- 누적된 기록
- 누군가에게 보상 전송
- 게임 종료와 같은 복합 흐름

=> 이런 건 **단순한 Counter 컨트랙트만으로는 절대 구현할 수 없습니다.**

## 그래서 오늘은 한 단계 더 나아가보려 합니다

오늘 우리가 만들 프로젝트는  
바로 **Baseball Game**이라는 작은 게임 플랫폼입니다.

- **정답 숫자를 숨기고**
- **입력값을 받고**
- **시도 횟수를 누적하고**
- **정답을 맞추면 보상을 자동으로 주고**
- **게임 상태를 마무리하고 종료시키는 흐름**

즉, 오늘은  
**실제 서비스 로직에 가까운 흐름을 직접 스마트 컨트랙트로 구현**해보는 겁니다.

## 정리하면

지난주는

> **"Solidity 문법과 함수 구조를 체계적으로 체화한 시간"**이었다면,

오늘은

> **"그 문법을 실전 도메인(Baseball Game)에 적용해보는 시간"**입니다.

---

이제부터는  
**숫자 하나를 올리는 게 아니라,  
상태를 관리하고, 게임 결과를 판별하고,  
자산 흐름까지 처리하는 흐름**을 직접 만들어봅시다.
