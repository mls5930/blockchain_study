# 교수님! sendTransaction()이 아니라 send()를 쓰는 이유는 뭔가요?

---

## 어제랑 다르잖아요?

> 어제는 `sendTransaction(tx, privateKey)`로  
> 트랜잭션 객체를 만들고 서명도 우리가 직접 처리했잖아요?

```js
const signedTx = await web3.eth.accounts.signTransaction(tx, PRIVATE_KEY);
await web3.eth.sendSignedTransaction(signedTx.rawTransaction);
```

→ 여기서 우리는 **비밀키를 코드 안에 넣고**,  
→ 직접 서명도 하고,  
→ 트랜잭션도 우리가 보내는 구조였어요.

근데 오늘은?

```js
await contract.methods.increment().send({ from: sender });
```

> 아니 이건 너무 간단하잖아요?  
> 서명은요? 비밀키는요??

---

### 어제 구조

- 우리는 **Node.js 환경에서 배포 스크립트 (`deploy_to_sepolia.js`)**를 실행했습니다
- 트랜잭션 객체를 만들고, **서명도 코드 안에서 직접 처리**했죠
- 그래서 **비밀키도 코드 내부에서 직접 가지고 있어야 했습니다**

이 구조는 일반적으로

> **비사용자 환경(즉, 프로그램이나 CLI 도구가 트랜잭션을 주도하는 상황)**에서 사용하는 방식입니다.

즉, **사람이 직접 서명하는 게 아니라,  
코드가 모든 걸 대신 처리해야 할 때 필요한 구조**입니다.

---

### 오늘 구조

- 우리는 **브라우저 환경에서**,
- 사용자의 **지갑(MetaMask)**와 직접 연결해서 트랜잭션을 보냅니다
- 서명은 **사용자 지갑이 직접** 해줍니다
- 우리는 비밀키를 알 필요도 없고, 알 수도 없습니다.

---

## 이게 무슨 말이지?

> 우리는 단순히 `from: sender`만 넘겼습니다.  
> 근데 트랜잭션이 전송되고, 서명도 된다고요?

여기서 중요한 질문이 하나 나옵니다.

> "서명은 무조건 비밀키로만 할 수 있다고 배웠잖아요?  
> 근데 주소만 주고 어떻게 서명을 해요? 비밀키는 어디서 나온 거예요?"

정확한 질문입니다.

---

## ✅ 먼저 원칙부터 확인합시다

블록체인에서 서명(Signature)은  
→ **비밀키(Private Key)** 없이는 절대 할 수 없습니다.

주소, 공개키는 있어도  
→ 서명은 오직 **비밀키를 가진 주체만** 가능합니다.

그리고 그 비밀키는 **절대로 노출되어선 안 됩니다.**

---

## ❌ 그렇다고 우리가 비밀키를 넘기는 건 아니다

지금 우리가 작성한 코드를 보면 이렇게 되어 있어요:

```js
await contract.methods.increment().send({ from: sender });
```

여기서 `sender`는 그냥 사용자의 **지갑 주소 (EOA)**입니다.  
비밀키는 직접 넘기지 않았습니다. 근데도 트랜잭션이 전송됐어요. 왜죠?

---

## 진짜 서명은 누가 했을까?

> **메타마스크가 했습니다.**

정확히 말하면:

1. 메타마스크는 사용자의 지갑을 **브라우저에 확장 프로그램 형태로 설치**합니다.
2. 지갑 생성 시, **비밀키는 브라우저 로컬에 암호화된 형태로 저장**됩니다.
3. 사용자가 `eth_requestAccounts`를 통해 메타마스크 지갑을 연결하면,
   - 웹페이지는 메타마스크로부터 지갑 주소(EOA)를 전달받습니다.
4. 이후 `send({ from: sender })`를 실행하면,
   - Web3는 내부적으로 `eth_sendTransaction` JSON-RPC 요청을 `window.ethereum`에 보냅니다.
   - `window.ethereum`은 메타마스크의 인터페이스입니다.
5. 메타마스크는
   - 해당 `from` 주소에 대한 비밀키를 가지고 있는지 확인하고,
   - **팝업을 띄워 사용자에게 "이 트랜잭션에 서명하시겠습니까?"라고 묻습니다.**
6. 사용자가 동의하면
   - 메타마스크가 **내부적으로 비밀키로 서명을 수행**하고,
   - 트랜잭션을 이더리움 네트워크로 전송합니다.

---

## 중요한 점은 이겁니다

- **우리는 주소만 넘겼습니다.**
- 하지만 메타마스크는 **해당 주소와 연결된 비밀키를 이미 보유하고 있습니다.**
- 그래서 **우리는 비밀키를 직접 다룰 필요도, 알 필요도 없습니다.**
- 서명은 브라우저에서 보이지 않는 **메타마스크 내부**에서 안전하게 이루어집니다.

---

## 공식 문서에서도 이렇게 설명하고 있습니다

> **When a site calls `eth_sendTransaction`, MetaMask will create and sign the transaction using the private key associated with the from address.**  
> — MetaMask Docs: `eth_sendTransaction`

---

## 오해 방지: 절대 비밀키를 유추하는 게 아닙니다

> "주소를 보면 비밀키를 알 수 있어서 그런 거 아닌가요?"

아닙니다.

Ethereum 주소는 다음처럼 생성됩니다:

```
비밀키 → 공개키 (secp256k1) → keccak256 해시 → 마지막 20바이트 → 주소
```

이건 **단방향(one-way)** 함수입니다.  
→ 주소로부터 **비밀키를 역산하는 건 수학적으로 불가능**합니다.

---

## 그래서 이 구조는 안전한가요?

네, 안전합니다.  
왜냐하면:

- **비밀키는 브라우저 확장 내부에만 존재**하고,
- **JavaScript 코드에서는 절대 접근할 수 없으며**,
- **서명은 메타마스크가 직접 처리**하고,
- **사용자 승인 없이는 아무 일도 일어나지 않습니다.**

이게 바로

> 메타마스크가 **인터페이스 + 프록시 + 서명자(Signing Agent)** 역할을 한다고 말한 이유입니다.

## 핵심 문장 요약 (최종 정리)

> 블록체인에서 **트랜잭션은 반드시 비밀키로 서명되어야**만 전송할 수 있습니다.  
> 하지만 오늘 실습에서는 **우리가 직접 비밀키를 다루지 않았습니다.**

→ 그 이유는, 우리가 사용한 메서드가

```js
contract.methods.increment().send({ from: address });
```

> 이기 때문입니다.

이 구조는 다음처럼 동작합니다:

- `send()`는 내부적으로 **window.ethereum**을 통해  
  **메타마스크에 트랜잭션 서명을 요청**합니다.
- 메타마스크는 해당 `from` 주소에 대한 **비밀키를 내부적으로 보유**하고 있고,
- 사용자가 **팝업에서 승인**하면,
- 메타마스크가 **대신 비밀키로 서명**한 뒤,
- 트랜잭션을 **이더리움 네트워크에 전파**합니다.

---

> 이 과정에서 우리는 **비밀키를 직접 다루지 않았고**,  
> 메타마스크는 **비밀키를 절대 외부로 노출하지도 않았습니다.**

---

그래서 `send()`는

> 메타마스크가 **서명자이자 전송자(Signing & Sending Agent)** 역할을 해주기 때문에 가능한 구조입니다.

> 우리는 **주소만 넘겼지만**, 메타마스크는  
> 해당 주소와 매핑된 **비밀키를 내부에 보유하고 있으므로**,  
> **서명까지 자동으로 대신해줄 수 있는** 것입니다.

---

## 이걸 꼭 기억하세요

> `sendTransaction()`은 **내가 직접 서명할 때**,  
> `send()`는 **메타마스크가 대신 서명해줄 때** 씁니다.
