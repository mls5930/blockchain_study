# 카운터 조회 상호작용부터 구현해보자

## 먼저! READ부터 시작합니다

보통 CRUD라고 하면 **Create, Read, Update, Delete**죠?  
근데 **가장 먼저 구현하기 좋은 건 Read**,  
즉 **조회**입니다.

왜냐면?

- 네트워크에 **트랜잭션을 전송할 필요가 없고**,
- 지갑 연결도, 서명도 필요 없습니다.
- 일단 읽기만 하면 되니까 부담이 없어요!

그래서 오늘은  
**`getCount()`를 통해 카운트 값을 불러오는 상호작용**부터 구현해보겠습니다.

## Web3와 Axios를 설치해봅시다

우리는 React로 프로젝트 구성하지 않습니다.  
왜냐하면, 오늘 이걸 **기초부터 실습으로 빠르게 체득해야 하니까요!**

그래서 우리는 **CDN 방식**을 씁니다.  
브라우저에 `<script>`로 붙여버리는 방식이죠.

```html
<script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
```

## Web3 인스턴스 생성하기

자 이제 Web3를 써야겠죠?  
이제 블록체인과 대화할 준비를 해봅시다.

```html
<script>
  let web3;
</script>
```

=> Web3(https://sepolia.io/v3/945....)
Web3는 블록체인과 연결을 위한 **통신 객체**예요.  
근데 이걸 바로 생성할 수는 없고,  
**"어디랑 연결할 건지"** 먼저 알려줘야 합니다.

## 우리는 Sepolia랑 연결할 건데, 오늘은 `window.ethereum` 씁니다

보통 이런 식으로 많이 연결하죠:

```js
web3 = new Web3(
  new Web3.providers.HttpProvider("https://sepolia.infura.io/v3/your-api-key")
);
```

그런데 **오늘은 이걸 안 씁니다.**  
왜냐고요?

### 이유는 딱 하나.

> 우리는 사용자의 **지갑과 직접 상호작용**할 거기 때문입니다.

그 지갑이 바로 **메타마스크(MetaMask)**죠.

메타마스크는 설치되면 브라우저에 **`window.ethereum`** 이라는 객체를 자동으로 넣어줍니다.  
이 객체는 사용자 지갑을 제어할 수 있는 인터페이스입니다.

그래서 우리는 다음처럼 씁니다:

```js
web3 = new Web3(window.ethereum);
```

## 어? 그럼 Sepolia RPC URL은 안 써도 돼요?

좋은 질문입니다.

보통 블록체인에 연결할 땐 이런 식으로 직접 RPC를 지정합니다:

```js
web3 = new Web3(
  new Web3.providers.HttpProvider("https://sepolia.infura.io/v3/your-api-key")
);
```

즉, **“이 주소로 요청 보내라”**는 걸 명시적으로 알려주는 방식이죠.

그런데 오늘은 이렇게 하지 않습니다.  
왜냐하면 우리는 **메타마스크와 직접 상호작용**하기 때문입니다.

---

### 그럼 메타마스크는 어떻게 동작하는 걸까?

메타마스크는 단순한 지갑 프로그램이 아니라는걸, 더 설명하자면,

> 브라우저에 설치되는 **확장 프로그램(Extension)**이며,  
> 설치되는 순간 브라우저 내부에 **`window.ethereum`** 이라는 객체를 자동으로 삽입합니다.

이 객체는 우리가 웹 페이지(HTML, JavaScript)에서  
→ **메타마스크와 직접 대화할 수 있게 해주는 인터페이스**이자,  
→ 메타마스크가 사용자를 대신해 네트워크 요청을 처리해주는 **프록시(proxy)** 역할을 합니다.

---

### 이 `window.ethereum` 객체는 어떤 역할을 할까?

이 객체 안에는 우리가 상호작용할 수 있는 다양한 속성과 기능들이 담겨 있습니다.  
예를 들어:

| 속성 / 메서드         | 설명                                                                                   |
| --------------------- | -------------------------------------------------------------------------------------- |
| `isMetaMask`          | 현재 지갑이 메타마스크인지 여부 (Boolean)                                              |
| `selectedAddress`     | 현재 연결된 계정 주소 (지갑 주소)                                                      |
| `chainId`             | 현재 연결된 네트워크 체인 ID (예: Sepolia = 0xaa36a7)                                  |
| `request()`           | 메타마스크와 통신하는 핵심 함수 (`eth_requestAccounts`, `eth_sendTransaction` 등 호출) |
| `on(event, callback)` | 메타마스크 이벤트 리스너 등록 (예: 계정 변경, 네트워크 변경 감지 등)                   |

---

### 예: 현재 사용자가 어떤 네트워크에 연결되어 있는지 확인할 수 있어요

아래와 같이 `ethereum.chainId`를 통해,

> 사용자가 현재 메타마스크에서 어떤 네트워크(RPC URL)에 연결되어 있는지 확인할 수 있습니다:

```js
console.log(window.ethereum.chainId);
// 예: "0xaa36a7" → Sepolia 네트워크
```

또는 다음처럼 요청해서 확인할 수도 있습니다:

```js
const chainId = await window.ethereum.request({ method: "eth_chainId" });
console.log(chainId);
```

이렇게 확인이 가능하다는 건,

> **사용자의 지갑이 어떤 네트워크에 연결되어 있는지를  
> 브라우저에서 메타마스크를 통해 바로 알 수 있다는 뜻**입니다.

---

### 그래서 메타마스크는 "인터페이스이자 프록시"입니다

우리가 지갑과 대화할 수 있는 창구일 뿐만 아니라,

> 그 창구 뒤에는 **사용자가 선택한 RPC 서버(Sepolia, Goerli 등)**가 이미 연결되어 있어요.

즉, 우리는 직접 `https://sepolia.infura.io/v3/...` 같은 RPC 주소를 적을 필요 없이,

> **메타마스크가 모든 걸 대신 연결해주고, 브라우저에 그 인터페이스를 제공해주는 구조**입니다.

---

### 그래서 우리는 `RPC URL`을 직접 쓸 필요가 없습니다

- 사용자가 메타마스크에서 Sepolia 네트워크를 선택했다면,
- 메타마스크는 이미 그에 해당하는 RPC 서버 주소를 알고 있고,
- 우리가 굳이 `https://...` 형태의 URL을 다시 적을 필요 없이,
- **`window.ethereum`을 통해 그 기능을 대신 쓸 수 있게 해주는 구조**입니다.

---

### 정리하자면

메타마스크는 브라우저에 **`window.ethereum` 객체를 삽입**하여,  
우리가 웹페이지(JavaScript) 상에서 **사용자의 지갑과 직접 통신**하고,  
동시에 사용자가 선택한 **블록체인 네트워크(Sepolia 등)와 연결**할 수 있도록 돕는  
**인터페이스이자 중개자(proxy)** 역할을 수행합니다.

이 객체는 단순한 통로가 아닙니다.

**계정 정보, 네트워크 상태, 체인 ID**,  
그리고 **서명 요청, 트랜잭션 전달 등 주요 기능을 관리하는 정보 허브**입니다.

우리가 `window.ethereum`을 통해 메타마스크에 요청을 보내면,

메타마스크는 **현재 브라우저에 연결된 사용자 지갑의 설정**에 따라  
해당 네트워크(RPC)에 **요청을 자동으로 전달하고 처리**합니다.  
(※ 이때 네트워크는 **사용자가 메타마스크에서 직접 선택한 것**입니다.  
즉, **노드나 코드가 아닌 사용자의 선택**이 기준입니다.)

따라서 우리는 직접 RPC URL을 다룰 필요 없이,

**브라우저에 설치된 메타마스크 인터페이스만으로**  
지갑 연결과 네트워크 통신을 모두 처리할 수 있는 구조를 사용할 수 있게 되는 것입니다.

## 메타마스크가 없으면?

이런 경우도 대비해야겠죠?

```html
<script>
  let web3;
  if (typeof window.ethereum !== "undefined") {
    web3 = new Web3(window.ethereum);
  } else {
    alert("MetaMask가 설치되어 있지 않습니다.");
  }
</script>
```

- 메타마스크가 설치되어 있다면 `window.ethereum`이 존재합니다.
- 없으면? 경고창을 띄웁니다.

---

## 여기까지 정리!

| 개념                        | 설명                                                                 |
| --------------------------- | -------------------------------------------------------------------- |
| `Web3`                      | 블록체인과 연결해주는 자바스크립트 객체. 스마트 컨트랙트 호출의 기반 |
| `window.ethereum`           | 브라우저에 설치된 메타마스크가 자동 삽입하는 지갑 인터페이스         |
| RPC URL을 직접 안 쓰는 이유 | 메타마스크가 이미 선택된 네트워크의 RPC와 연결되어 있기 때문         |
