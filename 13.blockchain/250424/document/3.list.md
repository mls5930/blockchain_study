# 트랜잭션을 보내기 위해 우리가 준비해야 할 것들

## 1. 사용자는 버튼만 누른다.

하지만 우리는 그 **버튼 뒤의 구조 전체를 설계**해야 한다.

이제부터는 단순히 메타마스크가 무엇인지 아는 수준을 넘어서,

"메타마스크와 dApp이 실제로 어떻게 연결되고 서명까지 흘러가는가?"  
를 **프론트엔드 개발자의 시선으로** 들여다볼 시간입니다.

사용자는 클릭 한 번이면 되지만,  
우리는 그 클릭이 일으킬 **행동 요청**,  
즉 **트랜잭션 객체(transaction object)**를 만들어야 합니다.

## 2. 트랜잭션을 보낸다는 건 상태를 바꾸겠다는 뜻이다

블록체인에서 어떤 행위든 **상태 변경**을 포함하면,  
그건 반드시 **트랜잭션을 통해서만** 이루어져야 합니다.

예:

```solidity
function increment() public {
    count += 1;
}
```

이 함수는 **count 값을 바꾸는 함수**입니다.  
→ 즉, **상태 변경**이죠.  
→ 따라서 반드시 트랜잭션이 필요하고, **서명도 필요**합니다.

---

## 3. 그럼 실제로 우리가 준비해야 할 것은?

1. **Web3 인스턴스 생성**

   - `const web3 = new Web3(window.ethereum);`

2. **사용자 계정 요청 (지갑 연결)**

   - `await window.ethereum.request({ method: 'eth_requestAccounts' })`

3. **서명할 계정 확인**

   - `const accounts = await web3.eth.getAccounts();`

4. **컨트랙트 인스턴스 생성**

   - `new web3.eth.Contract(ABI, contractAddress)`

5. **트랜잭션 요청 보내기**
   - `contract.methods.increment().send({ from: accounts[0] })`

## 4. 여기서 중요한 점

- `.send()`는 **서명이 필요한 요청**입니다.  
  내부적으로 메타마스크가 팝업을 띄우고,  
  사용자의 **명시적 승인을 받아 서명을 진행**합니다.

- 메타마스크는 서명된 트랜잭션을 **네트워크로 전파**하고,  
  그 결과로 **트랜잭션 해시(txHash)**를 반환해줍니다.

## 5. 트랜잭션이 전파되면?

블록체인 네트워크는 이 트랜잭션을

> **mempool(메시지 대기실)**에 보관하고,  
> 채굴자 또는 검증자가 선택하여 블록에 포함시킵니다.

그 이후 Etherscan 같은 블록 탐색기를 통해  
→ 우리가 만든 트랜잭션이 **정말 반영되었는지 추적**할 수 있습니다.

## 오늘의 흐름 요약

```
웹 → 트랜잭션 생성 → 메타마스크 서명 → 블록체인 전파 → Etherscan 확인
```

## 개발자로서 알아야 할 책임

사용자는 “딸깍”만 하지만,  
우리는 그 딸깍을  
**실제 상태 변화로 이어지게 만드는 전체 흐름을 설계해야** 합니다.

메타마스크는 "서명 도구"일 뿐,  
**우리가 제대로 된 트랜잭션을 구성하지 않으면 아무 일도 일어나지 않습니다.**

---

이게 바로 **블록체인 기반 dApp 개발자**가 된다는 뜻입니다.  
우리는 이 세계에서 **기능을 설계하고 책임을 구조화하는 사람들**입니다.
