자 다시 돌아오겠습니다.  
아까 비밀키가 필요한 상황에 대해서 말했었죠?

### 상황 2. 개발자가 단독으로 CLI로 배포하거나 실행할 때

아까도 말씀드렸던 것처럼, 그리고 어제 우리가 했던 것처럼

```js
const signedTx = await web3.eth.accounts.signTransaction(
  tx,
  process.env.PRIVATE_KEY
);
await web3.eth.sendSignedTransaction(signedTx.rawTransaction);
```

→ 이건 **사람이 직접 버튼을 누르지 않고**,  
→ **스크립트가 트랜잭션을 생성, 서명, 전송까지 처리**하는 구조입니다.

그래서 `PRIVATE_KEY`가 필요합니다.

## 그럼 .env에 PRIVATE_KEY를 넣는 건 안전한가요?

이 질문도 정말 중요합니다. 핵심은:

> `.env`는 안전한 공간이 아닙니다.  
> **코드와 환경이 격리되어 있을 뿐, 접근은 가능합니다.**

### 다음과 같은 상황이면 매우 위험합니다

- `.env` 파일을 GitHub에 실수로 올렸을 경우 (최악)
- 서버 코드가 해킹되어 환경변수 접근이 가능해진 경우
- `.env`에 접근 가능한 외부 라이브러리가 취약한 경우

---

### 그래서 보통 어떻게 보관하나요?

| 보안 전략             | 설명                                                         |
| --------------------- | ------------------------------------------------------------ |
| 환경변수 암호화       | 서버에 배포할 때 암호화된 형태로 `.env`를 관리               |
| Key Management System | AWS KMS, HashiCorp Vault 같은 별도 **키 관리 시스템 사용**   |
| 접근 제어 분리        | 트랜잭션 전송 권한이 있는 서버는 최소한의 경로로만 접근 허용 |
| Git Ignore 필수       | `.env`는 무조건 `.gitignore`에 포함시켜야 함                 |

## 요약하자면

> **PRIVATE_KEY가 필요한 경우는 메타마스크가 없고,  
> 우리가 코드에서 직접 서명해야 할 때입니다.**

> 이 키는 매우 민감한 정보이며,  
> `.env`에 넣는다고 해서 완전히 안전한 것이 아닙니다.

> 실무에서는 반드시 **키 관리 전략**을 별도로 두고,  
> 개발 중에도 항상 **비밀키는 노출되지 않도록 철저히 관리**해야 합니다.

## 한 줄 요약

> 메타마스크가 있다면 서명을 대신해줍니다.  
> 메타마스크가 없다면 **우리가 비밀키로 직접 서명해야 하고**,  
> 그때는 **비밀키 관리가 곧 보안입니다.**
