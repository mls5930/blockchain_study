# 자 여기까지! 따라오느라 정신없었죠?

지갑 연결부터 트랜잭션 전송까지,  
정말 많은 걸 한 번에 구현해봤습니다.

> 그래서 이제 **전체 흐름**을 한 번에 정리해봅시다.  
> 각 단계에서 **무슨 일이 벌어졌고**,  
> **누가 책임지고**,  
> **어떤 기술이 작동했는지** 정확히 짚어보는 시간입니다.

---

## 1. 웹3 인스턴스 생성

```js
web3 = new Web3(window.ethereum);
```

- 브라우저 환경에서는 `window.ethereum`을 통해 메타마스크와 연결합니다.
- 별도로 RPC URL을 넣지 않아도 됨 → 메타마스크가 내부적으로 처리

---

## 2. 지갑 연결 요청

```js
await window.ethereum.request({ method: "eth_requestAccounts" });
```

- 사용자의 지갑 연결을 요청
- 사용자가 직접 팝업을 통해 연결 허용해야 함

---

## 3. 계정 정보 가져오기

```js
const accounts = await web3.eth.getAccounts();
const sender = accounts[0];
```

- 연결된 계정 목록 중 첫 번째 계정(보통 기본 계정)을 사용
- 이 계정이 트랜잭션의 `from` 주소가 됨

---

## 4. ABI 불러오기

```js
await loadABI();
```

- 컨트랙트와 상호작용하려면 ABI가 반드시 필요
- Solidity 코드의 “함수 설명서” 역할
- 브라우저는 bytecode만 보고는 함수 정보를 알 수 없음 → 반드시 따로 불러와야 함

---

## 5. 컨트랙트 인스턴스 생성

```js
const contract = new web3.eth.Contract(contractABI, address);
```

- ABI + 컨트랙트 주소(CA)를 이용해 web3가 컨트랙트 인스턴스를 생성
- 이 인스턴스를 통해 `.methods.getCount()` 등 함수를 호출할 수 있음

---

## 6. 상태 읽기 (조회)

```js
await contract.methods.getCount().call();
```

- 조회는 `call()`로 처리
- 트랜잭션 아님 → 서명 필요 없음 → 가스비도 없음

---

## 7. 상태 변경 (트랜잭션 발생)

```js
await contract.methods.increment().send({ from: sender });
```

- 이건 트랜잭션입니다 → EVM 상태 변경
- → **가스비 발생**
- → **서명 필요**
- → **네트워크에 기록됨**
- 서명은 메타마스크가 내부적으로 수행하고, 사용자가 팝업으로 동의해야 전송됨

---

## 8. 트랜잭션이 성공하면?

```js
tx.transactionHash;
```

- 트랜잭션 해시를 통해 Etherscan에서 트랜잭션 내용을 확인할 수 있음

---

## 절대 놓치면 안 되는 보안 개념

| 키워드                  | 설명                                                  |
| ----------------------- | ----------------------------------------------------- |
| 비밀키 직접 사용        | 서버에서 배포나 자동화 때만! 사용자 키는 절대 사용 ❌ |
| 메타마스크의 역할       | 지갑 + 비밀키 보관 + 서명 대행 + UI 연결              |
| 서명 책임               | 사용자가 직접 승인해야만 서명됨                       |
| send vs sendTransaction | 메타마스크가 있는 환경에서는 `send()`만으로 충분      |

---

## 마지막으로

> 여러분이 지금 만든 건 단순한 버튼 몇 개짜리 웹페이지가 아닙니다.  
> 사용자의 지갑과 직접 연결된 **실제 블록체인과 상호작용하는 프론트엔드**입니다.
