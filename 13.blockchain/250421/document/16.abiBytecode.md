# 자, 어지러우니까 오늘 배운 거 정리해보겠습니다!

우리가 오늘 실제로 한 건 이거예요:

1. `Counter`라는 스마트컨트랙트를 만들었고
2. 그걸 **solc로 컴파일**해서 **바이트코드와 ABI**를 얻었고
3. `web3.js`를 통해 **Ganache 노드에 배포**했어요
4. 그리고 버튼을 누르거나 코드를 실행해서 **increment()** 함수도 호출해볼거임!

그런데… 이 모든 과정에서  
진짜 중요한 질문이 하나 남아 있어요:

> "내가 작성한 이 코드가,  
> **EVM에서는 도대체 어떻게 실행되고 있는 걸까?**"

이걸 제대로 이해하면  
이더리움이 어떻게 돌아가는지, 왜 ‘가상 머신’이라고 부르는지,  
스마트컨트랙트가 **어디에서 어떻게 살아 있는지** 완전히 꿰뚫을 수 있어요.

그럼 지금부터  
**EVM의 내부 동작 원리**를  
**우리가 만든 `Counter` 컨트랙트의 흐름을 따라가며**  
끝까지 정리해보겠습니다.

## 전제: Counter 컨트랙트

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Counter {
    uint public count = 0;

    function increment() public {
        count += 1;
    }
}
```

이걸 우리가 `solc`로 컴파일하고,  
Bytecode와 ABI를 얻은 뒤, 배포했다고 가정하자.

---

## 1. 배포 – 바이트코드가 블록체인에 올라감

### `solc`가 컴파일하면 바이트코드가 생성됨

예: `608060405234801561001057600080fd5b...` ← 이게 바이트코드

이 코드를 `web3.eth.sendTransaction({ data: 바이트코드 })`로 보내면,  
EVM은 이걸 읽고 스마트컨트랙트를 배포함.

---

## EVM이 여기서 하는 일:

- 이 바이트코드는 **스마트컨트랙트 생성 코드 + 실제 코드**로 구성돼 있음
- **생성 코드**는 실행 후, 최종적으로 EVM에 남겨질 코드만 반환함
- EVM은 이 반환값을 **해당 주소의 코드 공간에 저장함**

→ 이게 바로 **“배포된 컨트랙트의 코드”**가 되는 거야

---

## 2. 사용 – 프론트엔드가 함수 호출함

예: `contract.methods.increment().send({ from: 주소 })`

이때 Web3.js는 ABI를 참고해서 **함수 호출에 맞는 바이트 입력값(data)**을 만듦

- 예: `0xd09de08a` ← `increment()` 함수에 해당하는 **function selector**

## 3. 트랜잭션 발생 → EVM이 실행 시작

이제 `increment()`를 호출하는 트랜잭션이 발생했어.  
EVM은 다음과 같이 동작함:

## EVM 내부 실행 흐름

### 1. 상태 복원

- EVM은 해당 컨트랙트 주소의 **스토리지 슬롯**을 불러옴
- `count`는 슬롯 `0`에 저장되어 있음  
  (Solidity에서 맨 첫 번째 상태변수는 `slot 0`)

### 2. 바이트코드 해석

- 저장된 바이트코드를 **한 줄씩 해석**
- EVM은 **스택 기반 가상머신**  
  → 명령어는 전부 stack 위에서 push/pop 하며 실행됨

→ 예를 들면 `PUSH1 0x01`, `ADD`, `SSTORE` 이런 식의 명령어들을 실행함

### 3. `count += 1` 로직 수행

- `SLOAD`로 `slot 0`에 있는 값을 가져옴
- `PUSH1 0x01`으로 1을 올림
- `ADD`로 둘을 더함
- `SSTORE`로 다시 `slot 0`에 저장함

즉, **상태를 직접 조작**하는 명령어들이 실행되는 거야

## 4. 결과 저장

- 실행이 끝나면, 바뀐 `slot 0` 값이 **새로운 상태로 블록체인에 기록됨**
- 이건 **불변성(inmutability)**에 따라  
  과거 상태는 유지되고, 새로운 상태로 덮어써짐

---

1. solc 컴파일
   → 생성 코드(Contract Creation Code) + 최종 코드(Runtime Bytecode) 생성

2. 배포 트랜잭션 발생
   → data 필드에 생성 코드 포함됨

3. EVM은 생성 코드를 실행
   → 생성 코드가 반환하는 최종 코드(runtime bytecode)를 컨트랙트 주소에 저장

4. 사용자 함수 호출
   → ABI 기반 입력값(data) 생성 → 트랜잭션 발송

5. EVM이 해당 주소의 최종 코드(runtime bytecode)를 실행
   → 입력값 해석 → 함수 찾기 → 스택 기반 명령어 실행

6. 상태 변경 (SLOAD, SSTORE 등으로 storage 수정)

7. 변경 결과는 블록체인에 저장 (상태 변경 완료)

---

# 📌 마지막 요약 한 줄

> **EVM은 바이트코드를 "스택 머신" 방식으로 실행하며,  
> 상태(state)는 슬롯 단위로 관리되고,  
> 호출은 ABI 기준으로 생성된 입력값(data)을 통해 처리된다.**
