# 전체 흐름은 아래처럼 잡아보자:

## 1. **지난 흐름 되짚기 – 비트코인 네트워크 복기**

우리는 이미 지난 수업에서 **비트코인 구조**를 구현했어요.  
P2P 구조로 노드 간 메시지를 주고받고, 트랜잭션을 모아서 블록을 만들고,  
그 블록을 채굴하고 전파하는 시스템까지 완성했죠.

즉, 우리는 이걸 직접 구현한 셈입니다:

- 지갑 → 트랜잭션 생성 → 블록 → 채굴 → 브로드캐스트 → 검증 → 체인에 반영

근데 이건 철저히 **"거래(트랜잭션)" 중심의 네트워크**예요.  
즉, **잔액 변화**, **전송 기록**, **거래의 유효성** 같은 것들이 핵심이었죠.

## 2. **그럼 우리는 지금 어디쯤 왔을까?**

지금까지 구현한 건 철저히 **비트코인 스타일의 시스템**이에요.  
하지만 이제는 여기서 **한 단계 더 나아가야** 합니다.

단순히 거래 기록을 저장하는 데 그치지 않고,  
이제는 그 위에서 **“계약을 실행하는 플랫폼”**을 만들어야 해요.

> 그게 바로 **이더리움(Ethereum)**이죠.

## 3. 그런데… 이더리움을 이해하려면, 네트워크를 빼놓을 수 없습니다.

Ethereum도 결국 우리가 쓰는 인터넷 위에서 작동하는 시스템이에요.  
즉, **TCP/IP**, **OSI 7계층** 위에 올라가는 구조죠.

하지만 주의할 점이 있어요.

> Ethereum은 **기존의 '웹 통신 방식'과는 완전히 다른 구조**로 통신해요.

우리가 흔히 아는 웹은 이렇게 동작하죠:

- 브라우저가 요청을 보내고 (Client)
- 서버가 응답을 주는 구조 (Server)
- 이걸 HTTP, HTTPS 같은 프로토콜이 규정해요

📌 이건 **클라이언트 / 서버 구조**예요.

반면 Ethereum은 **서버 없이 모든 노드가 동등하게 연결**되어 있어요.

- 누구든 데이터를 보낼 수 있고
- 누구든 받아서 검증할 수 있어요
- 요청이 아닌 **브로드캐스트 방식**

📌 이건 **P2P 구조**입니다.

정리하면:

> Ethereum은 우리가 아는 인터넷(OSI 7계층) 위에서 돌아가지만,  
> 기존 웹의 통신 방식과는 **철학이 다른 구조(P2P)**를 구현하고 있어요.

그래서 지금 이 시점에서, 우리는 **네트워크란 무엇인가**부터 차근차근 다시 짚고 넘어갈 필요가 있습니다.

> 우리는 보통 인터넷 = 웹 = HTTP라고 생각하죠?  
> 그런데 비트코인은 HTTP를 쓰지 않아요.  
> 대신, 컴퓨터끼리 서로 직접 연결되어 정보를 주고받는 **P2P 구조**를 써요.  
> 이 구조는 기존의 서버 중심 네트워크와 다르게,  
> **서버 없이 모든 노드가 평등하게 대화합니다.**

> 그리고 이 네트워크 위에 **디지털 화폐 전송, 합의, 블록 생성**이 얹혀 있는 구조.  
> 이 전체를 우리는 **"비트코인 네트워크"**라고 부릅니다.

# 1단계: "네트워크란 무엇인가?"

## 1. 웹의 세계부터 시작 — **클라이언트 / 서버 구조란?**

"우리가 브라우저에 주소를 치면, 누군가가 화면을 보내주죠?"

- 브라우저: **클라이언트**
- 화면을 보내주는 컴퓨터: **서버**
- 클라이언트는 요청(request), 서버는 응답(response)

이 구조를 우리는 **클라이언트 / 서버 구조**라고 부릅니다.

## 2. 웹은 어떻게 연결되는가? — **HTTP 프로토콜**

"서버랑 클라이언트가 대화하는 규칙, 그게 바로 HTTP입니다."

- HTTP: **HyperText Transfer Protocol**
- 화면 전체를 "텍스트"로 주고받는 규칙
- 주소 요청 → HTML, CSS, JS 파일 응답
- 즉, **웹사이트 화면을 '요청-응답' 방식으로 가져오는 통신 규칙**

📌 한 가지 더!

- **HTTP는 'Stateless'하며, 요청-응답 후 연결을 끊는 방식**이에요.  
  → 매 요청마다 TCP 연결을 새로 열고, 응답이 끝나면 닫습니다.  
  → 그래서 흔히 **“connectionless”**라고 표현되지만,  
   실제로는 **TCP 위에서 동작하는 연결 지향적 프로토콜**입니다.

## 3. 연결은 어떻게 만들어지는가? — **3-Way Handshake**

"실제로는 HTTP가 동작하기 전에, TCP가 먼저 연결을 만들어야 해요."

- TCP 연결은 이렇게 진행됩니다:

```plaintext
1. 클라이언트 → SYN
2. 서버 → SYN + ACK
3. 클라이언트 → ACK
```

📌 이 과정을 **3-Way Handshake**라고 부릅니다.  
📌 연결을 끊을 때는 4번의 메시지를 주고받는 **4-Way Handshake**도 있어요.

## 4. 그럼 비트코인도 HTTP를 쓰나?

**아니요. 비트코인은 HTTP를 사용하지 않아요.**

- 비트코인은 **P2P 네트워크** 구조로 돌아갑니다.
- 여기서 **모든 노드가 서로 직접 연결**돼요.
- 누군가에게 요청받기 전에, **내가 먼저 메시지를 보낼 수도 있어요.**

즉, **HTTP처럼 '누군가 요청하면 응답하는 구조'가 아니라**,  
**각 노드가 주체적으로 정보를 퍼뜨리는 구조**입니다.

📌 물론 각 노드는 **TCP 소켓을 열고 연결을 기다리는 역할도 하죠.**  
 그래서 **서버처럼 동작**하지만,  
 우리가 말하는 **중앙 서버는 없습니다.**

> 그래서 이 구조를 우리는 **탈중앙 네트워크 (P2P 구조)**라고 부릅니다.

## 기술적으로 보면:

| 기준           | HTTP (웹)                 | 비트코인 (P2P)                          |
| -------------- | ------------------------- | --------------------------------------- |
| 요청/응답 구조 | 있음 (Request → Response) | 없음 (수시로 Push 전파)                 |
| 서버 존재      | 명확한 중심 서버          | 없음 (노드끼리 직접 연결)               |
| 연결 방식      | Stateless (HTTP over TCP) | **항상 연결 유지** (TCP 소켓 상시 연결) |
| 메시지 흐름    | 요청 후 응답              | **정보를 직접 전파 (broadcast)**        |

## 5. 그래서 비트코인은 뭘 썼을까? — **P2P + TCP + 자체 프로토콜**

- **TCP 소켓**으로 양방향 연결을 항상 유지하고,
- **HTTP가 아닌 자체 메시지 규약**으로 통신합니다.
- 이 연결 구조를 기반으로:
  - 블록 전파
  - 트랜잭션 공유
  - 체인 동기화

> 이 모든 구조를 통틀어 우리는 **“비트코인 네트워크”**라고 부릅니다.

## 쉽게 말하면:

**누가 요청을 보내면 내가 받을 수 있고,  
내가 먼저 보내면 누군가가 받을 수 있는 구조예요.**

이걸 우리는 **P2P 통신 네트워크**라고 부릅니다.

여기서는 **나도 서버가 될 수 있고**, **나도 클라이언트가 될 수 있어요.**

- 어떤 노드는 트랜잭션을 만들어서 보내고,
- 어떤 노드는 그걸 받아서 검증하고,
- 또 어떤 노드는 블록을 만들어서 전파해요.

그러니까,

> **"내가 클라이언트이자 데이터베이스가 될 수 있다."**

그리고 그 **데이터베이스 안에는 블록이 들어 있어요.**  
그걸 내가 직접 **검증하고, 만들고, 전파**합니다.

> **그게 바로 비트코인입니다.**

---

웹은 **정보를 요청해서 보는 구조**,  
비트코인은 **정보를 같이 만들고, 공유하는 구조**입니다.

그래서 이 구조를 우리는

> **"비트코인 네트워크"**, 또는 **"탈중앙 P2P 네트워크"**라고 부릅니다.

# 2단계: **비트코인 네트워크는 무엇을 해결했는가?**

### 1. 신뢰란 무엇인가?

> 우리가 일상에서 ‘신뢰’라는 말을 쓸 때는,  
> **"저 사람을 믿을 수 있을까?"**  
> **"그 은행은 내 돈을 잘 보관할까?"**  
> 이런 **'사람'이나 '기관'을 기준으로 판단**하죠.

그런데 컴퓨터 네트워크에서는 이런 신뢰가 문제예요:

- 이 사람이 누군지 모르고
- 어디에 있는지도 모르고
- 얼굴도 본 적 없는 상대에게 **디지털 자산**을 보내야 해요

### 2. 그래서 비트코인은 ‘신뢰 없는 시스템’을 만들려 했다

> 여기서 말하는 “신뢰 없음”은 **사람을 안 믿는다는 뜻이 아니에요.**  
> **사람이 아니라, ‘시스템(수학과 코드)’을 믿자는 거예요.**

📌 **즉, 신뢰를 강요하지 않아도 되는 구조**  
📌 **사람 대신 수학과 코드가 기준이 되는 구조**

> 그래서 우리는 비트코인을  
> **“신뢰가 필요 없는 환경” = Trustless System**  
> 이라고 부릅니다.

### 3. 그럼 이건 누가 만들었을까?

2008년, 세계 금융위기 직후  
어떤 사람(혹은 집단)이 다음과 같은 선언을 했어요:

> > "은행도 정부도 믿지 마라.  
> > 우리끼리 돈을 직접 주고받자.  
> > 다만, 그 시스템은 사람 대신 수학이 보장해줄 것이다."

이 선언을 한 사람이 바로 **사토시 나카모토**  
그리고 그가 설계한 시스템이 바로 **비트코인 네트워크**

### 4. 비트코인이 사용한 도구들

> 이 신뢰 없는 디지털 자산 시스템을 가능하게 만든 핵심 기술들은 다음과 같아요:

- **분산 네트워크**: 누구도 중앙이 아님
- **블록체인**: 데이터를 묶어서 체인으로 저장
- **작업 증명(PoW)**: 다수가 동의한 결과만 인정
- **공개키 암호학**: 나를 증명하는 수단
- **P2P 통신**: 모든 노드가 서로 직접 연결

📌 이 구조 덕분에 우리는 **중앙 기관 없이도 디지털 자산의 이동 기록을 무결하게 저장**할 수 있게 되었고,  
📌 이를 통해 **비트코인이라는 단일한 암호화폐가 '화폐처럼' 기능할 수 있는 기반이 마련된 것**입니다.

# 3단계: **비트코인의 한계는 무엇인가?**

## 1. “비트코인을 어디까지 활용할 수 있을까?”

> 비트코인은 디지털 화폐 전송과 그 기록을 위한 시스템이에요.  
> 다시 말해, **비트코인이라는 단일한 화폐의 이동과 그 이력을 블록체인에 남기는 것**,  
> 이게 본래의 역할입니다.

그런데 질문 하나 해볼게요:

- **다중 서명 지갑 같은 구조를 만들 수 있을까?**
- **조건에 따라 자동으로 화폐가 움직이게 할 수 있을까?**
- **투표 시스템, 게임 아이템, 보험 계약 같은 앱도 표현 가능할까?**

📌 결론부터 말하면,  
**비트코인 네트워크는 이런 기능적 활용에는 매우 제한적**입니다.  
가능은 하지만,

- 직접 스크립트를 짜야 하고
- 상태를 저장할 수 없고
- 조건이 매우 제한적이에요.

## 2. 비트코인의 스크립트 언어의 한계

> 비트코인에는 `Script`라는 아주 단순하고 제한적인 언어가 있어요.  
> 이 언어는 오직 **조건부 송금** 정도만 허용되도록 설계되었습니다.

- 반복문 없음 (루프 X)
- 상태 저장 불가 (변수 X, DB X)
- 분기 구조 약함 (조건문도 제한적)
- 디버깅도 힘들고, 재사용성 없음

📌 예: 다중 서명 지갑을 만들고 싶다면  
→ `OP_CHECKMULTISIG` 같은 연산자들을 직접 조합해서 써야 해요  
→ 실수도 많고, 유지보수도 어렵고, 확장도 거의 불가능합니다.

## 3. 이로 인해 생긴 흐름들

> 기능을 더 만들고 싶었던 사람들은  
> **비트코인을 포크하거나, 비트코인 위에 얹히는 방식으로 확장하려고 했어요.**

예를 들어:

- **Namecoin**: DNS(도메인 이름)을 블록체인에 저장해보자
- **Colored Coin**: 특정 비트코인에 의미를 부여해서, 일종의 토큰처럼 활용
- **Mastercoin**: 비트코인 위에서 스마트 계약 비슷한 기능 실험

📌 이들은 새로운 코인을 만든다기보다는,  
**“비트코인을 더 다양한 목적으로 활용해보려는 시도”**였어요.

## 4. 핵심은 이거예요

> **비트코인은 ‘화폐의 전송과 기록’이라는 목적에 최적화된 시스템입니다.**  
> 하지만 **그 외의 기능을 표현하기엔 너무 불편하고 제약이 많았어요.**

이걸 비유하자면:

> **비트코인은 계산만 가능한 계산기 같아요.**  
> 그런데 사람들은 스마트폰처럼 앱을 올릴 수 있는 플랫폼을 원한 거죠.
>
> 그런데 비트코인 위에 앱 하나 올리고 싶으면…  
> 계산기를 분해해서 다시 조립해야 할 수준이었어요.

## 그래서 등장한 것이 “이더리움”

> 이런 한계를 보고,  
> **비탈릭 부테린은 한 가지 문제의식을 품었습니다.**

> > “왜 기능 하나 만들고 싶을 때마다 시스템 전체를 다시 짜야 하지?”  
> > “이걸 코드 몇 줄로 쉽게 만들 수 있는 하나의 플랫폼이 있다면 어떨까?”

이 질문에서 출발한 게 바로  
→ **이더리움(Ethereum)**입니다.

# 4단계: **비탈릭의 문제의식** — 플랫폼이라는 발상의 전환

## 1. 비탈릭 부테린의 질문

> 비탈릭은 여기서 아주 단순하지만 중요한 질문을 던집니다.

> “**왜 기능 하나 추가하려면, 매번 구조 전체를 새로 짜야 하지?**”  
> “**왜 코인을 계속 만들지? 그냥 기능을 코드로 표현하면 안 되는 걸까?**”

그는 생각했어요:

> 👉 "**모든 기능을 하나의 플랫폼 안에서, 누구나 코드를 통해 만들 수 있다면 어떨까?**"

이건 단순한 기능 확장이 아니라,  
**블록체인을 하나의 실행 환경으로 바라보는 발상의 전환**이었어요.

## 2. 그래서 ‘플랫폼’이라는 발상으로 이동

비탈릭은 새 코인을 만들고 싶었던 게 아닙니다.  
그는 **누구나 자유롭게 기능을 만들고 실행할 수 있는 공간**,  
즉 **블록체인 기반의 '앱 플랫폼'**을 만들고자 했습니다.

📌 그 플랫폼은 다음과 같은 조건을 만족해야 했습니다:

- 사용자가 원하는 기능을 직접 **코드로 작성**할 수 있어야 하고
- 그 코드는 누구나 확인 가능하고,
- **중앙 없이**, 신뢰 없이도 실행되며
- 그 결과는 **변조 불가능하게 블록체인에 기록**되어야 합니다

이건 마치 이런 질문이기도 했습니다:

> “블록체인 위에서 실행되는 **앱스토어**가 가능하지 않을까?”

## 3. 그 생각이 이더리움의 시작이 되었다

> “이더리움은 비트코인의 대체물이 아니다.”
>
> “이더리움은 **비트코인의 철학을 계승하면서**,  
> 블록체인을 **범용 컴퓨터처럼 사용할 수 있도록 재설계한 플랫폼**이다.”

비트코인은 “**디지털 화폐 전송을 위한 신뢰 없는 시스템**”이었다면,  
이더리움은 “**디지털 계약과 앱을 실행하는 신뢰 없는 플랫폼**”이었습니다.

# 5단계: **그래서 이더리움은 무엇인가?**

— 기능을 품은 블록체인 플랫폼

## 1. **이더리움은 “기능을 실행할 수 있는 플랫폼”이다**

> 비탈릭 부테린은 "코인을 계속 만들지 말고, **기능을 코드로 표현하자**"는 문제의식에서 출발했습니다.

비트코인은 단일한 기능(화폐 전송)에 최적화된 시스템이었어요.  
하지만 비탈릭은 여기에 질문을 던졌죠.

> “왜 기능 하나 만들 때마다 네트워크를 새로 설계해야 하지?”  
> “그 기능을 코드로 만들고, 누구나 그걸 실행할 수 있다면 어떨까?”

그래서 탄생한 것이 바로 **Ethereum**,  
즉 **사용자가 직접 만든 기능을 블록체인 위에서 실행할 수 있는 플랫폼**입니다.

## 2. 그럼, 이 기능은 어디에서 실행되는 걸까?

> Ethereum은 단순히 “기능을 짜자”로 끝나지 않았어요.  
> 중요한 건, **그 기능을 네트워크 상에서 모두가 똑같이 실행하고, 검증하고, 기록해야 한다는 것**이죠.

그럼 어떻게 가능할까요?

> 정답은,  
> **“하나의 가상 머신(EVM) 위에서 똑같은 코드를 실행시키는 방식”**입니다.

## 3. EVM — Ethereum Virtual Machine

Ethereum은 네트워크 안에 **모두에게 동일하게 동작하는 ‘가상 CPU’**,  
즉 **EVM (Ethereum Virtual Machine)**을 만들어 넣었습니다.

- 이더리움의 모든 노드는 이 EVM을 보유하고 있어요.
- 그리고 사용자가 작성한 코드를 이 EVM 안에 넣고 실행시킵니다.
- 그렇게 하면 **어느 노드에서 실행하든, 항상 같은 결과**가 나오게 되죠.

📌 이것이 Ethereum이 **“전 세계에 설치된 하나의 컴퓨터처럼 작동한다”**고 표현되는 이유입니다.

## 4. 그럼, 이 EVM에 코드를 어떻게 넣을 수 있을까?

> 바로 여기에서 등장하는 게 **Solidity**입니다.

Solidity는 **EVM이 이해할 수 있는 코드(바이트코드)**를 만들기 위한 고급 언어입니다.  
즉, 사람은 Solidity로 작성하고,  
컴퓨터(EVM)는 이를 컴파일해서 바이트코드로 받아 실행합니다.

## 5. Solidity는 어떤 언어일까?

Solidity는 다음과 같은 특징을 갖습니다:

- 변수 선언
- 조건문, 반복문
- 상태 저장 (`state variable`)
- 함수, 이벤트
- 스마트 컨트랙트 단위의 모듈화

즉, 일반적인 프로그래밍 언어와 비슷하지만,  
**블록체인 위에서 실행된다는 점에서 결정적인 차이**가 있습니다.

### Solidity 예제:

```solidity
contract Counter {
    uint256 public count = 0;

    function increment() public {
        count += 1;
    }
}
```

📍 이 컨트랙트는 단순한 기능을 갖지만,  
**이 기능이 실행될 때 발생하는 상태 변화가 전 세계 노드에 의해 검증되고, 그 결과가 블록체인에 기록된다는 점**입니다.

---

### **계정 기반 구조 – EOA와 CA**

이더리움은 **모든 상태를 Account 단위로 관리**합니다.  
그리고 계정은 두 종류로 나뉩니다:

| 계정 타입                          | 설명                                                                                            |
| ---------------------------------- | ----------------------------------------------------------------------------------------------- |
| **EOA** (Externally Owned Account) | 우리가 흔히 쓰는 지갑 주소. **개인키를 보유하며**, 직접 트랜잭션을 보낼 수 있음                 |
| **CA** (Contract Account)          | 스마트 컨트랙트가 배포된 주소. **트랜잭션을 받아야만 작동**, 스스로는 트랜잭션을 시작할 수 없음 |

📌 이더리움 내부적으로는 이런 구조로 상태를 관리합니다:

```ts
interface Account {
  nonce: number; // 트랜잭션 카운터
  balance: string; // 이더 잔액
  storageRoot: string; // 상태 변수 저장 구조
  codeHash: string; // 배포된 스마트 컨트랙트 코드의 해시
}
```

# 6. Solidity를 배울 때 필요한 관점

이제부터 우리는 **Solidity 언어**로  
**스마트 컨트랙트(Contract)**를 작성하게 됩니다.

---

### 1. **계약이라는 개념에 익숙해져야 합니다**

앞으로 우리는 수없이 **‘계약(Contract)’**이라는 단어를 마주치게 될 거예요.  
이 단어는 법률에서도 쓰이고, 우리가 살면서 자주 접하는 개념이죠.  
현실 세계에서 계약은 **"서로가 지켜야 할 약속"**입니다.

근데 블록체인에서 이 계약은 조금 다르게 작동합니다.

> 현실의 계약은 사람이 지키는 약속이라면,  
> **블록체인의 계약은 기계가 실행하는 약속**입니다.

---

우리가 Solidity로 작성하는 코드는  
**조건을 코드로 표현하고**,  
**그 결과를 네트워크에 기록하고**,  
**누구나 동일한 방식으로 실행 가능한 약속**입니다.

> 결국, **계약이란?**  
> **조건을 코드로 명시하고, 실행 결과를 블록체인에 남기는 자동화된 약속**입니다.

---

이제 우리가 스마트 컨트랙트를 작성했으니,  
이걸 실제 네트워크에서 '실행 가능한 형태'로 만들어야겠죠.

> 바로, 이 계약을 **블록체인에 올리는 것**,  
> 즉 **배포(Deploy)**입니다.

---

### 그런데 “블록체인에 올린다”는 게 무슨 뜻일까요?

이 말이 좀 추상적으로 들릴 수 있어요.  
그래서 우리는 앞으로 **세폴리아(Sepolia)**라는 네트워크를 사용할 겁니다.

이건 **이더리움의 테스트용 퍼블릭 네트워크**예요.  
하지만 중요한 건, 이게 단순히 테스트가 아니라는 거예요.

- 진짜 트랜잭션이 발생하고,
- EVM이 돌아가고,
- 우리가 작성한 코드가 **실제 주소로 배포**되며,
- 그 결과는 **Etherscan**에서 확인할 수 있습니다.

---

> 어렵게 느껴질 수도 있어요.  
> 하지만 핵심은 간단합니다.

우리가 작성한 Solidity 코드는  
**세폴리아 네트워크라는 퍼블릭 블록체인에 올라갈 수 있고**,  
**전 세계 어디서든 누구나 실행할 수 있게 됩니다.**

이걸 우리는 **“배포한다”**고 부릅니다.

---

이제부터 우리가 작성하는 **`contract`**는  
그저 로컬에서 돌려보는 테스트 코드가 아닙니다.  
**공적인 네트워크에 기록되고, 호출되고, 추적되는 진짜 약속**이에요.

그래서 Solidity를 배울 땐  
단순히 문법이 아니라  
**계약의 관점, 네트워크 위의 실행 관점,  
그리고 자동화된 신뢰의 관점**을 함께 가져가야 합니다.

# 질문! "그럼 Solidity가 곧 스마트 컨트랙트인가요?"

## 아닙니다!

Solidity는 **스마트 컨트랙트를 작성하기 위한 언어**일 뿐입니다.  
우리가 글을 쓸 때 **한글을 쓴다고 해서 그게 계약서가 되는 건 아니잖아요?**

---

스마트 컨트랙트란 건 **'약속을 명시한 코드'가 네트워크 위에서 다음을 만족할 때**입니다:

1. **EVM 위에서 실행되고**,
2. **모든 노드가 그 실행을 검증하고**,
3. **결과가 블록체인에 기록되며**,
4. **누구나 접근 가능하고, 되돌릴 수 없는 형태**로 존재할 때.

그제서야 우리는 **이 코드를 "스마트 컨트랙트"라고 부를 수 있는** 거예요.

## 다시 정리하면

- **Solidity로 작성된 코드**는 그 자체로는 단순한 소스코드입니다.
- 그 코드가 **EVM에 배포되고**,
- 네트워크 상에서 **자동 실행 가능한 형태로 존재할 때**,
- 우리는 그걸 **"스마트 컨트랙트"라고 부릅니다.**

# 자 이렇게 쭈욱 설명을 했는데요.

아직 무슨 소리인지 잘 모르겠죠?  
이해가 됩니다.

그래서 말보다는, 이제 직접 코드를 보면서 이해해보는 시간을 가질 거예요.

---

이제 질문 하나 던져볼게요:

> “그럼 우리가 짜는 코드도, 저 EVM 위에서 실행되는 걸까?”

맞습니다.  
우리가 작성할 코드—이제부터 만들어볼 **작은 컨트랙트 하나**도  
바로 저 가상 머신(EVM) 위에서 **실제로 실행**됩니다.

---

그래서 이제부터 **우리는 이더리움 스마트 컨트랙트를 직접 짜보고, 실행해볼 겁니다.**

그 실습의 주제는…  
아마 이름을 들으면 웃을 수도 있어요.

우리가 만들 건 바로...

> **카운터**입니다.  
> (네, 그거 맞아요. 숫자 하나씩 올라가는 그거요.)

---

근데 이번엔 다릅니다.

단순히 변수 하나를 증가시키는 코드가 아니에요.  
**이건 스마트 컨트랙트로 작성된 코드고,**  
**EVM 위에서 실행되고, 실행 결과가 블록체인에 기록되는 실험**입니다.

---

정확히 어떤 흐름이냐면…

- 우리가 Solidity로 `+1` 기능이 담긴 컨트랙트를 작성하고,
- 이 코드를 **EVM이 이해할 수 있는 바이트코드로 컴파일**한 뒤,
- **Ganache**라는 로컬 테스트 블록체인 환경에 배포합니다.
- 그런 다음 우리는 **직접 만든 컨트랙트를 호출하고**,
- **실제로 값이 변하는 과정을 눈으로 확인**하게 될 거예요.

---

> 즉, 오늘 우리가 만들 이 "카운터"는  
> 단순한 실습 예제가 아니라,  
> **진짜 블록체인에서 실행되는 하나의 계약(Contract)**입니다.  
> 다만 오늘은 **우리 컴퓨터 안에서 돌아가는 가상의 블록체인(Ganache)**에서 실험해보는 거예요.

---

자, 그럼 이제 그 실습을 위한 폴더부터 만들어봅시다.

```bash
250421
```

그리고 그 안에 제일 먼저 구성할 디렉토리는 바로 이거예요:

```bash
250421/
└── contracts/
    ├── Counter.sol
```

이 폴더 안에는 우리가 짤 스마트 컨트랙트 코드와,  
그걸 EVM이 이해할 수 있는 형태로 변환해주는 컴파일러가 들어가게 될 거예요.

- `Counter.sol` – 우리가 작성할 스마트 컨트랙트
- `compile.js` – 이 컨트랙트를 ABI와 Bytecode로 변환하는 코드
  좋아.  
  지금 요청한 방향은 단순히 `Counter.sol`을 "어떻게" 작성하느냐가 아니라,  
  **"왜 Solidity라는 새로운 언어를 배워야 하며, 어떤 철학과 배경 위에서 이 언어를 바라봐야 하는가"**  
  즉, **도구를 배우기 전에 세계관부터 정립시키는 것**이 핵심이야.

---

## Counter.sol

지금부터 우리는 스마트 컨트랙트를 직접 작성해볼 겁니다.  
그리고 그 첫걸음은 이 파일 하나에서 시작됩니다:

```bash
250421/
└── contracts/
    ├── Counter.sol
```

이름은 익숙하죠?  
네, 바로 그 카운터입니다. +1 올리는 카운터.  
근데 이번엔 그냥 버튼 누르면 숫자 올라가는 카운터가 아니라,  
**진짜 퍼블릭 블록체인에 올라가는 계약 코드로 작성된 카운터**입니다.

---

### 그런데 말이죠…

우리가 지금까지 코드를 짤 땐 거의 다 **JavaScript**나 **TypeScript**였어요.  
그런데 갑자기 `Counter.sol`이란 확장자의 **Solidity**라는 언어가 등장합니다.

이쯤에서 질문 하나 던져봅니다.

> "왜 자바스크립트로 안 짜고,  
> 굳이 새 언어를 또 배워야 하죠?"

---

Solidity는 **Ethereum 전용 스마트 컨트랙트 언어**입니다.  
이 언어로 작성된 코드는 결국 EVM 위에서 opcode로 변환되어 실행돼요.  
하지만 그냥 그렇게 설명하면 이 언어가 "대체재"처럼 느껴지기 쉬워요.  
절대 그렇지 않습니다.

```solidity
pragma solidity ^0.8.0;

contract Counter {

}
```

이게 우리가 작성할 컨트랙트의 기본 뼈대입니다.  
하나씩 해석해볼게요.

---

#### ✅ `pragma solidity ^0.8.0;`

이건 약속이에요.

> "나는 Solidity 0.8.0 버전 이상에서 이 코드를 사용할 거예요"  
> "그 이하 버전에서는 동작을 보장하지 않아요"

실제 블록체인은 오랜 시간 유지되기 때문에  
**명확한 버전 명시**는 필수입니다.  
Solidity는 하위 호환이 완벽하지 않기 때문에,  
**컨트랙트마다 사용하는 컴파일러 버전을 꼭 적어야 해요.**

---

#### ✅ `contract Counter {}`

이게 바로 우리가 만드는 "계약"입니다.  
자바스크립트에서 `class`와 비슷한 구조이지만,  
역할은 완전히 다릅니다.

이건 단순한 틀이 아니라:

- 하나의 독립적인 주소를 갖게 되고
- 상태(state)를 저장할 수 있고
- 여러 사람이 접근 가능한 "공공 계약"이 됩니다

즉, **이 코드를 배포하면 세상 어딘가에 하나의 주소가 생기고,  
그 주소는 독립적인 ‘계약 공간’이 되는 거예요.**

---

### 2. **실행이 아니라 기록이다**

우리가 이제부터 작성할 이 컨트랙트는, 단순히 눈앞에서 숫자를 올리고 끝나는 코드가 아닙니다.  
이건 **전 세계 노드가 실행하고, 그 결과를 블록에 새기는 계약입니다.**

Solidity에서는 함수를 실행하는 순간,

> **그 행위는 기록이 됩니다.**

- 저장소가 바뀌고,
- 트랜잭션이 만들어지고,
- 가스(Gas) 비용이 발생하고,
- 모든 노드가 같은 결과를 검증하고,
- 그 결과가 블록에 남습니다.

즉, **실행은 곧 영구 기록**입니다.  
한 번 실행되면 절대 되돌릴 수 없어요.  
이게 Solidity의 본질이에요.

---

그럼 이제 우리가 만들 `Counter` 컨트랙트에 기능을 조금 추가해봅시다.  
단순히 `count`라는 숫자를 1씩 증가시키는 기능이에요.

```solidity
contract Counter {
    uint public count = 0;

    constructor() {
        count = 0;
    }

    function increment() public {
        count += 1;
    }

    function getCount() public view returns (uint256) {
        return count;
    }
}
```

이제부터 각 구성 요소를 차근차근 뜯어봅시다.

---

#### ✅ `uint public count = 0;`

- `uint`는 **양의 정수형 변수**를 선언하는 타입입니다.  
  (`uint256`과 동일하며, 기본 정수는 모두 양수예요)
- `public`은 **이 변수를 외부에서도 조회 가능하게 만든다는 의미**입니다.
  즉, 이 컨트랙트가 배포되면 Etherscan에서도 이 변수 값이 자동으로 보이게 됩니다.
- `= 0`은 **초기값 선언**입니다.

👉 이건 결국, **컨트랙트의 상태(state)**입니다.  
**지금 이 계약이 어떤 값을 보유하고 있는지를 보여주는 공간**이에요.  
이건 단순한 변수 선언이 아니라,  
**블록체인에 저장되는 값**이고,  
**누구나 조회할 수 있는 퍼블릭 상태**입니다.

---

#### ✅ `constructor() { count = 0; }`

- 생성자 함수입니다.
- 이 컨트랙트가 배포될 때 **딱 한 번만 실행되는 특별한 함수**예요.
- 여기서는 그냥 count를 0으로 초기화하고 있지만,  
  나중엔 배포자 주소를 저장하거나, 초기 상태를 세팅하는 데에 자주 사용됩니다.
- 참고로 생성자 함수는 생략해도 됩니다.  
  여기선 학습 목적으로 `count = 0` 초기화를 보여주기 위해 명시했어요.

---

#### ✅ `function increment() public { count += 1; }`

- 누구나 이 함수를 호출할 수 있습니다.
- `count += 1`이라는 이 단순한 연산…  
  사실 이건 자바스크립트에서라면 `count++`만큼 가볍죠?

하지만 Solidity에선 이 한 줄이 **하나의 트랜잭션**을 만듭니다.

→ 이더를 조금 소모하고 (가스),  
→ 블록체인에 기록되고,  
→ 여러 노드가 이 연산을 똑같이 수행한 뒤,  
→ **그 결과를 영원히 남깁니다.**

그래서 우리가 이걸 "실행"했다기보다는,

> **"요청했고, 기록됐다"**라고 표현하는 게 더 정확해요.

---

#### ✅ `function getCount() public view returns (uint256)`

- `view` 함수는 상태를 **조회**만 하고 **변경하지 않는 함수**입니다.
- 즉, 블록체인을 건드리지 않고 값을 확인만 하므로 **가스가 들지 않아요.**
- `returns (uint256)`는 `count` 값을 그대로 되돌려주는 함수 시그니처입니다.

→ 이건 말 그대로 **“현재 계약의 상태를 확인해보는 용도”**입니다.

# 3. **컴파일**

자, 우리가 Solidity로 스마트 컨트랙트를 작성했어요.  
그럼 바로 실행할 수 있을까요?

> 아니요. **우리는 아직 실행 준비조차 안 된 상태입니다.**

Solidity로 작성된 코드는 사람이 읽기 쉬운 고급 언어입니다.  
하지만 EVM은 이걸 바로 이해할 수 없습니다.

## 그럼 어떻게 해야 할까요?

먼저 **컴파일(Compile)**을 해야 합니다.  
**Solidity 코드를 → EVM이 이해할 수 있는 언어로 번역**해야 해요.

즉, 우리가 작성한 `Counter.sol` 파일을  
→ 기계가 이해할 수 있는 두 가지 결과물로 변환해야 해요:

---

### 컴파일 결과물

1. **ABI (Application Binary Interface)**

   - 외부에서 이 컨트랙트를 **어떻게 사용할 수 있는지에 대한 설명서**
   - 함수 목록, 입력 타입, 출력 타입 등을 담고 있음

2. **Bytecode**

   - EVM이 실제로 **실행할 수 있는 코드 덩어리**
   - 블록체인에 올라갈 진짜 기계어 코드

---

### 이 두 가지가 있어야만…

- 세폴리아 네트워크에 배포할 수 있고
- 배포된 컨트랙트의 주소로 접근할 수 있고
- 다른 노드도 우리의 컨트랙트를 호출하거나 상호작용할 수 있어요

즉, **우리가 작성한 코드가 ‘세상과 연결되려면’ 컴파일이 필수**입니다.

## Contract Address? 그건 또 뭐예요?

우리가 컴파일한 Bytecode를 세폴리아 네트워크에 **배포(deploy)**하면  
네트워크는 그 컨트랙트에 **고유한 주소**를 부여합니다.

이 주소를 우리는 **Contract Address (CA)**라고 부릅니다.

→ 마치 “우리 집 주소”처럼,  
→ 블록체인 세계에 있는 이 컨트랙트를 호출하거나 데이터를 보내려면  
→ 이 주소가 반드시 필요합니다.

> 즉, 모든 실행은 **Contract Address를 통해** 시작됩니다.

---

### 그럼 컴파일 어떻게 해요?

이제 우리가 해야 할 일은 단 하나.

`Counter.sol`을 EVM이 이해할 수 있도록 컴파일하는 거예요.  
그리고 그걸 위해 **`compile.js`**라는 스크립트를 작성합니다.

---

```bash
250421/
├── contracts/
    ├── Counter.sol
    └── compile.js
```

이 파일을 실행하면 아래 두 개의 파일이 자동 생성됩니다:

- `contracts_sol_Counter.abi`
- `contracts_sol_Counter.bin`

---

### 실행 명령어:

```bash
node 250421/compile.js
```

실행 후엔 이 폴더 안에 이렇게 두 개의 결과물이 생기게 할겁니다!:

```bash
250421/
├── contracts/
    ├── Counter.sol
    ├── contracts_sol_Counter.abi
    ├── contracts_sol_Counter.bin
    └── compile.js
```

이제 우리는 이걸 가지고  
→ **Ganache 테스트 네트워크에 배포할 준비가 된** 상태입니다.

### 파일이 어딨는데요?

나한테 있음.  
근데 그냥 주지 않을 거임.  
하나하나 필요에 의해서 구현해볼거임!

# 최종 목표

```plaintext
Counter.sol → compile.js → ABI & Bytecode 생성
```

이게 오늘 우리가 만드는 흐름이야.

## 단계별 구현 흐름

---

### 1단계: `Counter.sol` 파일을 읽어야 한다

```js
const solc = require("solc");
const fs = require("fs");
const path = require("path");

// 컨트랙트 파일 경로 설정
const contractPath = path.join(__dirname, "Counter.sol");
const source = fs.readFileSync(contractPath, "utf8");
```

### 이 코드가 의미하는 것

- `solc`: Solidity 컴파일러 (Node.js에서 사용하는 모듈)
- `fs`: 파일을 읽기 위한 모듈
- `path`: 파일 경로를 안전하게 연결해주는 유틸

여기서 핵심은

> `"Counter.sol"` 파일을 **문자열로 읽어들이는 것**이야.  
> 이걸 나중에 컴파일러에게 넘겨줘야 하니까.

---

### 2단계: 컴파일 옵션 만들기

```js
const input = {
  language: "Solidity",
  sources: {
    "Counter.sol": {
      content: source,
    },
  },
  settings: {
    outputSelection: {
      "*": {
        "*": ["*"],
      },
    },
  },
};
```

### 이 코드는 뭐 하는 건데?

우리가 `solc.compile()` 함수에 넘겨줄 옵션이야.  
쉽게 말하면:

- `어떤 언어냐?` → Solidity
- `어떤 파일을 컴파일할거냐?` → Counter.sol
- `무슨 정보까지 뽑아올거냐?` → 전부 다 (`["*"]`)

---

### 3단계: 컴파일 실행 & 에러 확인

```js
const output = JSON.parse(solc.compile(JSON.stringify(input)));

if (output.errors) {
  console.error("컴파일 에러:", output.errors);
  process.exit(1);
}
```

### 여기서 꼭 알아야 할 것

- `compile()`은 JSON 문자열을 받고 JSON 문자열을 반환해.
- `output.errors`가 있으면 콘솔에 찍고 강제 종료해.

우리는 아직 코딩보다 **문제 생기면 빠르게 잡는 습관**이 더 중요해.

---

### 4단계: ABI와 Bytecode 추출

```js
const contract = output.contracts["Counter.sol"]["Counter"];
const abi = contract.abi;
const bytecode = contract.evm.bytecode.object;
```

### 드디어 핵심

- `contract` 객체는 우리가 작성한 `Counter` 컨트랙트의 전체 정보야
- `.abi` → 외부에서 함수 호출할 때 필요한 인터페이스
- `.bytecode` → 실제 EVM에서 실행될 코드

---

### 5단계: 결과 저장

```js
fs.writeFileSync(
  path.join(__dirname, "contracts_sol_Counter.abi"),
  JSON.stringify(abi, null, 2)
);
fs.writeFileSync(path.join(__dirname, "contracts_sol_Counter.bin"), bytecode);
```

### 이 줄 한 줄이 왜 중요하냐?

- 나중에 `deploy.js`에서 이 파일들을 불러와서 배포하게 돼.
- 즉, 이건 그냥 저장이 아니라 **배포의 준비 작업**이야.

---

### 6단계: 완료 메시지

```js
console.log("컴파일 완료!");
console.log("ABI와 Bytecode가 저장되었습니다.");
```

단순하지만 **중요한 감정적 마침표**야.  
내가 뭔가 하나 만들었다는 확신을 줄 수 있어.

---

## 정리: 우리가 지금까지 한 일

| 단계  | 설명                    |
| ----- | ----------------------- |
| 1단계 | Counter.sol 파일을 읽음 |
| 2단계 | 컴파일 입력 정의        |
| 3단계 | 컴파일 실행 & 에러 체크 |
| 4단계 | ABI & Bytecode 추출     |
| 5단계 | 결과 저장               |
| 6단계 | 완료 메시지 출력        |

---

## 다음 단계?

이제 우리는 `Counter.sol`이  
**EVM에서 실행 가능한 형태로 완전히 준비된 상태**야.

다음 단계는 바로...

> 이걸 **내 컴퓨터 속 이더리움 네트워크(Ganache)**에 **배포**하는 거야.

# 4단계: 내가 만든 코드 → 계약을 배포하기

---

지금까지 우리는 다음 작업을 했습니다:

- `Counter.sol`이라는 스마트 컨트랙트를 작성했고,
- `compile.js`를 통해 **ABI**와 **Bytecode**를 생성했어요.

이제 학생들이 종종 이렇게 착각할 수 있어요.

---

## 우리가 배포를 했었나…?

> 아니요. **컴파일은 배포가 아닙니다.**

---

### 🔍 컴파일은 무엇이었죠?

- Solidity 소스 코드를
- **EVM이 이해할 수 있는 기계어(Bytecode)**로 바꾸고,
- 외부에서 호출할 수 있는 인터페이스(ABI)를 생성한 거예요.

즉, 컴파일은 **준비 완료**의 상태일 뿐  
아직 **어디에도 올라간 건 없어요.**

---

## 그럼 배포는 무엇이냐?

> 진짜 네트워크 상에 **컨트랙트를 올리고**,  
> **Contract Address를 부여받는 것**입니다.

이제부터 우리가 직접 `deploy.js`를 만들어서,  
로컬 이더리움 네트워크인 **Ganache**에  
이 컨트랙트를 **배포(deploy)**해볼 거예요.

---

## 배포의 의미 다시 한번 요약

| 단계   | 설명                                           |
| ------ | ---------------------------------------------- |
| 컴파일 | 실행 가능한 코드(ABI, Bytecode)를 만들었다     |
| 배포   | 그 코드를 네트워크에 등록하고, 주소를 받아온다 |

---

### 우리의 목표

- `compile.js`에서 만든 ABI와 Bytecode를 불러와서
- Ganache 네트워크에 컨트랙트를 배포하고
- **컨트랙트 주소 (Contract Address)**를 받아오는 것

---

이제 진짜 **배포** 코드를 작성하러 갑시다.  
필요한 파일은 하나예요:

```bash
deploy.js
```

다음 단계에서 이걸 한 줄씩 만들면서  
**왜 필요한지, 어떤 순서로 실행되는지**  
차근차근 함께 정리해볼 거예요.

# 코드 흐름

---

```js
const { Web3 } = require("web3");
```

→ `web3` 라이브러리에서 `Web3` 클래스만 꺼내와요.  
→ 앞으로 이 객체로 블록체인과 소통합니다.

---

```js
const fs = require("fs");
const solc = require("solc");
const path = require("path");
```

- `fs`: 파일 읽고 쓰기 위해 필요
- `solc`: Solidity 코드를 EVM용 코드로 변환할 때 사용
- `path`: 경로 조작 시 플랫폼 상관없이 안전하게 처리

**컴파일과 파일 저장 준비 작업**

---

```js
const web3 = new Web3("http://127.0.0.1:8545");
```

→ `Ganache`와 연결합니다.  
→ 로컬 블록체인에 접속할 주소예요.  
지금은 퍼블릭 네트워크 말고 **우리 컴퓨터 속 이더리움**

## 컨트랙트 컴파일 파트

```js
const contractPath = path.join(__dirname, "/contracts/Counter.sol");
console.log(contractPath);
```

→ `Counter.sol` 파일의 전체 경로를 만들고 출력합니다.  
우리가 작성한 스마트 컨트랙트를 읽어올 준비

---

```js
const source = fs.readFileSync(contractPath, "utf8");
```

→ Solidity 원본 코드를 문자열 형태로 읽어옵니다.  
**"EVM한테 보여줄 코드 원본 확보 완료"**

---

```js
const input = {
  language: "Solidity",
  sources: {
    "Counter.sol": {
      content: source,
    },
  },
  settings: {
    outputSelection: {
      "*": {
        "*": ["*"],
      },
    },
  },
};
```

→ `solc.compile()`이 이해할 수 있는 JSON 구조로 컴파일 옵션을 설정합니다.  
→ 어떤 파일을 어떤 언어로 어떤 결과물까지 뽑을지 명시해주는 거예요.  
**"컴파일할게요!" 라고 정확히 말하는 준비**

---

```js
const output = JSON.parse(solc.compile(JSON.stringify(input)));
const contract = output.contracts["Counter.sol"]["Counter"];
```

→ JSON 형태로 결과를 받아서 다시 객체로 파싱합니다.  
→ 그중 우리가 원하는 컨트랙트(`Counter`)만 뽑아냅니다.  
컴파일 완료: 이 안에 `ABI`, `Bytecode`, `gasEstimate` 전부 들어있어요

---

## 결과물 저장 파트

```js
const abiPath = path.join(__dirname, "/contracts/contracts_sol_Counter.abi");
const bytecodePath = path.join(
  __dirname,
  "/contracts/contracts_sol_Counter.bin"
);
```

→ 컴파일 결과를 저장할 경로를 만듭니다.  
**"이제 ABI랑 Bytecode를 실제 파일로 따로 저장할 거예요"**

---

```js
fs.writeFileSync(abiPath, JSON.stringify(contract.abi));
fs.writeFileSync(bytecodePath, JSON.stringify(contract.evm.bytecode.object));
```

→ 각각의 정보를 JSON 문자열로 저장합니다.  
외부에서 이 컨트랙트를 호출하거나 배포하려면 반드시 필요한 파일들입니다.

---

## 🚀 컨트랙트 배포 함수

```js
async function deploy() {
  try {
```

→ 비동기 함수 `deploy()` 선언.  
→ 모든 배포 과정은 네트워크 통신이니까 `async/await` 필수입니다.  
**"이제 진짜 배포할게요!"**

---

```js
const accounts = await web3.eth.getAccounts();
const account = accounts[0];
```

→ Ganache가 제공한 가짜 지갑들 중 하나를 선택합니다.  
배포에 사용할 "내 지갑 주소" 설정

---

```js
const contract = new web3.eth.Contract(
  JSON.parse(fs.readFileSync(abiPath, "utf8"))
);
```

→ `ABI`를 읽어와서 이더리움 네트워크에 등록할 컨트랙트 인스턴스를 만들어요.  
ABI 없이 블록체인에 “이 컨트랙트 이렇게 생겼어요” 라고 설명할 수 없음

---

```js
const deployTx = contract.deploy({
  data: "0x" + JSON.parse(fs.readFileSync(bytecodePath, "utf8")),
  arguments: [],
});
```

→ Bytecode를 읽어와서 배포 트랜잭션을 생성합니다.  
→ `arguments`는 생성자에 넣을 인자가 없어서 빈 배열  
**"이걸 블록체인에 심어주세요"** 요청 준비

---

```js
const gas = await deployTx.estimateGas();
```

→ 실제로 얼마만큼의 연산비용(Gas)이 들지 미리 계산해봅니다.  
이걸 안 하면 “가스 부족” 에러가 날 수 있어요

---

```js
const result = await deployTx.send({
  from: account,
  gas: gas,
});
```

→ 트랜잭션을 네트워크에 전송합니다.  
→ **배포가 이뤄지는 순간**  
여기서 컨트랙트가 블록체인에 올라가고, 고유 주소를 갖게 됩니다.

---

```js
console.log("Contract deployed at:", result.options.address);
return result.options.address;
```

→ 배포된 컨트랙트의 주소를 출력합니다.  
바로 이 주소가 `Contract Address`, 즉 **우리 계약의 집 주소**

---

```js
  } catch (error) {
    console.error("Deployment error:", error);
  }
}
```

→ 중간에 에러가 생기면 로그로 확인할 수 있게 처리합니다.

---

```js
deploy();
```

→ 지금까지 정의한 배포 함수를 실제로 실행합니다.  
**이제 진짜로 배포 완료!**

# 5단계: Ganache에서 실행해보기 – 내가 만든 계약이 실제로 작동하는 순간

---

지금까지 우리는 다음 작업을 했습니다:

- `Counter.sol`이라는 계약을 작성하고
- `compile.js`를 통해 **ABI**와 **Bytecode**를 만들었어요.

이제 남은 건 단 하나:

> **“실제로 이걸 배포하고 실행해보는 것”**

---

## 근데 어디에 실행하죠?

바로 여기서 등장하는 게 **Ganache**입니다.

---

### Ganache란?

Ganache는 **내 컴퓨터 안에서만 실행되는 개인용 이더리움 네트워크**입니다.

- 10개의 테스트 계정이 자동으로 생성되고,
- 각 계정에 테스트용 이더가 100개씩 지급되며,
- 복잡한 지갑 연결 없이도 바로 트랜잭션을 실행할 수 있습니다.

📌 쉽게 말해:

> **실제 이더리움 네트워크처럼 작동하지만, 위험도 비용도 없는 실험 공간**

---

## 오늘 실습의 진짜 목표

우리가 확인하고 싶은 건 단순합니다:

1. **배포한 컨트랙트가 제대로 올라갔는가?**
2. **`increment()` 호출 → 숫자 올라가는가?**
3. **`getCount()` 호출 → 상태를 정확히 읽어오는가?**

---

## 전체 실행 흐름 – 단계별 리스트

```plaintext
1단계: compile.js 실행 → ABI / Bytecode 생성
2단계: deploy.js 작성 → Ganache 네트워크에 컨트랙트 배포
3단계: call_increment.js → 상태 변경 (count += 1)
4단계: call_getCount.js → 현재 count 값 확인
```

각 스크립트는 그 목적과 기능이 완전히 분리되어 있어요.  
**하나의 스크립트 = 하나의 역할 = 하나의 책임**  
이 흐름이 몸에 배도록 만드는 게 목표입니다.

---

## 실제 배포 예시 로그

```bash
▶ node deploy.js
Contract deployed at: 0x950Ca5d7B177d28f5a02a8460F6600bBE574e703
```

이 한 줄이 의미하는 건 뭘까?

> **이제 나만의 계약이 하나의 주소를 갖고 블록체인에 올라갔다는 뜻입니다.**  
> 즉, 이 순간부터 **누구든 이 주소로 계약을 호출할 수 있는 상태가 된 거예요.**

---

## 이 실습의 진짜 의미는?

> “내가 쓴 코드가 그냥 실행되는 게 아니라,  
> EVM 위에서 실행되고, 상태를 바꾸고,  
> 그 결과가 **블록체인에 기록되는 구조**임을 체험하는 것”

---

이 감각이 익숙해졌다면,  
우리는 다음 단계에서 이 컨트랙트를 **퍼블릭 환경**,  
즉 **세폴리아 네트워크**에 올려보는 실습으로 확장할 수 있습니다.

# 실행 흐름 가이드 – `Ganache에서 스마트 컨트랙트 실행 실습`

---

## 사전 준비: 필요한 패키지 설치

```bash
npm install ganache-cli web3 solc
```

- `ganache-cli`: 가상 이더리움 네트워크 실행기
- `web3`: JS에서 이더리움과 소통하기 위한 라이브러리
- `solc`: Solidity 컴파일러

---

## 실습 환경 실행 – 2개의 터미널을 준비하세요

---

### 터미널 1 – 가상 이더리움 네트워크 실행 (Ganache)

```bash
npx ganache-cli
```

- 10개의 테스트 계정 자동 생성
- 각 계정은 테스트용 이더 100개 보유
- 포트: 8545
- 지금부터 이 네트워크에 배포/실행을 합니다

---

### 터미널 2 – 계약 실행 흐름

```plaintext
step 1. node compile.js       → Counter.sol → ABI / Bytecode 생성
step 2. node deploy.js        → Ganache에 컨트랙트 배포, CA 확인
step 3. node call_increment.js → count += 1 요청 (상태 변경)
step 4. node call_getCount.js  → 현재 count 값 읽기
```

---

## 각 단계 목적 요약

| 파일 이름           | 목적                             | 실행 후 기대 결과                             |
| ------------------- | -------------------------------- | --------------------------------------------- |
| `compile.js`        | 코드 컴파일                      | `contracts_sol_Counter.abi`, `.bin` 파일 생성 |
| `deploy.js`         | 네트워크에 계약 배포             | Contract Address (CA) 출력                    |
| `call_increment.js` | 상태 변경 요청 (`count += 1`)    | 블록 생성, 트랜잭션 처리 완료 메시지 출력     |
| `call_getCount.js`  | 현재 상태 확인 (`count` 값 조회) | 콘솔에 숫자 값 출력 (예: 1, 2...)             |

---

## 예시 콘솔 출력 (요약 흐름)

```bash
▶ node compile.js
컴파일 완료! ABI와 Bytecode가 저장되었습니다.

▶ node deploy.js
Contract deployed at: 0xABC123...

▶ node call_increment.js

▶ node call_getCount.js
```

---

## 마무리 핵심 개념 정리

- 내가 쓴 코드(`Solidity`)는 **그냥 실행되는 코드가 아니다**
- **컴파일 → 배포 → 트랜잭션 → 상태 확인**이라는 **전체 흐름**이 존재한다
- 지금 내가 보고 있는 숫자(`count`)는  
  → **EVM이 실행한 결과이며, 블록체인에 기록된 상태값이다**
