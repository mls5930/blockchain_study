# 자 이렇게 쭈욱 설명을 했는데요.

아직 무슨 소리인지 잘 모르겠죠?  
이해가 됩니다.

그래서 말보다는, 이제 직접 코드를 보면서 이해해보는 시간을 가질 거예요.

---

이제 질문 하나 던져볼게요:

> “그럼 우리가 짜는 코드도, 저 EVM 위에서 실행되는 걸까?”

맞습니다.  
우리가 작성할 코드—이제부터 만들어볼 **작은 컨트랙트 하나**도  
바로 저 가상 머신(EVM) 위에서 **실제로 실행**됩니다.

---

그래서 이제부터 **우리는 이더리움 스마트 컨트랙트를 직접 짜보고, 실행해볼 겁니다.**

그 실습의 주제는…  
아마 이름을 들으면 웃을 수도 있어요.

우리가 만들 건 바로...

> **카운터**입니다.  
> (네, 그거 맞아요. 숫자 하나씩 올라가는 그거요.)

---

근데 이번엔 다릅니다.

단순히 변수 하나를 증가시키는 코드가 아니에요.  
**이건 스마트 컨트랙트로 작성된 코드고,**  
**EVM 위에서 실행되고, 실행 결과가 블록체인에 기록되는 실험**입니다.

---

정확히 어떤 흐름이냐면…

- 우리가 Solidity로 `+1` 기능이 담긴 컨트랙트를 작성하고,
- 이 코드를 **EVM이 이해할 수 있는 바이트코드로 컴파일**한 뒤,
- **Ganache**라는 로컬 테스트 블록체인 환경에 배포합니다.
- 그런 다음 우리는 **직접 만든 컨트랙트를 호출하고**,
- **실제로 값이 변하는 과정을 눈으로 확인**하게 될 거예요.

---

> 즉, 오늘 우리가 만들 이 "카운터"는  
> 단순한 실습 예제가 아니라,  
> **진짜 블록체인에서 실행되는 하나의 계약(Contract)**입니다.  
> 다만 오늘은 **우리 컴퓨터 안에서 돌아가는 가상의 블록체인(Ganache)**에서 실험해보는 거예요.

---

자, 그럼 이제 그 실습을 위한 폴더부터 만들어봅시다.

```bash
250421
```

그리고 그 안에 제일 먼저 구성할 디렉토리는 바로 이거예요:

```bash
250421/
└── contracts/
    ├── Counter.sol
```

이 폴더 안에는 우리가 짤 스마트 컨트랙트 코드와,  
그걸 EVM이 이해할 수 있는 형태로 변환해주는 컴파일러가 들어가게 될 거예요.

- `Counter.sol` – 우리가 작성할 스마트 컨트랙트
- `compile.js` – 이 컨트랙트를 ABI와 Bytecode로 변환하는 코드
  좋아.  
  지금 요청한 방향은 단순히 `Counter.sol`을 "어떻게" 작성하느냐가 아니라,  
  **"왜 Solidity라는 새로운 언어를 배워야 하며, 어떤 철학과 배경 위에서 이 언어를 바라봐야 하는가"**  
  즉, **도구를 배우기 전에 세계관부터 정립시키는 것**이 핵심이야.

---

## Counter.sol

지금부터 우리는 스마트 컨트랙트를 직접 작성해볼 겁니다.  
그리고 그 첫걸음은 이 파일 하나에서 시작됩니다:

```bash
250421/
└── contracts/
    ├── Counter.sol
```

이름은 익숙하죠?  
네, 바로 그 카운터입니다. +1 올리는 카운터.  
근데 이번엔 그냥 버튼 누르면 숫자 올라가는 카운터가 아니라,  
**진짜 퍼블릭 블록체인에 올라가는 계약 코드로 작성된 카운터**입니다.

---

### 그런데 말이죠…

우리가 지금까지 코드를 짤 땐 거의 다 **JavaScript**나 **TypeScript**였어요.  
그런데 갑자기 `Counter.sol`이란 확장자의 **Solidity**라는 언어가 등장합니다.

이쯤에서 질문 하나 던져봅니다.

> "왜 자바스크립트로 안 짜고,  
> 굳이 새 언어를 또 배워야 하죠?"

---

Solidity는 **Ethereum 전용 스마트 컨트랙트 언어**입니다.  
이 언어로 작성된 코드는 결국 EVM 위에서 opcode로 변환되어 실행돼요.  
하지만 그냥 그렇게 설명하면 이 언어가 "대체재"처럼 느껴지기 쉬워요.  
절대 그렇지 않습니다.

```solidity
pragma solidity ^0.8.0;

contract Counter {

}
```

이게 우리가 작성할 컨트랙트의 기본 뼈대입니다.  
하나씩 해석해볼게요.

---

#### ✅ `pragma solidity ^0.8.0;`

이건 약속이에요.

> "나는 Solidity 0.8.0 버전 이상에서 이 코드를 사용할 거예요"  
> "그 이하 버전에서는 동작을 보장하지 않아요"

실제 블록체인은 오랜 시간 유지되기 때문에  
**명확한 버전 명시**는 필수입니다.  
Solidity는 하위 호환이 완벽하지 않기 때문에,  
**컨트랙트마다 사용하는 컴파일러 버전을 꼭 적어야 해요.**

---

#### ✅ `contract Counter {}`

이게 바로 우리가 만드는 "계약"입니다.  
자바스크립트에서 `class`와 비슷한 구조이지만,  
역할은 완전히 다릅니다.

이건 단순한 틀이 아니라:

- 하나의 독립적인 주소를 갖게 되고
- 상태(state)를 저장할 수 있고
- 여러 사람이 접근 가능한 "공공 계약"이 됩니다

즉, **이 코드를 배포하면 세상 어딘가에 하나의 주소가 생기고,  
그 주소는 독립적인 ‘계약 공간’이 되는 거예요.**

---

### 2. **실행이 아니라 기록이다**

우리가 이제부터 작성할 이 컨트랙트는, 단순히 눈앞에서 숫자를 올리고 끝나는 코드가 아닙니다.  
이건 **전 세계 노드가 실행하고, 그 결과를 블록에 새기는 계약입니다.**

Solidity에서는 함수를 실행하는 순간,

> **그 행위는 기록이 됩니다.**

- 저장소가 바뀌고,
- 트랜잭션이 만들어지고,
- 가스(Gas) 비용이 발생하고,
- 모든 노드가 같은 결과를 검증하고,
- 그 결과가 블록에 남습니다.

즉, **실행은 곧 영구 기록**입니다.  
한 번 실행되면 절대 되돌릴 수 없어요.  
이게 Solidity의 본질이에요.

---

그럼 이제 우리가 만들 `Counter` 컨트랙트에 기능을 조금 추가해봅시다.  
단순히 `count`라는 숫자를 1씩 증가시키는 기능이에요.

```solidity
contract Counter {
    uint public count = 0;

    constructor() {
        count = 0;
    }

    function increment() public {
        count += 1;
    }

    function getCount() public view returns (uint256) {
        return count;
    }
}
```

이제부터 각 구성 요소를 차근차근 뜯어봅시다.

---

#### ✅ `uint public count = 0;`

- `uint`는 **양의 정수형 변수**를 선언하는 타입입니다.  
  (`uint256`과 동일하며, 기본 정수는 모두 양수예요)
- `public`은 **이 변수를 외부에서도 조회 가능하게 만든다는 의미**입니다.
  즉, 이 컨트랙트가 배포되면 Etherscan에서도 이 변수 값이 자동으로 보이게 됩니다.
- `= 0`은 **초기값 선언**입니다.

👉 이건 결국, **컨트랙트의 상태(state)**입니다.  
**지금 이 계약이 어떤 값을 보유하고 있는지를 보여주는 공간**이에요.  
이건 단순한 변수 선언이 아니라,  
**블록체인에 저장되는 값**이고,  
**누구나 조회할 수 있는 퍼블릭 상태**입니다.

---

#### ✅ `constructor() { count = 0; }`

- 생성자 함수입니다.
- 이 컨트랙트가 배포될 때 **딱 한 번만 실행되는 특별한 함수**예요.
- 여기서는 그냥 count를 0으로 초기화하고 있지만,  
  나중엔 배포자 주소를 저장하거나, 초기 상태를 세팅하는 데에 자주 사용됩니다.
- 참고로 생성자 함수는 생략해도 됩니다.  
  여기선 학습 목적으로 `count = 0` 초기화를 보여주기 위해 명시했어요.

---

#### ✅ `function increment() public { count += 1; }`

- 누구나 이 함수를 호출할 수 있습니다.
- `count += 1`이라는 이 단순한 연산…  
  사실 이건 자바스크립트에서라면 `count++`만큼 가볍죠?

하지만 Solidity에선 이 한 줄이 **하나의 트랜잭션**을 만듭니다.

→ 이더를 조금 소모하고 (가스),  
→ 블록체인에 기록되고,  
→ 여러 노드가 이 연산을 똑같이 수행한 뒤,  
→ **그 결과를 영원히 남깁니다.**

그래서 우리가 이걸 "실행"했다기보다는,

> **"요청했고, 기록됐다"**라고 표현하는 게 더 정확해요.

---

#### ✅ `function getCount() public view returns (uint256)`

- `view` 함수는 상태를 **조회**만 하고 **변경하지 않는 함수**입니다.
- 즉, 블록체인을 건드리지 않고 값을 확인만 하므로 **가스가 들지 않아요.**
- `returns (uint256)`는 `count` 값을 그대로 되돌려주는 함수 시그니처입니다.

→ 이건 말 그대로 **“현재 계약의 상태를 확인해보는 용도”**입니다.
