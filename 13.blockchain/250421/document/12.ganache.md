# 5단계: Ganache에서 실행해보기 – 내가 만든 계약이 실제로 작동하는 순간

---

지금까지 우리는 다음 작업을 했습니다:

- `Counter.sol`이라는 계약을 작성하고
- `compile.js`를 통해 **ABI**와 **Bytecode**를 만들었어요.

이제 남은 건 단 하나:

> **“실제로 이걸 배포하고 실행해보는 것”**

---

## 근데 어디에 실행하죠?

바로 여기서 등장하는 게 **Ganache**입니다.

---

### Ganache란?

Ganache는 **내 컴퓨터 안에서만 실행되는 개인용 이더리움 네트워크**입니다.

- 10개의 테스트 계정이 자동으로 생성되고,
- 각 계정에 테스트용 이더가 100개씩 지급되며,
- 복잡한 지갑 연결 없이도 바로 트랜잭션을 실행할 수 있습니다.

📌 쉽게 말해:

> **실제 이더리움 네트워크처럼 작동하지만, 위험도 비용도 없는 실험 공간**

---

## 오늘 실습의 진짜 목표

우리가 확인하고 싶은 건 단순합니다:

1. **배포한 컨트랙트가 제대로 올라갔는가?**
2. **`increment()` 호출 → 숫자 올라가는가?**
3. **`getCount()` 호출 → 상태를 정확히 읽어오는가?**

---

## 전체 실행 흐름 – 단계별 리스트

```plaintext
1단계: compile.js 실행 → ABI / Bytecode 생성
2단계: deploy.js 작성 → Ganache 네트워크에 컨트랙트 배포
3단계: call_increment.js → 상태 변경 (count += 1)
4단계: call_getCount.js → 현재 count 값 확인
```

각 스크립트는 그 목적과 기능이 완전히 분리되어 있어요.  
**하나의 스크립트 = 하나의 역할 = 하나의 책임**  
이 흐름이 몸에 배도록 만드는 게 목표입니다.

---

## 실제 배포 예시 로그

```bash
▶ node deploy.js
Contract deployed at: 0x950Ca5d7B177d28f5a02a8460F6600bBE574e703
```

이 한 줄이 의미하는 건 뭘까?

> **이제 나만의 계약이 하나의 주소를 갖고 블록체인에 올라갔다는 뜻입니다.**  
> 즉, 이 순간부터 **누구든 이 주소로 계약을 호출할 수 있는 상태가 된 거예요.**

---

## 이 실습의 진짜 의미는?

> “내가 쓴 코드가 그냥 실행되는 게 아니라,  
> EVM 위에서 실행되고, 상태를 바꾸고,  
> 그 결과가 **블록체인에 기록되는 구조**임을 체험하는 것”

---

이 감각이 익숙해졌다면,  
우리는 다음 단계에서 이 컨트랙트를 **퍼블릭 환경**,  
즉 **세폴리아 네트워크**에 올려보는 실습으로 확장할 수 있습니다.

# 실행 흐름 가이드 – `Ganache에서 스마트 컨트랙트 실행 실습`

---

## 사전 준비: 필요한 패키지 설치

```bash
npm install ganache-cli web3 solc
```

- `ganache-cli`: 가상 이더리움 네트워크 실행기
- `web3`: JS에서 이더리움과 소통하기 위한 라이브러리
- `solc`: Solidity 컴파일러

---

## 실습 환경 실행 – 2개의 터미널을 준비하세요

---

### 터미널 1 – 가상 이더리움 네트워크 실행 (Ganache)

```bash
npx ganache-cli
```

- 10개의 테스트 계정 자동 생성
- 각 계정은 테스트용 이더 100개 보유
- 포트: 8545
- 지금부터 이 네트워크에 배포/실행을 합니다

---

### 터미널 2 – 계약 실행 흐름

```plaintext
step 1. node compile.js       → Counter.sol → ABI / Bytecode 생성
step 2. node deploy.js        → Ganache에 컨트랙트 배포, CA 확인
step 3. node call_increment.js → count += 1 요청 (상태 변경)
step 4. node call_getCount.js  → 현재 count 값 읽기
```

---

## 각 단계 목적 요약

| 파일 이름           | 목적                             | 실행 후 기대 결과                             |
| ------------------- | -------------------------------- | --------------------------------------------- |
| `compile.js`        | 코드 컴파일                      | `contracts_sol_Counter.abi`, `.bin` 파일 생성 |
| `deploy.js`         | 네트워크에 계약 배포             | Contract Address (CA) 출력                    |
| `call_increment.js` | 상태 변경 요청 (`count += 1`)    | 블록 생성, 트랜잭션 처리 완료 메시지 출력     |
| `call_getCount.js`  | 현재 상태 확인 (`count` 값 조회) | 콘솔에 숫자 값 출력 (예: 1, 2...)             |

---

## 예시 콘솔 출력 (요약 흐름)

```bash
▶ node compile.js
컴파일 완료! ABI와 Bytecode가 저장되었습니다.

▶ node deploy.js
Contract deployed at: 0xABC123...

▶ node call_increment.js

▶ node call_getCount.js
```

---

## 마무리 핵심 개념 정리

- 내가 쓴 코드(`Solidity`)는 **그냥 실행되는 코드가 아니다**
- **컴파일 → 배포 → 트랜잭션 → 상태 확인**이라는 **전체 흐름**이 존재한다
- 지금 내가 보고 있는 숫자(`count`)는  
  → **EVM이 실행한 결과이며, 블록체인에 기록된 상태값이다**
