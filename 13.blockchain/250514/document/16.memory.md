# 이 한 줄이 왜 이렇게 헷갈릴까요?

```solidity
Proposal storage p = proposals[_proposalId];
```

자, 여러분. 이 문장 어렵죠?
그냥 안 보고 외워버리고 싶은 문장이기도 하고요.

그런데 여러분, 이렇게 생각해봅시다.

> 이건 사실 **"블록체인에 저장된 Proposal 데이터를 직접 가리켜서 수정하거나 읽겠다"는 뜻입니다.**

## 근데, 질문 하나 던져볼게요

> **꼭 이렇게 직접 가리켜야만 할까요?**

아니면, 이렇게 말할 수도 있겠죠?

> **“그 Proposal 데이터를 그냥 복사해와서, 함수 안에서만 잠깐 쓰고 버릴 수도 있지 않나요?”**

맞아요. 그게 바로 우리가 첫 번째로 이해해야 할 포인트입니다.

## 첫 번째 인식: 참조할 것인가, 복사할 것인가?

Solidity에서는 변수를 다룰 때
**두 가지 방식 중 하나를 반드시 선택해야 합니다.**

| 방식      | 설명                                                 |
| --------- | ---------------------------------------------------- |
| `memory`  | 블록체인 상태와는 무관하게 **잠깐 복사해서 쓰는 것** |
| `storage` | 블록체인 상태 그 자체를 **직접 가리키는 것**         |

그렇다면 위의 코드는 어떤 의미일까요?

```solidity
Proposal storage p = proposals[_proposalId];
```

→ 블록체인에 저장된 `proposals[_proposalId]`를
→ 변수 `p`가 **직접 가리키는 참조 포인터**가 된다는 뜻입니다.

## 반대로 하면 어떤 일이 생기나요?

```solidity
Proposal memory p = proposals[_proposalId];
p.title = "Lunch Budget";
```

→ 이건 **그 Proposal의 복사본을 메모리에 띄워놓고**,
→ `title`을 바꾼 겁니다.

하지만 이건 **블록체인에는 아무런 변화도 남기지 않습니다.**
→ 함수 끝나면 사라지는, 그냥 "임시 수정본"일 뿐입니다.

## 그러면 이 개념, 어떻게 공부해야 할까요?

다음과 같은 4단계를 차근차근 따라가 보세요.

---

### 1. **이더리움 네트워크에서의 메모리 영역 구분**

- `storage`: 블록체인에 기록되는 공간 (상태 변경 O)
- `memory`: 함수 실행 중에만 쓰는 임시 공간 (상태 변경 X)

---

### 2. **“포인터”라는 개념을 체화하기**

- `Proposal storage p`는
  → 실제 Proposal 상태를 **직접 가리킨다 (원본 참조)**
- `Proposal memory p`는
  → Proposal의 내용을 **복사해서 사용하는 스냅샷**

---

### 3. **Solidity에서 왜 명시를 강제하는가?**

Solidity는 `struct`, `array`, `mapping` 같은 복합 자료형을 쓸 때
**반드시 `memory` 또는 `storage`를 명시하도록 강제**합니다.

왜냐하면, 둘의 차이가 너무 중요하기 때문입니다.

- **가스비**에 영향 있고
- **상태 변화**에 직접 연결되며
- **보안상 의도하지 않은 상태 오염을 방지하기 위해서**입니다.

---

### 4. **struct와 mapping을 다룰 때는 더욱 주의**

```solidity
struct Proposal {
    ...
    mapping(address => bool) voted;
}
```

- `mapping`은 복사가 안 됩니다.
- `Proposal`에 `mapping`이 들어있다면
  → **무조건 `storage`로 다뤄야** 합니다.

**블록체인의 구조 자체에서 비롯된 철학**이란 관점에서 접근하면 좋을 듯.

## 최종 정리 – 여러분이 반드시 알아야 할 것

| 질문                     | 기억해야 할 포인트                       |
| ------------------------ | ---------------------------------------- |
| 복사해서 쓸 건가요?      | → `memory`를 씁니다                      |
| 직접 상태를 바꿀 건가요? | → `storage`를 씁니다                     |
| 복합 자료형인가요?       | → 명시(`memory`, `storage`)가 필수입니다 |
| mapping이 들어있나요?    | → `storage`만 가능합니다                 |

## 그럼 이제 다시 한 번 봅시다.

```solidity
Proposal storage p = proposals[_proposalId];
```

여러분, 이 코드 어렵게 생각하지 마세요.
우리가 전에 배웠죠?
`struct` + `mapping`은 **내가 접근하는 순간 기본값을 준다**는 원리.

그러니까 이 코드는 이렇게 말하는 겁니다:

> “내가 `proposals`라는 상태에 접근할게!
> 그러면 너는 **기본값이라도 존재하게 되겠지?**
> 이제 내가 **직접 참조해서 수정하고 상태 업데이트 좀 할게^^**”

그냥 이겁니다.

> 복사 아님
> 참조임
> 수정은 곧 상태 변화임

→ 그래서 `storage`를 쓰는 거예요.
