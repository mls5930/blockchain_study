# 구조적 한계 – 이 방식으로 모든 걸 처리할 수 있을까?

여러분, 우리는 방금
**하나의 DAO 컨트랙트 안에 여러 개의 안건을 등록하고,
그에 대해 투표하고, 결과를 상태로 남기는 구조**를 완성했습니다.

구조적으로 깔끔하고, 실습하기에도 좋죠.

그런데 여기서 질문을 하나 드려봅니다:

> “우리가 만든 이 구조로, 현실의 모든 투표 시스템을 다 표현할 수 있을까요?”

## 안건마다 실행 조건이 다르면?

예를 들어,

- 안건 A는 "찬성 2명 이상이면 통과"
- 안건 B는 "전체 투표 수의 60% 이상이 찬성일 때만 통과"
- 안건 C는 "특정 지갑이 승인해야만 유효"

→ 지금 우리가 만든 구조에서는
**이러한 조건을 안건마다 다르게 구현할 수 없습니다.**

왜냐면… `vote()`와 `getResult()`의 로직이 **모든 안건에 공통**이기 때문입니다.
→ 즉, **안건이 다양해질수록 구조가 버티질 못합니다.**

-

## 종료된 안건은 재사용이 불가능합니다

지금 구조에서는 한 번 `finished = true`가 되면
→ 그 안건은 그냥 "죽은 상태"가 됩니다.

- 수정도 안 되고,
- 다시 리셋도 안 되고,
- 복사도 어렵습니다.

> “한 안건을 기준으로 또 다른 투표를 만들고 싶어요!”
> → 지금 구조에선 불가능합니다.

-

## 컨트랙트 크기와 상태가 계속 커진다면?

생각해봅시다.

- 안건이 10개, 50개, 100개, 1000개…
- 투표자도 수백 명씩 누적된다면?

→ `mapping(uint => Proposal)` 안에 엄청난 상태 데이터가 쌓이게 됩니다.
→ 그럴수록 **컨트랙트는 점점 무거워지고**,
→ **가스비**는 더 많이 들고,
→ 결국 **이더리움의 확장성 한계**에 부딪히게 됩니다.

## 안건마다 다른 인터페이스가 필요하면?

지금 DAO 구조는 모든 안건에
`title`, `yes`, `no`, `finished`, `voted`
→ **딱 이 다섯 개만 존재**하죠?

근데 만약 어떤 안건은,

- 예산을 자동 지급해야 하고
- 어떤 안건은 NFT를 소각시켜야 하고
- 어떤 안건은 외부 컨트랙트와 연결되어야 한다면?

→ **Proposal마다 고유한 동작(인터페이스)**이 필요하겠죠.

하지만 지금 구조에서는
Proposal은 단지 데이터일 뿐이고,
→ 동작을 가질 수 없습니다.

-

## 그래서 우리는 감지합니다

> “이제 Proposal은 단순한 데이터가 아니라,
> **하나의 독립된 객체가 되어야 하지 않을까?”
> **자기 스스로 상태를 가지고, 조건을 설정하고, 실행까지 책임지는 존재.\*\*

-

## DAO 구조도 결국 '객체화'가 필요하다

지금까지는
→ "모든 안건을 하나의 컨트랙트에서 상태로 관리하는 구조"였다면,
이제는
→ **"안건 하나하나를 개별 컨트랙트로 만들어야 할 때"**입니다.

- 그렇게 하면 안건마다 조건도 다르게 짤 수 있고
- 컨트랙트 크기도 분산되고
- 재사용성도 높아지고
- 로직도 분리되고
  → **실제로 탈중앙화된 조직 운영에 더 적합해집니다.**

---

다음 수업에서 우리는
**“안건 하나 = 하나의 컨트랙트”**로 설계하는
**DAO Factory 구조**를 구현해볼 것입니다.

→ `ProposalFactory`라는 컨트랙트를 통해
→ 각각의 안건을 독립된 Proposal 컨트랙트로 만들어보고
→ 거기서 자유로운 실행 조건과 흐름을 부여해보겠습니다.
