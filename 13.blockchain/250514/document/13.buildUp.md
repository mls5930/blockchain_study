# 의도된 간소화 – **"직접 부딪혀야 설계의 한계가 보입니다"**

여기까지 잘 따라오셨습니다.
안건을 만들고, 투표하고, 종료하고, 결과를 확인하는
**하나의 DAO 구조**를 우리가 직접 만들었습니다.

처음이라서 조금 단순했지만,
그래서 오히려 **명확하게 체득할 수 있는 구조**였습니다.

---

## 그런데 여러분, 이런 생각 들지 않으셨나요?

> “어라? 이 구조로 진짜 아무 문제 없이 운영 가능한가?”

맞습니다.
사실 여러분이 이미 눈치채셨을지도 모르겠습니다.

이 구조는 완벽하지 않습니다.
**일부 중요한 유효성 검사가 아예 생략되어 있습니다.**

---

## 왜 생략했을까요?

> **일부러입니다.**

의도적으로 빠뜨렸습니다.
왜냐하면,

> **직접 부딪히고 오류를 경험할 때,
> 그게 곧 “설계 개선”의 출발점이 되기 때문입니다.**

---

## ❗ 자, 그럼 어떤 점들이 생략되어 있었을까요?

### 1. `proposalId` 유효성 검사

```solidity
Proposal storage p = proposals[_proposalId];
```

- 이 줄은 매우 자주 등장했지만,
- 사실 `require(_proposalId < proposalCount)` 같은
  **ID 범위 체크가 빠져 있습니다.**

> 존재하지 않는 안건에 접근하면 어떻게 될까요?
> → 오류가 발생할 수 있습니다.

---

### 2. `Proposal[]` 배열처럼 전체 반환이 안 되는 이유

```solidity
struct Proposal {
    ...
    mapping(address => bool) voted;
}
```

- 구조체 안에 `mapping`이 들어있기 때문에
- 이 구조체 자체는 memory로 복사하거나, 한 번에 리턴할 수 없습니다.

→ 그래서 우리는 `getResult()`를 만들어
→ 필드별로 하나하나 뽑아서 리턴한 겁니다.

> 만약 전체 Proposal을 배열로 반환하고 싶다면?
> → 이 구조는 **기술적으로 막혀 있습니다.**

---

### 3. `proposalCount++` 위치 변경 시도

```solidity
Proposal storage p = proposals[proposalCount++];
```

이 문장은 **후위 증가 연산자**를 사용하고 있죠?

→ `proposalCount`가 먼저 `proposals[x]`에 쓰인 뒤
→ 그 다음에 1이 증가합니다.

> 만약 위치를 바꾸면 어떤 일이 생길까요?

```solidity
proposalCount++;
Proposal storage p = proposals[proposalCount];
```

→ 이 경우 **proposals\[1]부터 시작**하게 됩니다.
→ `proposals[0]`은 영원히 비어있게 됩니다.

> 구조적 실수가 곧 **데이터 누락**으로 이어질 수 있다는 걸
> 이 실험을 통해 느껴보세요.

---

## 그러니까 오늘 구조는 완성형이 아닙니다

오히려 **불완전함을 체험하게 하기 위한 구조**입니다.

- 왜 유효성 검사가 필요한지
- 왜 `mapping`은 배열처럼 다룰 수 없는지
- 왜 상태 증가 타이밍이 중요한지

→ 이 모든 의문은
**직접 구현하고, 실패하고, 디버깅해볼 때 가장 강력한 배움이 됩니다.**

---

## 정리

| 생략 항목                     | 의미와 실험 포인트                              |
| ----------------------------- | ----------------------------------------------- |
| `proposalId` 유효성 체크 없음 | 엉뚱한 ID로 접근 시 오류 발생 여부 확인         |
| `Proposal[]` 반환 불가        | 구조체 내부에 `mapping`이 있으면 전체 반환 불가 |
| `proposalCount++` 위치 고정   | 순번이 꼬이면 구조 전체가 어긋남                |

---

> **여러분은 이제 단순히 “작동하는 코드”가 아니라,
> “의미 있는 구조”를 설계할 준비를 하고 있는 중입니다.**

다음 글에서는 이 설계의 한계를 기반으로
\*\*DAO를 어떻게 “확장 가능한 구조”로 바꿔나갈 수 있을까?\*\*를 함께 고민해보겠습니다.
→ 그 출발이 바로 **DAO의 객체화**, 그리고 **Factory 구조**입니다.
