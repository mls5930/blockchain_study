# 실습 예제 – 값 타입에서의 memory vs 직접 수정

이제부터는 손으로 직접 실험해보며 이해해보자.
**가장 단순한 값 타입인 `uint`부터 시작한다.**

---

## 시나리오

하나의 `count` 변수가 있다.
이 값을 함수 안에서 `100`으로 바꾸고 싶다고 해보자.
그런데 이걸 `memory`로 처리하면 어떻게 될까?
직접 값을 바꾸면 결과는 어떻게 될까?

→ 두 방식의 차이를 코드로 비교해보자.

---

## 코드로 봐보자

먼저 **실패 예제부터** 확인한다.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract VariableTest {
    uint public count = 1;

    function changeWithMemory() public view returns (uint) {
        uint temp = count; // 복사됨
        temp = 100;
        return temp;
    }
}
```

---

## 코드 흐름 설명

```solidity
uint temp = count;
```

- 이 줄에서는 `count`의 값을 **메모리로 복사**해서 `temp`에 저장한다.
- `count`는 이 컨트랙트의 전역 상태 변수이고, **기본적으로 storage에 저장**된다.
- 반면 `temp`는 함수 내부에 선언된 지역 변수이고, 이는 **자동으로 memory에 위치한다.**

즉, 이 시점에서 실제 일어나는 일은 다음과 같다:

> "storage에 있던 값을 memory로 복사해서 임시 변수로 만든다."

---

```solidity
temp = 100;
```

- 이 시점에서는 \*\*복사본(temp)\*\*의 값을 수정하는 것일 뿐,
- 실제 상태 변수인 `count`는 전혀 영향을 받지 않는다.

→ 이 함수가 끝난 후에도 블록체인에 저장된 `count`는 그대로 1이다.

---

## 그래서 이 함수는 상태를 바꾸지 못한다

- `temp = 100`은 단지 메모리 상의 변수만 수정한 것이라,
- 블록체인에 기록되는 상태는 전혀 변하지 않는다.
- `view` 함수인 이유도 여기에 있다. 상태를 **읽기만** 하기 때문이다.

---

## 진짜로 값을 바꾸고 싶다면?

```solidity
function realChange() public {
    count = 100;
}
```

- 여기서는 `count`라는 **storage 변수에 직접 접근**해서 값을 수정한다.
- 전역 상태 변수는 별도로 `storage` 키워드를 선언하지 않아도,
  **기본적으로 storage로 취급되기 때문에** 이 방식이 가능하다.

---

## 추가로 인지해야 할 것

Solidity에서는 `contract` 안에 선언된 모든 전역 상태 변수는
→ 자동으로 **storage 영역에 저장**된다.

> 즉, `count`는 굳이 `uint storage count = ...`처럼 쓰지 않아도 된다.
> 이미 **영구 저장되는 공간에 존재**하기 때문이다.

→ 이것이 `count = 100`처럼 단순 할당만으로도 상태가 바뀌는 이유다.

---

## 핵심 요약

| 코드                 | 의미                                      |
| -------------------- | ----------------------------------------- |
| `uint temp = count;` | `count`를 memory로 복사                   |
| `temp = 100;`        | 복사된 메모리 값만 수정됨 (상태는 그대로) |
| `count = 100;`       | 전역 상태 변수에 직접 접근하여 상태 변경  |

---

## 정리 문장

> `memory`는 복사다.
> 복사된 공간에서 무언가를 바꾸더라도,
> **원본인 storage에는 아무런 영향도 없다.**

---

이제 값 타입에서의 메모리/스토리지 개념은 분명해졌다.
다음 단계에서는 구조체(`struct`)에서 이 개념이 어떻게 확장되는지 확인해본다.
