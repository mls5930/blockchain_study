# 조건부 실행 – **“투표가 끝났다면, 이제 결과를 확정하자”**

자, 이제 우리는

- 투표가 어떻게 진행되고 (`vote`)
- 결과를 어떻게 확인할 수 있는지 (`getResult`)
  그 구조를 완성했습니다.

그런데 여기서 중요한 전환이 하나 필요합니다.

> **단순히 투표만 했다고, 결정이 난 걸까요?**

---

## “아직은 아닙니다.”

지금까지는

- 누가 찬성했는지
- 누가 반대했는지
- 총 몇 표가 나왔는지를
  우리가 상태로 기록해두었습니다.

하지만 **“투표가 끝났다”**는 것을
누가, 언제, 어떻게 선언할까요?

## 그 선언의 순간이 바로 **`finished = true`**입니다

```solidity
result = p.finished
    ? (p.yes > p.no ? "Proposal Passed" : "Proposal Rejected")
    : "Voting in progress";
```

이제 이 한 줄의 의미가 조금 다르게 보일 겁니다.

- `finished == false`일 땐 → 아무 결과도 말할 수 없습니다.
  → 아직 진행 중입니다. `"Voting in progress"`

- 하지만 `finished == true`로 전환된 순간
  → 우리는 이제 결과를 판단할 수 있게 됩니다.

## 결과 판단 조건은 단 하나입니다

```text
yes > no → "Proposal Passed"
yes <= no → "Proposal Rejected"
```

이 기준은 단순하지만, 명확합니다.

- 찬성이 반대보다 많아야만, 안건이 통과됩니다.
- 그 외의 모든 상황(무효, 동률, 반대가 많음)은 기각입니다.

## 이 조건이 어디에 들어가 있죠?

> 네. 바로 앞에서 살펴본 `getResult()` 함수 안에 포함되어 있습니다.

즉, 이 구조는
단순히 “투표가 종료되었는가?”만 보는 게 아니라,
→ 종료된 이후라면
→ **정해진 조건에 따라 자동으로 결과를 확정**해주는 역할까지 담당합니다.

## 이게 왜 중요한가요?

블록체인 위에서 중요한 건
**사람의 판단이 아니라, 코드로 표현된 조건**입니다.

> “이 조건을 만족하면 통과”
> → 라는 명시적인 기준이 있어야
> → 누구도 결과에 이의를 제기하지 못하게 됩니다.

## 핵심 정리

| 조건                | 결과 메시지          |
| ------------------- | -------------------- |
| `finished == false` | "Voting in progress" |
| `yes > no`          | "Proposal Passed"    |
| `yes <= no`         | "Proposal Rejected"  |

## 결론 – 결과는 스스로 판단하지 않는다

우리가 지금까지 만든 구조는

- 사람들의 참여로 상태를 쌓고
- 그 상태를 조건에 따라 해석하여
  → **결과를 도출하는 구조**입니다.

**"투표가 끝났다고 모두가 납득할 수 있으려면?"**
→ 바로 이런 **명시적 조건부 실행 구조**가 필요합니다.

다음 글에서는 이 결과를 확정짓는 **종료 트리거**,
즉 `finishVote()` 함수에 대해 다루겠습니다.

> 누가 종료할 수 있는가?
> 언제 종료해야 하는가?
> → 그 모든 제어권을 가진 존재는 **chairperson**입니다.
