# 투표 종료 후 상태 변화 – **“이제 이 안건은 끝났습니다”**

자, 이제 우리는

- 찬반 투표가 이루어지고 (`vote`)
- 조건에 따라 결과가 결정되는 구조 (`getResult`)까지
  완성했습니다.

그런데 여전히 **결정적인 한 줄**이 빠져 있습니다.

> **“투표를 종료합니다”**
> 라는 선언.

`## 이 종료 선언을 누가, 언제 할 수 있을까요?

블록체인 시스템은 사람의 말이 아니라
→ **함수의 호출**을 통해 상태가 바뀝니다.

바로 이 함수가 그 역할을 맡습니다:

```solidity
function finishVote(uint _proposalId) public onlyChairperson {
    Proposal storage p = proposals[_proposalId];
    require(!p.finished, "Already finished");
    p.finished = true;
}
```

## 이 함수의 역할은 단 하나입니다

> **이제 더 이상 이 안건에 대해 말하지 마세요.**

- 투표는 종료되었습니다.
- 찬반을 더 이상 누를 수 없습니다.
- 결과는 정해졌고, 이제 바뀌지 않습니다.

## 이 함수에는 중요한 제약이 있습니다

```solidity
onlyChairperson
```

바로 이 한 줄.

> 이 말은, 아무나 투표를 종료할 수 없다는 뜻입니다.
> → 반드시 **의장(chairperson)**만이 이 함수에 접근할 수 있습니다.

왜 이런 제한을 둘까요?

## “모든 사람에게 종료 권한이 있다면?”

- 투표 중간에 누군가 마음대로 종료시켜버린다면?
- 아직 참여하지 않은 사람들이 있는데, 미리 결과가 고정된다면?

→ **시스템은 곧 혼란에 빠집니다.**

## 그래서 우리는 **권한을 명시적으로 구분합니다**

| 역할        | 책임                 |
| ----------- | -------------------- |
| chairperson | 안건 등록, 투표 종료 |
| 일반 사용자 | 투표 참여만 가능     |

→ 이것이 바로 DAO 구조의 **책임 분리 원칙**입니다.

## 그리고 이 함수는 말합니다

```solidity
p.finished = true;
```

이제 이 안건은
→ 더 이상 `vote()`를 받을 수 없습니다.
→ 더 이상 상태가 바뀌지 않습니다.
→ 더 이상 누군가의 참여로 수정되지 않습니다.

> **이제 이 안건은 “종료 상태”입니다.**

## 한 번 종료된 안건은 어떻게 되나요?

- 다시 열 수 없습니다.
- 다시 투표받을 수도 없습니다.
- 결과는 영원히 고정됩니다.

→ 이것이 블록체인이 가진 **불변성(immutability)**의 특징입니다.

## 마무리 요약

| 코드                            | 의미                            |
| ------------------------------- | ------------------------------- |
| `onlyChairperson`               | 특정 권한자만 종료 가능         |
| `require(!p.finished)`          | 이미 종료된 안건은 또 종료 불가 |
| `p.finished = true`             | 상태를 종료 상태로 전환         |
| 이후 `vote()` 호출 시 에러 발생 | `"Proposal already finished"`   |

---

다음 글에서는, 이처럼 모든 흐름이 종료된 후
→ **전체 구조를 다시 돌아보며**
→ 이 구조의 **한계점**과 **다음 단계(Factory 구조)**로의 전환을 함께 살펴보겠습니다.

> DAO는 여기서 끝나지 않습니다.
> 오히려, 이제부터 **확장 가능한 DAO**를 고민할 시점입니다.
