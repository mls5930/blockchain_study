# 오늘 수업 코드, 몇 개는 일부러 지웠습니다

---

## 오늘은 먼저, 이렇게 시작할게요

오늘 우리가 같이 볼 코드는  
**지난 시간까지 만들었던 P2P 코드**입니다.

그런데…  
제가 여러분이 혼란스러울까 봐,  
**일부러 몇 줄 코드를 “지워서” 시작합니다.**

> 왜 지웠을까요?  
> 그 코드는 일단 작동도 안 되고,  
> 지금 단계에선 오히려 헷갈리게 할 수도 있었기 때문이에요.

---

## 그런데 그 코드… 사실은 중요한 역할을 합니다

아까 설명한 **블록체인의 “쌍방 구조”**를 표현하는 데 꼭 필요한 코드입니다.

그래서 오늘은

> “그 코드가 왜 필요한지”  
> “어떻게 동작하게 만들었는지”

**코드 한 줄 한 줄 같이 다시 써보며 설명할 거예요.**

---

## 구조 정리부터 해봅시다

우리는 지금 **노드 간에 메시지를 주고받는 구조**를 만들고 있어요.

- A(클라이언트)가 B(서버)에게 요청을 보냄
- B가 응답을 보냄 → A가 그 응답을 받아야 완성!

하지만 문제는,
**B가 응답을 보내더라도 A가 그걸 못 받을 때가 있었어요.**

그래서 우리가 예전에 지웠던 코드가 바로 이거예요:

```ts
client.on("data", (data) => {
  const message: IMessage = JSON.parse(data.toString().trim());
  // 받은 메시지에 따라 동작
});
```

---

## 그럼 이걸 어떻게 살렸을까요?

### 서버(`p2p.ts`)에서 고친 부분부터 보겠습니다:

`initializeSocket() 메서드 부분`

```ts
socket.write(JSON.stringify(message));
```

하지만 이제는 이렇게 바꿀겁니다.

```ts
this.sendMessage(socket, MessageType.allBlock, this.chain.get());
```

### 이게 가능한 이유?

서버 코드에 메시지를 잘 만드는 헬퍼 함수가 생겼기 때문이에요:

```ts
private sendMessage(socket: Socket, type: MessageType, payload?: Block | Block[]): void {
    const message: IMessage = { type, payload };
    socket.write(JSON.stringify(message));
}
```

이 함수는 말 그대로:

> "보낼 메시지를 예쁘게 만들어서 socket으로 전달해주는 함수"

---

## 그럼 다시, 클라이언트도 받아야겠죠?

이제 클라이언트는 이렇게 작성했습니다:

```ts
client.on("data", (data) => {
  const message: IMessage = JSON.parse(data.toString().trim());
  console.log("message", message);

  switch (message.type) {
    case MessageType.addBlock:
      this.chain.replaceChain(message.payload as Block[]);
      break;
    case MessageType.latestBlock:
      console.log("[Latest Block]", message.payload);
      break;
    case MessageType.allBlock:
      console.log("[All Blocks]", message.payload);
      break;
  }

  client.destroy(); // 메시지 다 받고 종료
});
```

---

## 이 구조의 의미는?

이제 진짜 **블록체인 네트워크 구조처럼** 동작합니다.

- A → B에게 요청을 보냄
- B가 응답을 다시 A에게 보냄
- A는 `on("data")`로 그걸 받고 처리함

이 흐름이 바로 **"상호 통신, 쌍방 네트워크 구조"**의 기본이에요.
