# `client.ts`와 `p2p.ts`는 어떻게 서로 연결될까요?

---

## 진짜 궁금한 포인트

> “`client.ts`에서 보낸 메시지가  
> 어떻게 `p2p.ts`의 코드까지 정확히 도달해서  
> `initializeSocket()` 안으로 들어가는 거죠?”

코드가 나뉘어 있는데…  
**어떻게 자동으로 이어져서 작동하는 걸까?**

---

## 결론부터 말하면?

> **코드끼리 연결되는 게 아니라,  
> 포트를 기준으로 소켓끼리 연결**되는 겁니다.

---

## 소켓 통신의 원리

| 역할        | 설명                                                   |
| ----------- | ------------------------------------------------------ |
| `listen()`  | **포트를 열고 기다리는 역할 (서버)**                   |
| `connect()` | **열려 있는 포트에 연결을 시도하는 역할 (클라이언트)** |

---

## 실제 동작 흐름

### 1. `p2p.ts` – 서버가 먼저 문을 엽니다

```ts
listen(port: number): void {
  const server = net.createServer((socket) => {
    this.initializeSocket(socket); // 들어오는 연결 처리
  });

  server.listen(port, () => {
    console.log(`P2P 서버 실행 중 port: ${port}`);
  });
}
```

> “나는 지금 8081번 포트에서 기다릴게.  
> 누가 나한테 연결 오면 initializeSocket으로 처리할게!”

---

### 2. `client.ts` – 클라이언트가 그 포트로 문을 두드립니다

=> 나 node1인데! 나 블록 채굴함!

```ts
client.connect(port, host, () => {
  client.write(JSON.stringify(message));
});
```

> “8081번 포트 열려 있다며?  
> 나 메시지 하나 보낼게요~”

---

### 3. 그리고 이 순간!

- **서버에 열려 있는 포트(8081)에 누가 연결을 시도하면**
- `net.createServer((socket) => { ... })` 안의 콜백이 실행됩니다
- 여기서 받은 `socket`은 바로 **그 연결을 시도한 클라이언트와의 통로**입니다

---

## 그러니까 정리하면?

- **클라이언트가 connect(port, host)**로 요청하면
- **서버는 listen(port)**으로 이미 대기 중이고
- 요청이 오면 → 서버가 `initializeSocket(socket)`으로 처리함

이건 **코드끼리 맞물리는 게 아니라**,  
**포트를 통해 운영체제 수준에서 통신이 이어지는 구조**입니다.

---

> 여러분, `client.ts`랑 `p2p.ts`는 파일만 다를 뿐이지,  
> **둘 다 “소켓”이라는 걸 통해 같은 통신 규약으로 이어지고 있어요.**

> 코드끼리 연결되는 게 아니라,  
> **포트(=주소)를 통해 운영체제가 “여기 연결 들어왔어”라고 이어주는 거예요.**

> 그러니까 `client.connect()`는  
> 결국 `server.listen()`하고 있는 곳으로  
> **실제 연결 요청을 보내는 행동**입니다.  
> 서버는 그걸 받아서 `initializeSocket()`에서 응답하는 거고요.

---

## 비유로 이해하기

- `listen()`은 **가게 문 열고 손님 기다리는 것**
- `connect()`는 **손님이 가게 문 열고 들어오는 것**
- `socket`은 **손님과 가게 주인 사이의 전화기**
- 그 전화기를 통해 데이터를 주고받는 게 `write()`, `on('data')`
