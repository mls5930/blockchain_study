# 질문

> “스마트컨트랙트를 배포할 때, 왜 CA(Contract Address)가 꼭 필요하죠?”  
> “이미 코드가 블록체인에 올라갔다면, 그냥 그 코드 실행하면 되잖아요?”  
> “왜 굳이 주소 → 코드 → 함수 실행처럼 귀찮은 구조를 쓰죠?”

---

# 답변

## 1. **먼저 CA가 없다고 가정해보자**

- 우리가 `solc`로 컴파일해서 ABI, Bytecode를 얻고
- `web3.eth.sendTransaction()`으로 블록체인에 배포했다고 하자
- 그런데 CA가 없다면?

→ **블록체인에는 수많은 컨트랙트가 존재하고, 전부 같은 구조의 코드일 수도 있어요.**  
→ 그 중에서 **“내가 배포한 코드가 어떤 것인지” 식별할 방법이 없습니다.**

---

## 2. **ABI와 Bytecode는 ‘형태’일 뿐, ‘위치’가 아니다**

- ABI: 스마트컨트랙트가 어떤 함수 구조를 가지는지 설명해주는 인터페이스
- Bytecode: EVM이 이해할 수 있는 실행 명령어

> → 이건 **“이 컨트랙트를 어떻게 다룰지”를 설명할 뿐,  
> “어디 있는지를 지칭하지는 않아요.”**

---

## 3. **블록체인 네트워크는 “위치 기반 구조”다**

| 항목                           | 설명                          |
| ------------------------------ | ----------------------------- |
| externally owned account (EOA) | 사용자의 지갑 주소            |
| contract account (CA)          | 블록체인에 배포된 코드의 주소 |
| state                          | 특정 주소에 저장된 데이터     |

→ 모든 트랜잭션과 함수 호출은  
**“어디(Address)에 요청할 것인가?”**를 기준으로 작동해요.

---

## 4. **코드를 실행하는 게 아니라, “주소에 있는 코드”를 실행하는 것**

- 스마트컨트랙트는 단순한 코드가 아니라,
  > **“블록체인에 위치한, 고정된 코드와 상태를 가진 실행 단위”**예요.
- EVM은 트랜잭션을 처리할 때, 항상 **주소를 기준으로**
  > 그 주소에 있는 **코드**를 불러오고  
  > 그 주소에 있는 **스토리지**를 바꾸고  
  > 결과를 **그 주소에 귀속**시켜요.

---

## 그래서 구조가 이렇게 되는 거예요:

```
CA (어디?) → 그 위치에 저장된 코드 (무엇?) → 그 코드의 함수 (어떻게?)
```

→ **CA 없으면, "무엇을 실행해야 할지" 결정 불가능**  
→ **CA 없으면, 상태도 구분할 수 없음**  
→ 결국 **CA는 "코드의 정체성 + 위치 + 상태"를 모두 의미**하는 유일한 식별자

---

## 정리 한 문장

> **블록체인에서 모든 실행 가능한 대상은 ‘주소(Address)’를 기준으로 요청되고,  
> 스마트컨트랙트도 예외 없이  
> “어느 주소에 있는 어떤 코드”를 호출하는 방식으로 실행된다.**

# 이더리움, 세폴리아 등등 네트워크는 상태를 가집니다.

우리는 보통 이렇게 말합니다:

> “이 상태를 EVM을 통해서 컨트랙트를 실행하여 상태를 변화한다”
> => 이게 이더리움, 솔라나....등등에서 말하는 트랜잭션을 일으켰다의 의미.

그럼 여기서 중요한 질문 하나:

> **“상태(state)는 어디에 기록되는 걸까?”**

---

## 블록체인은 기술이다

- 블록체인은 그냥 기술이에요.
- 상태를 저장하는 **구조**고,
- 분산 네트워크가 그 상태를 **공유**한다는 개념이 핵심입니다.

→ 그래서 블록체인 **그 자체가 상태를 저장하는 주체는 아니에요.**

이더리움, 세폴리아 둘 다 동일한 상태를 가진다? 절 때 아니야
각각의 네트워크는 거대한 상태를 각각 가져.

---

## 중요한 포인트: “상태는 ‘네트워크’의 것이다”

- 우리가 스마트컨트랙트를 배포하고
- 트랜잭션을 발생시키면  
  → 상태(state)가 생기고, 바뀌고, 축적됩니다

근데 이 상태가 저장되는 대상은?

> **특정한 블록체인 네트워크입니다.**

---

## 예를 들어서

### 우리가 세폴리아(Sepolia) 테스트넷에 배포하고 트랜잭션을 보냈다?

- 이건 **블록체인 기술을 사용한 ‘세폴리아 네트워크의 상태’를 바꾼 것**이에요.
- 메인넷에는 아무 변화도 없어요.
- 로컬 Ganache 네트워크에도 아무 영향 없어요.

> 상태는 항상 **“특정 네트워크 단위로 분리되어 있다”**는 걸 기억해야 합니다.

---

## 그래서 구조는 이렇게 이해해야 해요

| 구분        | 설명                                                               |
| ----------- | ------------------------------------------------------------------ |
| 블록체인    | 분산 상태 저장을 가능하게 하는 기술                                |
| 네트워크    | 블록체인 기술로 구성된 실제 상태 보관 장소 (이더리움, 세폴리아 등) |
| 상태(state) | 각 네트워크가 가진 고유한 저장 내용 (컨트랙트, 잔액, 변수 값 등)   |

---

## 마무리 요약

> **“블록체인은 상태를 가질 수 있는 기술이고,  
> 실제 상태는 ‘블록체인 네트워크’에 저장된다.”**

> 우리가 트랜잭션을 보낼 때마다 바뀌는 건  
> **이더리움 네트워크의 상태,  
> 세폴리아 네트워크의 상태,  
> 또는 Ganache 로컬 네트워크의 상태**이다.

---

## 오해할 수 있는 질문

> “이더리움도 중앙화라는데, 그럼 블록체인이 아닌 거예요?”

---

## 답변: “또 이상한 소리 나왔네” (현실 인식부터 시작)

> 블록체인은 기본적으로 **탈중앙화를 지향하는 기술**이지만,  
> **현실적으로 완전한 탈중앙은 존재하지 않아요.**

- 네트워크 참여자 수, 노드 운영 분포, 메인 노드 집중도 등에 따라  
  → **“상대적인 탈중앙성”이 달라질 뿐**

---

## 핵심은 “모든 걸 블록체인에 저장할 필요는 없다”

### 예를 들어보자:

> 사용자의 프로필 사진, 성별, 나이, 선호 색상…

- 이런 정보들까지 굳이 블록체인에 기록해야 할까?
- **아니죠. 블록체인은 느리고, 비싸고, 공개돼 있어요.**

→ 이런 데이터는 그냥 **기존의 데이터베이스(RDBMS)**  
→ 예: MySQL, PostgreSQL 같은 걸 쓰는 게 더 합리적

---

## 그럼 언제 블록체인을 쓰나요?

> **"위조되면 안 되는 정보",  
> "모두가 공유하고 검증해야 하는 데이터"**는  
> **블록체인 네트워크에 저장**하는 거예요.

예를 들어:

- 누가 어떤 NFT를 가지고 있는가?
- 어떤 트랜잭션이 발생했는가?
- 스마트컨트랙트에 어떤 상태 변화가 있었는가?

→ 이런 건 **네트워크 전체가 동의해야 하는 정보**니까  
→ 블록체인 위에 저장해야 해요.

---

## 그래서 나오는 구분: **On-Chain vs Off-Chain**

| 구분      | 설명                     | 예시                                  |
| --------- | ------------------------ | ------------------------------------- |
| On-Chain  | 블록체인 네트워크에 저장 | 거래 기록, 토큰 보유 정보, 상태 값    |
| Off-Chain | 블록체인 외부에 저장     | 프로필, UI 설정, 일상적인 사용자 정보 |

→ 이건 **나중에 더 자세히 배울 예정**  
→ 지금은 **“모든 게 블록체인일 필요는 없다”는 감각만 익히면 돼요**

---

## 마무리 요약

> 이더리움은 완전한 탈중앙이 아니라, **필요한 부분만 네트워크로 분산시킨 구조**예요.
>
> 중요하고 검증 가능한 정보는 **블록체인 네트워크에 저장하고**,  
> 나머지 정보는 **중앙 데이터베이스(RDBMS)에 저장하는 게 일반적**이에요.
