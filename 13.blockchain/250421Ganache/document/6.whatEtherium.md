# 5단계: **그래서 이더리움은 무엇인가?**

— 기능을 품은 블록체인 플랫폼

## 1. **이더리움은 “기능을 실행할 수 있는 플랫폼”이다**

> 비탈릭 부테린은 "코인을 계속 만들지 말고, **기능을 코드로 표현하자**"는 문제의식에서 출발했습니다.

비트코인은 단일한 기능(화폐 전송)에 최적화된 시스템이었어요.  
하지만 비탈릭은 여기에 질문을 던졌죠.

> “왜 기능 하나 만들 때마다 네트워크를 새로 설계해야 하지?”  
> “그 기능을 코드로 만들고, 누구나 그걸 실행할 수 있다면 어떨까?”

그래서 탄생한 것이 바로 **Ethereum**,  
즉 **사용자가 직접 만든 기능을 블록체인 위에서 실행할 수 있는 플랫폼**입니다.

## 2. 그럼, 이 기능은 어디에서 실행되는 걸까?

> Ethereum은 단순히 “기능을 짜자”로 끝나지 않았어요.  
> 중요한 건, **그 기능을 네트워크 상에서 모두가 똑같이 실행하고, 검증하고, 기록해야 한다는 것**이죠.

그럼 어떻게 가능할까요?

> 정답은,  
> **“하나의 가상 머신(EVM) 위에서 똑같은 코드를 실행시키는 방식”**입니다.

## 3. EVM — Ethereum Virtual Machine

Ethereum은 네트워크 안에 **모두에게 동일하게 동작하는 ‘가상 CPU’**,  
즉 **EVM (Ethereum Virtual Machine)**을 만들어 넣었습니다.

- 이더리움의 모든 노드는 이 EVM을 보유하고 있어요.
- 그리고 사용자가 작성한 코드를 이 EVM 안에 넣고 실행시킵니다.
- 그렇게 하면 **어느 노드에서 실행하든, 항상 같은 결과**가 나오게 되죠.

📌 이것이 Ethereum이 **“전 세계에 설치된 하나의 컴퓨터처럼 작동한다”**고 표현되는 이유입니다.

## 4. 그럼, 이 EVM에 코드를 어떻게 넣을 수 있을까?

> 바로 여기에서 등장하는 게 **Solidity**입니다.

Solidity는 **EVM이 이해할 수 있는 코드(바이트코드)**를 만들기 위한 고급 언어입니다.  
즉, 사람은 Solidity로 작성하고,  
컴퓨터(EVM)는 이를 컴파일해서 바이트코드로 받아 실행합니다.

## 5. Solidity는 어떤 언어일까?

Solidity는 다음과 같은 특징을 갖습니다:

- 변수 선언
- 조건문, 반복문
- 상태 저장 (`state variable`)
- 함수, 이벤트
- 스마트 컨트랙트 단위의 모듈화

즉, 일반적인 프로그래밍 언어와 비슷하지만,  
**블록체인 위에서 실행된다는 점에서 결정적인 차이**가 있습니다.

### Solidity 예제:

```solidity
contract Counter {
    uint256 public count = 0;

    function increment() public {
        count += 1;
    }
}
```

📍 이 컨트랙트는 단순한 기능을 갖지만,  
**이 기능이 실행될 때 발생하는 상태 변화가 전 세계 노드에 의해 검증되고, 그 결과가 블록체인에 기록된다는 점**입니다.

---

### **계정 기반 구조 – EOA와 CA**

이더리움은 **모든 상태를 Account 단위로 관리**합니다.  
그리고 계정은 두 종류로 나뉩니다:

| 계정 타입                          | 설명                                                                                            |
| ---------------------------------- | ----------------------------------------------------------------------------------------------- |
| **EOA** (Externally Owned Account) | 우리가 흔히 쓰는 지갑 주소. **개인키를 보유하며**, 직접 트랜잭션을 보낼 수 있음                 |
| **CA** (Contract Account)          | 스마트 컨트랙트가 배포된 주소. **트랜잭션을 받아야만 작동**, 스스로는 트랜잭션을 시작할 수 없음 |

📌 이더리움 내부적으로는 이런 구조로 상태를 관리합니다:

```ts
interface Account {
  nonce: number; // 트랜잭션 카운터
  balance: string; // 이더 잔액
  storageRoot: string; // 상태 변수 저장 구조
  codeHash: string; // 배포된 스마트 컨트랙트 코드의 해시
}
```
