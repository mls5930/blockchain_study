# **상아님 프로젝트 중간 점검 피드백**

## 1. 디렉토리 구조

- `blockchain/`: 스마트 컨트랙트
- `project-ui/`: 프론트엔드
- `.gitignore`, `project.md`: 루트 설정

→ **프론트와 블록체인 분리를 명확히 했다는 점에서 좋은 선택**입니다.  
실전 프로젝트 구조와 유사합니다.

## 2. 컨트랙트 구조

- **총 3개 컨트랙트**로 책임 분리

  - `STKToken.sol`: ERC-20 보상 토큰
  - `BadgeNFT.sol`: ERC-1155 NFT 뱃지
  - `Board.sol`: 핵심 로직 담당 게시판 컨트랙트

→ **컨트랙트 간 의존성과 책임 분리가 잘 되어 있음**

## 3. 배포 및 초기 세팅 순서

1. STKToken 배포
2. BadgeNFT 배포
3. Board 배포 시, 위 두 컨트랙트 주소 주입
4. 이후 `transferOwnership`으로 Board가 나머지 권한을 위임받음

→ **컨트랙트 간 권한 위임과 책임 설정이 명확함**

## 4. **지금까지 어디까지 구현했어?**

- 글 작성 기능 구현했어요? 구현
- 0.5 ETH 체크 로직 있어요? 구현
- 보상(STK) 지급은 되고 있어요? 구현
- 등급 계산 로직 있어요? 실제로 조건 만족하면 등급 올라가요? 구현
- NFT는 발급이 되나요? 누구 기준으로? 어떤 시점에서? 구현

## 5. **다시 정리해서 말해볼까요? ‘내가 글 하나 쓰고, 조건 맞아서 뱃지 발급하는 흐름**

1. 글을 씁니다.
2. 0.5이더 빠져나감
3. 회원 등급을 확인합니다 (누적 조회수, 확인 등등)
4. 등급 조건에 맞는 보상을 줘요
5. 만약에 등급이 올랐어 그럼 보상을 줌

---

1. 컨트랙트 3개가 있어요
   1. STKToken 배포
   2. BadgeNFT 배포
   3. Board 배포시에 STK, NFT CA들을 전부 Board 상태에 주입시킵니다.
2. STKToken이랑 NFT에 transferOwnerShip을 오너의 권한까지 전부 다 넘깁니다.
3. 사용자가 글 쓰기 전에, 관리자가 STK 토큰 민팅을 해야 함.
4. 사용자가 글을 쓰면, 구조체 배열로 사용자가 쓴 글과 등등 정보들을 저장합니다.
5. 사용자 등급을 먼저 합니다. 각 등급에 맞는 보상을 줌.
6. 사용자가 글 등록 딸깍했을 때, 실행되는 함수는 다음과 같습니다.
   1. 등급 확인
   2. STK 토큰
   3. NFT

## 4. 그럼 다음은 뭐 할 계획이에요?

1. 메타마스크 연결해서 저거 오픈시랑 제대로 배포되는지 확인.
2. 그리고 화면 구현이요.

## 5. QNA

지금은 없고 나중에 있을 듯 싶어요
제발 부탁이니까 리스트 아리마셍

## 6. 피드백

상아님이 3일 동안 컨트랙트를 구현했죠?  
이걸 우리는 오래 걸렸다고 얘기합니다.

그렇다면 왜 오래걸렸느냐?

실력?

어느 정도는 맞아요 하하.

하지만 단순히 **실력 차이** 때문이 아닙니다.
**TDD(테스트 주도 개발)**라는 무기를 썼느냐, 안 썼느냐의 차이입니다.

---

### 교강사는 어떻게 하였느냐?

- **TDD로 흐름을 단위별로 정리**하면서 구현했음.
- 코드를 작성하기 전에 먼저,

  - 흐름을 정리했고
  - 테스트를 기준으로 책임과 결과를 명확히 나누었고
  - 실패를 예상한 뒤 코드를 작성했습니다.

> “내가 작성하는 모든 함수는 테스트 코드가 먼저 존재한다.”

---

### 상아님은 3일

- 이유:

  - 코드와 흐름을 **한 번에 묶어서** 고민했기 때문입니다.
  - 중간에 조건을 까먹거나, 흐름을 반복 확인해야 했고
  - 배포 후 리믹스에서 **직접 실행해보며 검증하는 방식**이었기 때문입니다.

## 그런데 이건 단순 속도 차이 문제가 아닙니다

### 시간이 지날수록 스마트 컨트랙트는 복잡해집니다:

1. **비용** 최적화를 고민하게 되고
2. **리팩토링**을 해야 하며
3. 흐름을 다시 **복기**해야 하고
4. 이상하게 작성된 코드를 **이해**하려 들며
5. **수정**해야 하고
6. **컴파일/배포** 다시 해야 하고
7. 리믹스에서 흐름 **다시 검증**해야 합니다.

> 지금은 3일, 나중엔 7일 걸립니다.
> 복잡도가 올라가면, 사람은 무너집니다.

## 그런데 TDD가 있다면?

1. 테스트 단위로 책임과 흐름이 정리됨
2. 고치고 다시 실행하는데 공수가 거의 없음
3. 협업 시 코드 리뷰에 **스크립트만 실행해 보여주면 됨**
4. **20분이면 전체 리뷰 끝**, 이게 협업 기준입니다.

## 정리

- 지금의 3일은 나쁘지 않습니다.
- 하지만, **그 시간이 왜 3일이었는지** 스스로 설명할 수 있어야 합니다.
- 그리고 다음에는 1일 안에 끝낼 수 있어야 합니다.
  **왜냐하면, 그걸 가능하게 해주는 도구가 바로 TDD이기 때문입니다.**
