# 트랜잭션 구조 구현: 단계별 선언 순서

자...상황 가정부터 합시다

`조상아 학생이 교강사인 주병현한테 100비트코인을 보냈다.`

이 단순한 거래도 **블록체인에서는 여러 구조가 유기적으로 작동해야만 성립**됩니다.  
즉, 단순히 금액을 입력하고 받는다고 끝나는 게 아닙니다.

## 핵심적으로 관찰할 포인트는 3가지입니다

| 구분          | 역할 설명                                        | 코드 구조로 연결             |
| ------------- | ------------------------------------------------ | ---------------------------- |
| 보내는 사람   | “내가 이걸 줄게요!” — 내가 어떤 걸 가지고 있는지 | `TxIn`, `UnspentTxOut`       |
| 받는 사람     | “이 사람이 받을 거예요” — 누구에게 줄 건지       | `TxOut`, `Receipt.received`  |
| 보상받는 사람 | (채굴자 등) “누군가는 보상 받아야죠”             | `createCoinbase()` + `TxOut` |

## 트랜잭션 흐름 전체 요약

```graph TD
    A[보내는 사람 (Sender)] --> B[내 지갑의 UTXO 조회]
    B --> C[필요한 UTXO 선택 → TxIn 배열 생성]
    C --> D[수신자, 잔액으로 TxOut 배열 생성]
    D --> E[TxIn + TxOut으로 트랜잭션 생성 및 해시 생성]
    E --> F[서명 추가 (Signature)]
    F --> G[트랜잭션 풀에 등록]
    G --> H[채굴자 블록에 포함 or 반영]
    H --> I[UTXO 업데이트 (새로운 TxOut 추가, TxIn 사용분 제거)]
```

## 목차

1. **트랜잭션을 구성하는 기본 단위부터 정의**
2. **전체 트랜잭션 한 건을 담을 구조 만들기**
3. **사용되지 않은 출력 관리 구조 정의 (UTXO)**
4. **트랜잭션 생성을 위한 로직 설계**
5. **트랜잭션 처리 이후 상태 변경 설계**
6. **트랜잭션 풀 관리**
7. **코인베이스 트랜잭션 설계 (보상)**

## 0단계. 트랜잭션 요청을 위한 외부 인터페이스 설계 (TDD 선택사항)

트랜잭션 생성 요청을 하기 위해 필요한 데이터 구조입니다.
외부에서 입력값으로 사용되며, 내부 트랜잭션 생성의 기반이 됩니다.

- Sender 클래스 선언
  - account: 보내는 사람의 주소
- Receipt 클래스 선언
  - sender: Sender 객체
  - received: 수신자 주소
  - amount: 전송할 금액
  - signature: 송신자가 서명한 값

이 구조는 Transaction.create(receipt, utxos) 에 전달되어 트랜잭션을 생성합니다.

## 1단계. **트랜잭션을 구성하는 기본 단위부터 정의**

트랜잭션은 입력과 출력이 기본입니다.  
**"이걸 가지고 있었고 → 누구에게 넘기겠다"**라는 구조죠.

- `TxIn` 클래스 선언

  - 어떤 과거 트랜잭션을 참조하는지
  - 몇 번째 출력인지
  - **서명**은 왜 필요한지

- `TxOut` 클래스 선언

  - 누구에게(account)
  - 얼마를(amount) 넘길 것인지

---

## 2단계. **전체 트랜잭션 한 건을 담을 구조 만들기**

이제 여러 개의 입력과 출력을 한 번에 묶을 수 있는 구조가 필요합니다.

- `TransactionRow` 클래스 선언
  - `txIns`: TxIn[]
  - `txOuts`: TxOut[]
  - `hash`: 트랜잭션의 고유 식별자

---

## 3단계. **사용되지 않은 출력 관리 구조 정의 (UTXO)**

트랜잭션이 발생한 이후,  
아직 누군가가 사용하지 않은 출력들 → **이게 곧 잔액**

- `UnspentTxOut` 클래스 선언

  - 어떤 트랜잭션에서
  - 몇 번째 출력이었으며
  - 누구(account)의 것이며
  - 얼마(amount)인지

- `UnspentTxPool` 타입 선언
  - 사용되지 않은 TxOut의 배열

---

## 4단계. **트랜잭션 생성을 위한 로직 설계**

이제 위 구조들을 활용해  
실제로 **TxIn을 만들고 → TxOut을 만들고 → 전체 트랜잭션을 조립**합니다.

- `createInput()`

  - 보유한 UTXO 중 필요한 만큼 꺼냄
  - 서명을 넣어 TxIn 배열 생성

- `createOutInput()`

  - 받을 사람과 금액 설정
  - 거스름돈이 있다면 나에게 다시 생성

- `serializeRow()`

  - TxIn + TxOut 조합으로 트랜잭션 해시 생성

- `create()`
  - 위 모든 걸 묶어서 TransactionRow 완성

---

## 5단계. **트랜잭션 처리 이후 상태 변경 설계**

트랜잭션이 발생한 후에는 상태가 바뀌어야 합니다.  
즉, 사용한 UTXO는 제거하고,  
새롭게 생긴 TxOut은 새로운 UTXO로 등록합니다.

- `Unspent.update()`
  - TxOut → 새로운 미사용 출력으로 등록
  - TxIn → 사용된 입력은 제거

---

## 6단계. **트랜잭션 풀 관리**

아직 블록에 포함되지 않은 트랜잭션들을 모아두는 공간입니다.

- `transactionPool` 배열 선언
- `getPool()`, `update()`, `sync()` 메서드 작성

---

## 7단계. **코인베이스 트랜잭션 설계 (보상)**

마지막으로, 채굴 보상을 위한 **특수 트랜잭션** 설계

- `createCoinbase()`
  - 일반 TxIn이 아닌, 블록 높이를 기반으로 TxIn 생성
  - 이전 트랜잭션 참조가 없고, 검증 방식도 다름
  - 입력 없이, 새로운 TxOut 생성 (보상 50코인)
