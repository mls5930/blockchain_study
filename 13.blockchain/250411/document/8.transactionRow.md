# 왜 `TransactionRow`의 `txIns`는 배열일까?

`조상아한테 1BTC 보낸다 나는.`  
모든 노드들:

> "진짜? 너 그만큼 있긴 해? 응 과거 기록 다 뒤져볼게^^"

---

## 먼저, `TransactionRow`가 뭔지부터 짚고 가자.

`TransactionRow`는 **하나의 트랜잭션**,  
즉 **누군가의 하나의 “주장 또는 거래”**를 표현하는 구조입니다.

예를 들어,

> “나는 친구에게 1BTC를 보낼 거야.”  
> 이게 바로 **트랜잭션 한 건**입니다.

블록체인에서는 이처럼 단일한 주장을 `TransactionRow`라는 구조로 담습니다.

> ✅ 블록 = 여러 트랜잭션의 묶음  
> ✅ 트랜잭션 = 하나의 주장 or 명령

---

## 그런데 왜 `txIns`가 **배열**일까?

학생들이 보통 이렇게 질문하죠:

> “하나의 거래인데, 왜 입력이 여러 개죠?”

---

## 이유는 간단합니다.

### 비트코인은 잔액을 **숫자로 저장하지 않기 때문입니다.**

- 우리는 계좌처럼 "100BTC 있음" 이런 식으로 저장된다고 생각하기 쉽지만,
- 비트코인은 그렇게 저장하지 않아요.

대신,

> **과거에 받은 “아직 사용되지 않은 출력들”(UTXO)**  
> = 내가 쓸 수 있는 돈의 조각들

을 따로 들고 있다가,  
**필요할 때 여러 개를 모아서 사용**하는 구조예요.

---

### 📦 예시로 설명해볼게요:

지금 내 지갑에 아래와 같은 UTXO가 있다고 해보세요:

- 0.3BTC (`tx1`)
- 0.4BTC (`tx2`)
- 0.5BTC (`tx3`)

→ 총 1.2BTC가 있죠.

근데 친구에게 1BTC를 보내고 싶다?

> 그러면 이 3개의 조각을 꺼내서,  
> 한 트랜잭션의 **입력(txIns)**으로 넣어야 합니다.

```ts
txIns = [
  { txOutId: "tx1", txOutIndex: 0 }, // 0.3 BTC
  { txOutId: "tx2", txOutIndex: 0 }, // 0.4 BTC
  { txOutId: "tx3", txOutIndex: 0 }, // 0.5 BTC
];
```

그리고 이렇게:

- 친구에겐 1.0 BTC를 `TxOut`으로 보냄
- 나머지 0.2 BTC는 `TxOut`으로 다시 내 지갑으로 돌려받음 (거스름돈)

---

## 정리하면

| 질문                                 | 답변                                                                         |
| ------------------------------------ | ---------------------------------------------------------------------------- |
| 단일 트랜잭션인데 왜 TxIn이 여러 개? | 여러 개의 UTXO 조각을 모아서 써야 할 수도 있어서요.                          |
| 출력도 배열인가요?                   | 네. 거스름돈 보내거나 여러 명에게 분배할 수 있으니까요.                      |
| 왜 이렇게 복잡한 구조인가요?         | 이게 바로 **UTXO 철학**입니다 – 숫자가 아닌 조각 단위로 관리하는 방식이에요. |

---

## 결론

> 트랜잭션 하나는 “하나의 주장”이지만,  
> 그 주장을 하기 위해 여러 개의 조각(입력)을 모아야 하니까  
> `txIns`는 **배열**입니다.

또한 결과도 다양할 수 있어서  
`txOuts`도 **배열**이 되는 거죠.

---

> **1개의 주장 = N개의 입력 + M개의 출력**  
> = 그래서 배열로 표현하는 게 자연스럽고 정확한 구조입니다.

## 잠깐, 그러면 왜 `txOuts`도 배열입니까?

아주 중요한 질문이에요.  
입력(txIns)은 "내가 가진 조각들 중 어떤 걸 꺼내 쓸까?"에 대한 것이고,  
출력(txOuts)은 **"이걸 누가 가져가게 될까?"**에 대한 정보입니다.

---

### 여러 명에게 보낼 수도 있죠?

예를 들어, 내가 1.5BTC를 입력으로 넣었는데

- A에게 1.0BTC 보내고
- B에게 0.3BTC 주고
- 나한테 0.2BTC 거스름돈 돌려주고 싶다면?

→ 이걸 어떻게 표현해야 할까요?

```ts
txOuts = [
  { account: "A", amount: 1.0 },
  { account: "B", amount: 0.3 },
  { account: "나", amount: 0.2 },
];
```

→ 즉, **한 번의 트랜잭션으로 여러 명에게 줄 수 있으니**  
→ `txOuts`도 배열로 되어 있어야 해요.

---

### ✅ 또는 단순히 거스름돈 때문일 수도 있습니다

이건 가장 흔한 상황입니다:

```ts
- 입력 총액: 1.2 BTC
- 친구에게 보낼 금액: 1.0 BTC
- 나머지 0.2 BTC → 나에게 다시 돌아와야 함
```

이럴 때도 **출력이 2개**입니다:

```ts
txOuts = [
  { account: "친구", amount: 1.0 },
  { account: "나", amount: 0.2 }, // change
];
```

---

## 정리: 왜 `txOuts`도 배열일까?

| 상황                       | 이유                                                   |
| -------------------------- | ------------------------------------------------------ |
| 여러 명에게 동시에 보낼 때 | 1개의 트랜잭션에 여러 개의 송금 대상이 필요하니까      |
| 나에게 거스름돈 돌려줄 때  | 출력이 2개 이상 되어야 하니까                          |
| 향후 분배 가능성 고려      | 확장성과 표현력을 위해 배열로 처리하는 것이 자연스러움 |

---

## 그래서 결국 이렇게 기억하면 돼요

> 트랜잭션은 “주장”입니다.
>
> 주장하려면 과거의 **조각들(txIns)**을 꺼내야 하고,  
> 그걸 기반으로 **새로운 조각들(txOuts)**을 만들어야 하죠.

즉,

```sh
1개의 트랜잭션 = 여러 개의 입력(TxIn[]) + 여러 개의 출력(TxOut[])
```

그래서 **둘 다 배열**인 겁니다.
