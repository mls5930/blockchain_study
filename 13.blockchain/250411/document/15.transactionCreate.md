# 여태까지 만든 메서드들을 전부 합쳐서 `create()` 메서드를 만들 거예요

우리는 지금까지 트랜잭션을 구성하기 위해

- **입력(TxIn)**을 만들고
- **출력(TxOut)**을 만들고
- 이 내용을 **직렬화해서 해시로 만드는 과정**까지 구현해왔습니다.

이제 그 모든 과정을 하나로 묶어  
**실제로 트랜잭션을 생성하는 `create()` 메서드**를 완성할 차례입니다.

## 여태까지 했던 흐름 정리

1. **어떤 돈(UTXO)을 쓸지 선택** → `createInput()`
2. **누구에게 얼마를 줄지, 거스름돈은 나에게** → `createOutInput()`
3. **입출력 정보를 조합해서 고유 해시 생성** → `serializeRow()`
4. **트랜잭션 풀에 저장** → 아직 블록에 넣기 전 대기 상태

## 이 `create()` 함수는 뭐 하는 건데요?

> “이 함수 하나로 **트랜잭션 한 건을 완성**합니다.”

- 필요한 입력/출력을 만들고
- 트랜잭션 해시까지 생성하고
- **트랜잭션 풀에 등록**한 뒤
- 완성된 트랜잭션 객체를 리턴합니다.

이제 실질적으로 **실행 가능한 트랜잭션이 만들어지는 시점**이죠.

하지만 이걸 만든다고 해서 실제로 돈이 이동한 건 아닙니다.

아직은 트랜잭션 풀이라는 **대기 장소**에 올라간 상태고,
진짜 거래가 일어나려면 누군가 블록을 채굴해서 이 트랜잭션을 포함시켜줘야 합니다.

즉, 우리는 오늘 수업에서 **"거래가 일어날 준비만 마친 상태"**까지 만든 거예요.

---

## 함수의 사용 시나리오 예

예를 들어 누군가가 다음 요청을 보냈다고 해볼게요:

```ts
{
  signature: '서명정보',
  amount: 10,
  received: 'Alice',
  sender: { account: 'Bob' }
}
```

→ 이 정보를 바탕으로  
Bob이 가지고 있던 UTXO 중에서 10코인을 꺼내  
Alice에게 보내고, 거스름돈은 Bob에게 돌려주는 트랜잭션을 생성합니다.

# `create()` 함수 단계별 구현과 설명

## 1단계. 서명 유무 검사

```ts
if (!receipt.signature) throw new Error("서명이 없습니다.");
```

### 설명:

- 트랜잭션은 **누가 돈을 보내는지 증명하는 서명(Signature)**이 꼭 있어야 합니다.
- 서명이 없으면 누가 요청했는지 알 수 없고, 위조 방지가 불가능해요.
- 그래서 서명이 없으면 아예 트랜잭션 생성을 막습니다.

---

## 2단계. 입력(TxIn) 생성

```ts
const [txIns, amount] = this.createInput(
  unspentTxOuts,
  receipt.amount,
  receipt.signature
);
```

### 설명:

- 보내려는 금액(`receipt.amount`)을 충당하기 위해  
  사용 가능한 UTXO(미사용 출력 목록) 중에서 필요한 만큼 꺼냅니다.
- 이때 만들어지는 `txIns`는
  > “이전의 어떤 트랜잭션의 몇 번째 출력을 사용하겠다”는 선언입니다.
- 동시에 **꺼낸 총 금액(`amount`)도 반환**합니다.
  - 이건 나중에 **거스름돈 계산**에 사용돼요.

---

## 3단계. 출력(TxOut) 생성

```ts
const txOuts = this.createOutInput(
  receipt.received,
  receipt.amount,
  receipt.sender.account,
  amount
);
```

### 설명:

- `txOuts`는 "누구에게 얼마를 줄 것인지"를 나타냅니다.
- 보낼 금액만큼 **받는 사람(received)**에게 보내고,  
  만약 꺼낸 돈이 더 많았다면, **남은 금액은 보낸 사람(sender)**에게 다시 돌려줍니다.
- 즉, 수신자 + 거스름돈 → 여러 개의 `TxOut`이 생성될 수 있습니다.

---

## 4단계. 트랜잭션 조립

```ts
const transaction: TransactionRow = {
  txIns,
  txOuts,
  hash: "",
};
```

### 설명:

- 입력(TxIn)과 출력(TxOut) 정보를 바탕으로 **하나의 트랜잭션 구조**를 만듭니다.
- 이 시점에는 아직 해시가 없습니다.

---

## 5단계. 고유 해시 생성

```ts
transaction.hash = this.serializeRow(transaction);
```

### 설명:

- `txIns`, `txOuts` 정보를 기반으로 문자열로 직렬화하고,  
  그걸 SHA256으로 해시해서 트랜잭션의 **고유한 식별자(hash)**를 생성합니다.
- 이 해시는 블록체인에서 **"이 트랜잭션은 어떤 내용인지"**를 대표하게 됩니다.
- 내용을 바꾸면 해시가 완전히 바뀌기 때문에, **위조 방지 역할**도 합니다.

---

## 6단계. 트랜잭션 풀에 등록

```ts
this.transactionPool.push(transaction);
```

### 설명:

- 아직 블록에 포함되지 않은 트랜잭션은 임시 저장소인 **트랜잭션 풀(transactionPool)**에 저장됩니다.
- 채굴자가 새로운 블록을 만들 때 이 트랜잭션을 꺼내 사용할 수 있어요.

주의!!

### 채굴 과정

1. **블록 후보 생성**

   - 각 노드(개인 컴퓨터)는 스스로 새로운 블록을 만들기 시작합니다.
   - 이때 자신이 보관하고 있는 **트랜잭션 풀 (mempool)** 에서 트랜잭션을 고릅니다.

2. **로컬 환경에서 채굴 진행**

   - 선택한 트랜잭션들과 이전 블록의 해시, difficulty 등을 바탕으로 블록 헤더를 구성하고 nonce를 바꾸며 채굴을 시도합니다.
   - 이 과정은 **로컬 컴퓨터 내부에서만 진행**됩니다.
   - 이 시점에서는 **다른 노드들은 이 블록의 정보에 접근할 수 없습니다.**

3. **채굴 성공**

   - 올바른 nonce 값을 찾으면, 블록의 해시가 조건을 만족합니다.
   - 이때 **해당 블록 전체를 P2P 네트워크에 브로드캐스트** 합니다.

4. **다른 노드들이 검증**
   - 다른 노드들은 블록을 받고, 안에 있는 트랜잭션, 블록 해시, nonce 등이 맞는지 검증합니다.
   - 검증이 끝나면, 해당 블록을 블록체인에 추가합니다.

여기에서 1단계에 채굴자가 트랜잭션들을 골라서 블록 후보를 만드는데,  
오늘 수업 내용인 트랜잭션들을 미리 만들어두고 트랜잭션 풀에 집어넣습니다.  
=> 이 상태는 절때! 거래가 이루어지지 않은 시점입니다!!

---

## 7단계. 최종 트랜잭션 반환

```ts
return transaction;
```

### 설명:

- 이렇게 완성된 트랜잭션 객체를 **외부로 리턴**합니다.
- 이 결과는 블록에 포함되거나, 지갑에서 트랜잭션 상태를 확인하는 데 사용할 수 있어요.
