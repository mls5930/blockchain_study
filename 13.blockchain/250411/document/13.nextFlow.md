## 다음에 필요한 건?

이제 우리는 `createInput()`과 `createOutInput()` 함수를 통해  
트랜잭션의 핵심 데이터인 `txIns`, `txOuts`를 만들었습니다.

> "어떤 돈을 써서 → 누구에게 얼마를 줄 것인지"는 완성된 상태예요.

## 그럼 이걸 어떻게 고유하게 구분할까요?

블록체인에서는 전 세계 수많은 트랜잭션이 동시에 만들어지고 이동합니다.  
이 중에서 **각 트랜잭션을 확실히 구분할 수 있는 고유한 값**이 필요합니다.

그래서 사용하는 것이 바로 **트랜잭션 해시(hash)**입니다.

## **왜 해시가 필요한가요?**

해시는 아래 두 가지 목적을 위해 사용됩니다:

1. **트랜잭션 고유 식별자 역할**  
   → 블록 안에서 트랜잭션을 구분하는 ID가 됩니다.

2. **위조 방지**  
   → 트랜잭션 내용을 살짝만 바꿔도 해시가 완전히 달라지기 때문에  
   → 조작 여부를 즉시 감지할 수 있습니다.

---

## 그런데 그냥 해시할 수는 없어요

중요한 포인트!  
트랜잭션의 `txIns`와 `txOuts`는 **객체(Object)**입니다.

컴퓨터 입장에서 객체는 바로 해시할 수 없어요.  
→ 먼저 **문자열(string)**로 바꿔줘야 합니다.

이걸 바로 **직렬화(serialization)**라고 부릅니다.

> 👉 “데이터를 문자열 형태로 정리해서, 고유한 해시로 변환할 수 있도록 만드는 작업”

---

## 그래서 필요한 함수는?

### 1. `serializeTxOut(txOut: TxOut): string`

- 하나의 TxOut을 문자열로 정리합니다.  
  예: `{ account: 'Alice', amount: 7 }` → `"Alice7"` → SHA256 해시

---

### 2. `serializeTxIn(txIn: TxIn): string`

- 하나의 TxIn을 문자열로 정리합니다.  
  예: `{ txOutIndex: 0 }` → `"0"` → SHA256 해시

---

### 3. `serializeTx<T>(arr: T[], callback: (item: T) => string): string`

> **입력 또는 출력 배열 전체를 직렬화할 때 사용하는 유틸 함수**

- `txIns`, `txOuts` 각각이 배열이니까
- `map()`처럼 하나하나 직렬화하고
- 문자열을 이어붙여서 하나의 문자열로 반환

예를 들어:

```ts
serializeTx(txOuts, serializeTxOut);
```

결과: `"Alice7Bob3"` 처럼 연결된 문자열 → 이걸 해시 처리

---

## 정리하면

> “트랜잭션은 단순히 데이터를 담는 것뿐만 아니라,  
> 그 데이터를 **고유하게 식별할 수 있는 해시 값**으로 만들어야 합니다.  
> 그런데 객체는 바로 해시할 수 없기 때문에,  
> 먼저 문자열로 정리하는 **직렬화** 과정이 필요합니다.  
> 이 직렬화를 통해 만들어진 문자열을 해시로 변환하면,  
> 비로소 블록체인에서 사용할 수 있는 ‘진짜 트랜잭션’이 되는 거죠.”

---

## 흐름 요약

1. `createInput()` → TxIn 생성
2. `createOutInput()` → TxOut 생성
3. 👉 **이제 해시를 만들기 위해**
   - `serializeTxOut()` / `serializeTxIn()` → 각 항목을 직렬화
   - `serializeTx()` → 배열 전체를 문자열로 정리
4. 이 모든 걸 조합해서 `serializeRow()`로 해시 생성
