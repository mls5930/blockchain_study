# 왜 우리는 `UTXO` 같은 구조를 사용할까요?

## 상태가 아닌 **기록으로 증명한다**

은행이나 일반 금융 시스템에서는 보통  
**계좌 기반 모델(Account-based model)**을 사용합니다.  
즉, `내 잔액: 100 → 10 보냄 → 90 남음`처럼  
**계좌의 상태(state)를 직접 갱신하며 관리**합니다.

하지만 이 방식은  
**블록체인이 지향하는 ‘신뢰하지 않는 환경’과 투명성의 철학과는 근본적으로 충돌합니다.**

---

### 왜냐하면...

중앙화된 시스템에서는  
"이 계좌에 왜 90이 남았는가?"라는 질문에 대해  
→ **은행이 전체 기록과 상태를 신뢰 기반으로 보증**해줍니다.  
→ 사용자 입장에서는 ‘그냥 믿으면 되기’ 때문에 기록을 추적할 필요가 없습니다.

하지만 블록체인은 다릅니다.

> **어느 누구도 믿지 않고도, 모두가 검증할 수 있어야 합니다.**

즉, **현재 상태를 받아들이기 위해선,  
그 상태가 어떤 ‘기록들의 결과’인지 추적 가능해야만 합니다.**

`지금 200비트코인 있음!`  
`그래...? 과거 기록 좀 보자 진짜인지`

## ❌ 그런데 계좌 기반 모델은?

계좌 기반 모델은 **현재 잔액 자체를 시스템의 상태(state)로 저장**합니다.

→ "잔액이 90입니다" 라고 하면,  
→ 그 **값이 어떤 트랜잭션들의 결과인지 외부에서 즉시 검증하기 어렵습니다.**

물론 계좌 기반으로 블록체인을 구성할 수는 있습니다.  
하지만 그 경우 **누군가가 상태를 잘못 저장하거나 조작**했을 때,

> **“이 잔액이 왜 이 숫자인지”**  
> 를 **기록만으로는 추적하거나 검증할 수 없습니다.**

## UTXO를 어떤 시각으로 봐야 할까?

### “잔액”이 아니라 “내가 들고 있는 조각들”이라고 생각해야 합니다

> 돈은 단순한 숫자가 아니라,  
> **"과거에 내가 받은 증명 가능한 조각들(Unspent Output)의 목록"**입니다.

## 💡 개발자는 이렇게 바라봐야 한다

> **"내가 얼마를 가지고 있는가?"** 라는 질문이 아니라,  
> **"내가 들고 있는 조각 중 무엇을 꺼내서 조립할까?"** 라는 관점입니다.

이 관점을 이해하면 다음이 자연스럽게 보입니다:

- 여러 개의 `UTXO`를 모아서 여러 개의 `TxIn`을 만들 수 있고,
- 그 결과를 여러 개의 `TxOut`으로 나눌 수도 있고,
- 남는 금액은 거스름돈처럼 **나에게 다시 출력값으로 돌려준다**는 사실까지도.

---

## 그래서 비트코인은 ‘UTXO’ 모델을 선택했습니다

이런 철학을 바탕으로, 비트코인은 “잔액”이라는 상태를 저장하지 않습니다.  
대신, **과거의 기록 중 아직 쓰이지 않은 출력(Unspent TxOut)**만 모아서 잔액을 추산합니다.

```ts
export class UnspentTxOut {
  txOutId: string; // 어떤 트랜잭션의
  txOutIndex: number; // 몇 번째 출력인지
  account: string; // 누구 소유인지
  amount: number; // 얼마인지
}
```

이 구조는 **“내가 사용 가능한 트랜잭션 조각”**을 의미합니다.  
즉, **잔액 = 사용되지 않은 출력값들의 합**입니다.

# 그래서 우리는 이렇게 코드를 구성합니다

이제 여러분은 알 수 있습니다.  
트랜잭션은 단순히 “누가 누구에게 얼마를 보냈다”가 아니라,

> “내가 들고 있는 조각들(UTXO) 중 일부를 꺼내어,  
> 누구에게 어떤 구조로 넘겨주고,
> 그것이 내가 했다는 걸 증명하는 구조”입니다.

그리고 이 구조를 그대로 코드에 옮긴 것이 바로 우리가 작성한 다음의 구성입니다:

| 역할                     | 코드 구조                   | 의미 요약                         |
| ------------------------ | --------------------------- | --------------------------------|
| 내가 어떤 조각을 쓰는가? | `TxIn`, `createInput()`     | 과거의 기록 중 일부를 참조         |
| 누구에게 어떻게 나눌까?  | `TxOut`, `createOutInput()` | 새로운 상태를 설계하고 권한을 부여 |
| 내가 만든 게 맞나?       | `signature`, `publicKey`    | 트랜잭션에 서명하고, 나임을 증명   |
| 결과를 반영하려면?       | `Unspent.update()`          | 사용한 건 제거, 새로 생긴 건 추가  |

이처럼 **UTXO 모델의 철학과 개념**을 이해해야만,  
왜 우리가 `TxIn`, `TxOut`, `UnspentTxOut`, 그리고 `signature` 구조를 이처럼 나누었는지 자연스럽게 받아들일 수 있게 됩니다.

결국 이 구조는 단순한 기술 구현이 아니라,  
블록체인의 **"철학과 검증 방식"을 코드로 실현**한 결과입니다.  
이 시각만 가지면, 코드는 더 이상 복잡하지 않습니다.  
**그저 조립식으로 만들어지는 명확한 주장과 증명의 흐름**일 뿐이니까요.

## 그래서 우리는 이렇게 코드를 구성합니다

이제 여러분은 알 수 있습니다.  
트랜잭션은 단순히 “누가 누구에게 얼마를 보냈다”가 아니라,

> “내가 들고 있는 조각들(UTXO) 중 일부를 꺼내어,  
> 누구에게 어떤 구조로 넘겨주고,
> 그것이 내가 했다는 걸 증명하는 구조”입니다.

그리고 이 구조를 그대로 코드에 옮긴 것이 바로 우리가 작성한 다음의 구성입니다:

| 역할                     | 코드 구조                   | 의미 요약                          |
| ------------------------ | --------------------------- | ---------------------------------- |
| 내가 어떤 조각을 쓰는가? | `TxIn`, `createInput()`     | 과거의 기록 중 일부를 참조         |
| 누구에게 어떻게 나눌까?  | `TxOut`, `createOutInput()` | 새로운 상태를 설계하고 권한을 부여 |
| 내가 만든 게 맞나?       | `signature`, `publicKey`    | 트랜잭션에 서명하고, 나임을 증명   |
| 결과를 반영하려면?       | `Unspent.update()`          | 사용한 건 제거, 새로 생긴 건 추가  |

이처럼 **UTXO 모델의 철학과 개념**을 이해해야만,  
왜 우리가 `TxIn`, `TxOut`, `UnspentTxOut`, 그리고 `signature` 구조를 이처럼 나누었는지 자연스럽게 받아들일 수 있게 됩니다.

결국 이 구조는 단순한 기술 구현이 아니라,  
블록체인의 **"철학과 검증 방식"을 코드로 실현**한 결과입니다.  
이 시각만 가지면, 코드는 더 이상 복잡하지 않습니다.  
**그저 조립식으로 만들어지는 명확한 주장과 증명의 흐름**일 뿐이니까요.
