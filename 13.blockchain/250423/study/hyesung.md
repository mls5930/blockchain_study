# 오늘은 뭐가 어려웠어?

```ts
const tx = {
  from: "increment()함수를 호출한 애",
  to: "해당 CA에게",
  gas,
  gasPrice,
};
```

CA는 가스비 + 기타 등등 값 조합해서 => ETH
얘를 일단 CA가 이치해두고 있어.

## 그럼 그 ETH는 CA가 다 갖는거에요?

아니야.  
=> 검증자/채굴자

---

# 비트코인 네트워크 vs 이더리움 네트워크

채굴 방식이 다른가요?

---

좋은 질문입니다.  
많은 분들이 이렇게 생각합니다:

> “비트코인과 이더리움은 채굴 방식이 다르다!”  
> → ❌ 아니요, **채굴의 '기술적 구조'는 오히려 매우 유사합니다.**

---

## 차이는 "채굴 방식"이 아니라 **보상 구조**에 있습니다.

---

### 비트코인 네트워크

비트코인은 트랜잭션 묶음을 블록으로 만든 후  
→ 그 블록 안에 **“코인베이스 트랜잭션”을 삽입합니다.**

```text
[ 일반 트랜잭션들 ]
+
[ 코인베이스 트랜잭션 (신규 발행 보상) ]
```

- 이 코인베이스 트랜잭션은 **새로운 비트코인을 발행해서 채굴자에게 지급**
- 이 구조는 **전체 네트워크가 합의한 고정된 보상 방식**
- 채굴자가 따로 "사용자에게 돈을 받는" 구조가 아님

> 즉, **네트워크가 알아서 보상을 제공하는 구조**입니다.

---

### 이더리움 네트워크 (Sepolia 포함)

보상의 흐름은 완전히 다릅니다:

```text
[ 일반 트랜잭션들 ]
→ 각 트랜잭션의 실행자(from)가
→ 직접 가스비를 지불
→ 이 가스비가 검증자에게 전달됨
```

- **검증자는 CA로부터 직접 가스비를 수령**합니다.
- 즉, 블록에 포함시켜준 대가로 **검증자가 직접 보상을 받는 구조**입니다.
- 이더리움에서는 **코인베이스 트랜잭션이 기본 보상의 중심이 아닙니다.**

> 즉, **"상태를 변화시킨 사람"이 보상 비용을 지불하는 구조**입니다.

---

## 쉽게 말하면

| 항목              | 비트코인                             | 이더리움                                |
| ----------------- | ------------------------------------ | --------------------------------------- |
| 보상 방식         | 네트워크가 직접 보상 (코인베이스 tx) | 트랜잭션 보낸 사람이 직접 가스비로 보상 |
| 누가 돈을 주나요? | 전체 합의된 구조로 자동 지급         | 사용자가 가스비로 직접 지급             |
| 보상의 철학       | 네트워크 합의로 발행되는 보상        | 상태 변경자 → 검증자에게 직접 보상      |
| 검증자의 위치     | 보상 수령자 (코인 생성자)            | 보상 수령자 (가스 수령자)               |

---

## 핵심 문장 요약

> **비트코인은 채굴 보상이 네트워크에서 자동으로 주어지는 구조**고,  
> **이더리움은 트랜잭션을 발생시킨 사용자가 직접 검증자에게 가스비를 지불하는 구조**입니다.

> 그래서 둘 다 "블록을 만들고 수고한 대가"를 받긴 하지만,  
> **누가 돈을 주느냐 / 어떤 방식으로 주느냐가 완전히 다릅니다.**

=> 배포자는 절대 즉, ETH를 단 돈 0.0000000001도 가져가서는 안되는 구조야.

# 실습은 하였나?

그래서 알고있었어.

그러면 실습을 하려면.

내가 준 실습을 하려면 적어도 하나의 트랜잭션은 발생해야 한다는 뜻

=> increment()를 호출하여야 한다
=> 세폴리아 네트워크

# `tx_report.md` (예시)

---

## 1. 이 컨트랙트는 어떤 역할을 하나요?

Counter.sol 솔리디티 파일입니다.  
스마트 컨트랙트라고 불리는 시점은 해당 컨트랙트가 컴파일하고 배포된 후 => 네트워크에 제 코드가 전파가 되었을때 (걍 내 생각이고 고민해서 나온 결과임 정답을 쓰지말라고 고민을 하라고)  
비로소 수 많은 전 세계 노드들이 제 코드를 실행할 준비가 되었다고 생각합니다.  
저는 이 시점을 스마트 컨트랙트라고 부릅니다.

그래서 교수님이 말씀하신 것 중에서 기억나는게 하나가 있습니다.  
solidty파일 === 스마트 컨트랙트 => 이건 절때 아니라는걸요.  
고민을 한 끝에 답이 나왔고 이게 제 답입니다.

---

## 2. 이 컨트랙트를 블록체인에 올리기 위해 어떤 준비를 했나요?

1. Solidity 코드 작성

2. 연결을 위한 인프라넷 가입후 내 주소를 가져옴 SEPOLIA_RPC_URL => CA

   수정(세폴리아 네트워크에 연결할 수 있는 노드 URL) 내주소 X

3. 만들어진 sol 코드 를 컴파일 하여 abi 와 bin 파일 생성

4. fs.로 컴파일한 파일들을 읽어옴

5. 스마트 컨트랙트를 만들준비 설계도 작성 new web3.eth.Contract(abi);

6. deploy로 실제 실행파일(bytecode,arguments[])로 초기값을 넣어줍니다. deployTx

7. gas와 gasPrice 작성

8. 실제 배포서버 SepoliaETH 서버에 배포하는것이므로 PRIVATE_KEY가 필요
   => 배포할 주체가 누구인지 알기위해 EOA

9. 지갑 생성 및 비밀키 생성

   1. MetaMask 다운
      MetaMask는 브라우저 확장 프로그램 형태의 이더리움 지갑 블록체인과 직접 상호작용을 도와줌

   2. 지갑 계정 생성후 유저계정을 생성
   3. 비밀키발행 SH
      나임을 증명하는 key 이므로 트랜젝션 서명에 사용
   4. 유저계정의 비밀키로 공개키 발행 (secp256k1곡선)
   5. 주소 발행 공개키를 keccak256으로 해시하고 마지막 20바이트 사용

   수정
   address = '0x' + keccak256(publicKey)[-20:]

10. 트렌젝션 작성 및 구조

    from: 트랜잭션을 사용할 사용자의 공개 주소 (address)
    data: deployTx
    기존에는 deployTx 만 넣으면 됬지만 deployTx는 객체상태 이기에 블록체인이 코드를 읽기위해서 encodeABI()로 변환해줘야함
    gas,
    gasPrice
    to: 트랜잭션을 실행시킬 컨트랙트 주소입니다.
    발행시에는 트랜잭션을 실행시킬 주소가 없기에 null이 뜨므로 생략합니다.

    수정:

    "to: 생략" → 정확히는 배포용 트랜잭션에는 to를 생략해야 합니다 ✅
    컨트랙트 호출일 때만 to를 지정합니다.

11. 트렌젝션 서명 signedTx
    만들어진 트랜잭션을 서명합니다. (tx , PRIVATE_KEY)
    타원곡선 알고리즘에 적용하여
    {
    messageHash: '0x...', // 우리가 서명한 해시
    v: '0x1b', r: '0x...', s: '0x...', // 서명 정보
    rawTransaction: '0x...', // 네트워크에 보낼 준비가 된 트랜잭션
    transactionHash: '0x...' // 이 트랜잭션의 고유 ID
    }

12. 발행

    실제 발행을 하기위해서 검증 된 트랜잭선임을 위해 서명이된 트랜잭션임을 증명하는 값인
    receipt.rawTransaction 메서드로 발행을 합니다.

---

## 3. 내가 보낸 트랜잭션의 구조를 설명해보세요

    from: 트랜잭션을 사용할 사용자의 공개 주소 (비밀키로 발행)
    data: deployTx
        기존에는 deployTx 만 넣으면 됬지만 deployTx는 객체상태 이기에 블록체인이 코드를 읽기위해서 encodeABI()로 변환해줘야함
    gas,
    gasPrice
    to: 트랜잭션을 실행시킬 컨트랙트  주소입니다.
    발행시에는 트랜잭션을 실행시킬 주소가 없기에 null이 뜨므로  생략합니다.

---

## 4. 내가 보낸 트랜잭션을 Etherscan에서 분석해보세요

Transaction Hash: 트랜잭션을 식별하는 고유한 해시값 (Tx ID)

Status: 트랜잭션 성공 여부 (Success 또는 Fail)

Block: 이 트랜잭션이 포함된 블록 번호

Confirmations: 현재까지 블록체인에 몇 개의 블록이 더 쌓였는지

Timestamp: 트랜잭션이 블록에 포함된 시간

From: 트랜잭션을 보낸 계정 주소 (EOA)

To: 받는 계정 주소 or 호출된 스마트 컨트랙트 주소

Value: 보낸 이더(ETH)의 양

Transaction Fee: 이 트랜잭션을 위해 실제로 소모된 ETH 총액

Gas Price: 가스 1단위당 지불한 가격 (Gwei 단위)

    Gwei 는 ETH 단위의 10-^9승
    1Gwei 는 0.0000000001 ETH

Gas Limit & Usage: 트랜잭션 실행을 위해 최대 허용치 vs 실제 소모량
실제 소모량이 최대 허용치에 가까울수록 코드 효율이 좋다.

Burnt Fees: EIP-1559 이후 소각된 가스비 (베이스피)

EIP-1559 이후 도입된 Base Fee 소각이란?
EIP-1559는 이더리움이 2021년에 도입한 수수료 개혁 시스템입니다.

핵심 개념: Base Fee Burn

항목 설명
Base Fee 트랜잭션을 블록에 포함시키기 위한 최소 수수료
Priority Fee 채굴자(지금은 블록 프로듀서)에게 주는 팁 (tip)
Total Fee Base Fee + Tip
Base Fee는 자동 소각됨 즉, 그만큼의 ETH는 없어짐 (→ 디플레이션 효과)

Nonce: 이 계정의 트랜잭션 순번 (중복 방지용)

Txn Type: 트랜잭션 유형 (0 = Legacy, 2 = EIP-1559)

Position In Block: 해당 트랜잭션이 블록 내에서 몇 번째 위치인지

Input Data: 컨트랙트 함수 호출에 쓰인 데이터 (인코딩된 ABI)
실제로 호출된 함수의 데이터  
 contract.methods.increment().encodeABI()

---

## 5. 오늘 수업을 통해 내가 얻은 가장 중요한 감각은?

### 퍼블릭 블록체인에서 “살아있는 코드”란?

Counter.sol 솔리디티 파일입니다.  
스마트 컨트랙트라고 불리는 시점은 해당 컨트랙트가 컴파일하고 배포된 후 => 네트워크에 제 코드가 전파가 되었을때 (걍 내 생각이고 고민해서 나온 결과임 정답을 쓰지말라고 고민을 하라고)  
비로소 수 많은 전 세계 노드들이 제 코드를 실행할 준비가 되었다고 생각합니다.  
저는 이 시점을 스마트 컨트랙트라고 부릅니다.

그래서 교수님이 말씀하신 것 중에서 기억나는게 하나가 있습니다.  
solidty파일 === 스마트 컨트랙트 => 이건 절때 아니라는걸요.  
고민을 한 끝에 답이 나왔고 이게 제 답입니다.

### 트랜잭션이란?

서명을 가지고 상태를 변화시키는데 그것에 책임을 지는것

### 가스는 뭔가요?

기본적으로 채굴자에게 주어지는 보상? 수수료?
아 다르고 어 다르다

면접관: 아하~ 그러면 온갖 수수료가 채굴자한테 그냥 가버리는 거네요? 목적이 이거네요?

아......

3가지 관점

1. 가스는 수수료다
2. 탈 중앙화된 네트워크의 복잡도 즉, 네트워크 질서 정립
3. 잘못된 수수료가 든다? => 비정상적인 계산에 의한 수수료다 => 부정 방지

### 나는 어떤 책임을 지고 어떤 결과를 남겼는가?
