우리가 지금까지 뭐 했죠?

- 배포할 컨트랙트 내용을 포장했고,
- 트랜잭션 요청서(tx)를 만들었고,
- 그 요청서에 대해 **"이건 내가 만든 거예요"**라는 **디지털 서명**도 완료했어요.

그러면 이제 남은 건 딱 하나예요:

> **“이걸 진짜 블록체인 네트워크에 보내는 일”**

바로 그걸 해주는 함수가 이거예요:

```js
const receipt = await web3.eth.sendSignedTransaction(signedTx.rawTransaction);
```

---

### 이 코드는 정확히 무슨 일을 하냐면요, 먼저 signedTx부터!

자, 아까 우리가 `signTransaction()`을 호출했을 때,  
이런 식으로 작성했었죠?

```js
const signedTx = await web3.eth.accounts.signTransaction(tx, PRIVATE_KEY);
```

여기서 `signedTx`는 **단순히 문자열 하나**가 아니라,  
**굉장히 중요한 정보를 가진 객체**입니다.

먼저 이 객체를 한번 출력해보면 이런 식으로 생겼어요:

```js
{
  messageHash: '0x...',            // 우리가 서명한 해시
  v: '0x1b', r: '0x...', s: '0x...', // 서명 정보
  rawTransaction: '0x...',         // 네트워크에 보낼 준비가 된 트랜잭션
  transactionHash: '0x...'         // 이 트랜잭션의 고유 ID
}
```

---

### 그럼 여기서 질문 하나:

> “왜 `sendSignedTransaction()`에 `signedTx` 전체를 넣지 않고,  
> `signedTx.rawTransaction`만 넣을까?”

좋은 질문이에요.

---

## `signedTx`는 뭐고? `rawTransaction`은 왜 따로 존재할까?

생각해보세요.  
`signedTx`는 말 그대로

> “내가 어떤 내용을 가지고, 어떤 방식으로 서명했는지”  
> 를 포함한 전체 결과물이에요.

이건 디버깅이나 확인에는 좋아요.  
근데 이걸 네트워크에 그대로 보내면?

- 서명 정보
- 해시 정보
- 내 주소
- 가스 설정  
  → 이걸 전부 별도로 뜯어서 받아야 하잖아요.

---

### 근데 블록체인은 그렇게 안 받아요.

EVM은 복잡한 구조 안 받습니다.  
**오직 하나만 받아요.**

> **“서명된, 실행 가능한 트랜잭션 한 덩어리”**,  
> → 이게 바로 `rawTransaction`

---

### `rawTransaction`이란?

> **서명도 다 끝났고**,  
> **필요한 모든 정보가 이미 인코딩돼 있는**,  
> **"즉시 전송 가능한 바이트 스트림"**입니다.

```js
0xf8a98085012a05f20083015f9094...
```

→ 이 한 줄짜리 문자열 안에  
→ `from`, `to`, `data`, `gas`, `gasPrice`, `nonce`, `signature(r,s,v)` 등  
→ **모든 정보가 16진수로 압축되어 있음**

---

### 그래서 결론은?

> `signedTx`: 우리가 서명한 전체 정보 묶음 (분석용, 디버깅용)  
> `rawTransaction`: 실제 네트워크에 보내는 실행 가능한 바이너리

→ 그래서 우리는 이걸 이렇게 쓰는 거예요:

```js
await web3.eth.sendSignedTransaction(signedTx.rawTransaction);
```

---

### 비유로 말하면?

- `signedTx`는 **계약서 + 서명된 종이 + 초안까지 포함된 전체 파일**
- `rawTransaction`은 **최종본 PDF 한 장**  
  → 딱 그거 한 장만 제출하면 됩니다.

---

### 핵심 요약:

> **`rawTransaction`은 EVM이 즉시 실행할 수 있는  
> 압축된 실행 명령 덩어리다.**  
> 그래서 그걸 `sendSignedTransaction()`에 넣는 거고,  
> 전체 `signedTx` 객체는 로그 확인이나 분석용일 뿐이에요.

→ 이걸 그대로 네트워크에 **브로드캐스트**(broadcast)합니다.  
→ 즉, 네트워크의 모든 노드에게 **“이거 좀 처리해줘요!”**라고 퍼뜨리는 거예요.

---

### 그리고 이걸 받은 네트워크는 어떻게 반응하냐면?

- 먼저, 이 서명이 유효한지 확인해요.
  → "이 서명은 실제로 이 주소의 개인키로 만들어졌나?"
- 그다음, 가스가 충분한지, 실행 가능한지 확인하고,
- 조건을 만족하면 **블록에 포함시켜요.**

이제 진짜 상태가 바뀌고,  
그 결과가 **Etherscan 같은 블록 익스플로러에 기록**되는 거예요.

---

### 여기서 아주 중요한 감각 하나

> 우리는 지금까지 코드만 짰던 게 아니에요.  
> 이제부터는 **내가 만든 코드가 진짜 블록체인에 기록**돼요.  
> 누가 언제, 어떤 방식으로, 어떤 주소로 실행했는지가  
> 전 세계 노드에 **영구적으로 저장**돼요.

---

그리고 마지막 이 `receipt` 안에는  
우리가 보낸 트랜잭션의 결과가 담겨 있어요:

- contractAddress (컨트랙트가 실제로 배포된 주소)
- transactionHash (트랜잭션 ID)
- blockNumber (어느 블록에 포함됐는지)

---

### 한 줄 요약:

> **`sendSignedTransaction()`은 내가 책임지고 만든 트랜잭션을  
> 진짜 블록체인에 broadcast해서,  
> 영구히 기록되도록 만드는 함수다.**
