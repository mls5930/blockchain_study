## 1단계: 왜 지갑 구조를 추상화해야 할까?

### 왜 필요할까?

블록체인에서 '지갑'이란 단어를 들으면 대부분 ‘코인 보관함’이라고 생각하기 쉽습니다.  
하지만 **진짜 지갑의 역할은 "서명 가능한 나의 정체성을 증명하는 구조"**입니다.

나는 누구인지 증명할 수 있어야 하고  
그 증명이 위조될 수 없어야 하며  
언제든 새로운 정체성을 만들 수도 있어야 합니다.

이 역할은 단순한 문자열 몇 개로 해결되는 일이 아니며,  
그 안에는 비밀키, 공개키, 서명 메서드 등 다양한 기능이 들어갑니다.

**블록체인에서의 지갑은 단순히 현실 세계의 지갑이 아닙니다.**

**‘나’ 자신을 증명하고, 그 증명이 진짜임을 보일 수 있으며, 그 검증에 필요한 서명을 생성하는 도구들의 집합**이라고 보는 것이 더 정확합니다.  
즉, 지갑은 **"디지털 나"를 위한 암호학적 증명 툴킷**입니다.

그리고 우리는 이후에 이런 기능을 다음과 같이 다루게 됩니다:

- `getPublicKey()`: 내 공개키를 조회
- `sign(data)`: 어떤 데이터에 서명
- `verify(signature, data)`: 해당 서명이 진짜인지 검증

하지만 만약 Wallet 클래스가 커지고 복잡해진다면,  
어떤 메서드를 반드시 구현해야 하는지 기준을 잃기 쉽습니다.

그래서 우리는 우선 "지갑의 공통된 동작 규약"을 먼저 정의해야 합니다.  
이걸 인터페이스(interface) 또는 **추상화(abstraction)**라고 합니다.

> 즉, 우리는 지금부터 "지갑이라면 반드시 갖춰야 할 능력"을 선언할 것입니다.  
> 앞으로 여러 형태의 Wallet이 생기더라도, 이 규약만 지키면 됩니다.

## 무엇을 정의할까?

```ts
import { SignatureInput } from "elliptic";

// 보내는 사람
export class Sender {
  publickKey: string;
  account: string;
}

// 영수증
export class Receipt {
  sender: Sender;
  received: string;
  amount: number;
  signature: SignatureInput;
}

// 내 계정
export class Accounts {
  privateKey: string;
  publicKey: string;
  account: string;
  balance: number;
}
```

---

## 각 클래스와 속성 설명

### `Sender`

트랜잭션을 보낼 때, **보낸 사람의 정체성**을 명확하게 담기 위한 구조입니다.  
이때 중요한 것은, **비밀키는 절대 외부에 노출되어서는 안 된다는 점**입니다.  
그래서 `Sender` 클래스에는 오직 아래 두 정보만 담깁니다:

- `publickKey`:  
  → 해당 트랜잭션이 누구로부터 시작되었는지를 증명하는 공개키입니다.  
  → 트랜잭션 서명을 검증할 때 이 키가 필요합니다.

- `account`:  
  → 실질적으로 거래 시 식별에 사용되는 **계정 주소**입니다.  
  → 공개키에서 유도된 값으로, 네트워크에서 “누구의 자산인가”를 가리킬 때 사용됩니다.

> Sender는 ‘나’를 대변하지만, 민감한 정보는 숨기고 필요한 정보만 전달하는 **트랜잭션용 신원 정보 객체**입니다.

---

### `Receipt`

실제 거래 행위를 표현하는 객체입니다.  
누가 누구에게 얼마나 보냈고, **그 증거로 어떤 서명을 남겼는가**를 기록합니다.

- `sender`:  
  → 앞서 정의한 `Sender` 클래스. 즉, 트랜잭션의 출발지입니다.

- `received`:  
  → 받는 사람의 **계정 주소(account)**.  
  → 공개키나 비밀키가 아닌, 순수 식별용 문자열입니다.

- `amount`:  
  → 송금하려는 **금액**입니다.

- `signature`:  
  → 이 트랜잭션이 실제로 `sender`가 보낸 것이 맞는지를 증명하기 위한 **디지털 서명**입니다.  
  → `sender.publicKey`를 이용해 서명의 진위를 검증할 수 있습니다.

> Receipt는 하나의 **완성된 거래**를 나타냅니다.  
> 누가 → 누구에게 → 얼마를 → 어떻게 증명하며 보냈는지를 모두 담고 있죠.

---

### `Accounts`

이제 진짜 지갑, 즉 **사용자 본인의 키와 자산을 관리하는 본체**입니다.  
실제 트랜잭션을 만들고 서명하는 주체이며, 개인 정보와 자산을 모두 가지고 있습니다.

- `privateKey`:  
  → 절대 외부에 노출되어서는 안 되는 **개인의 비밀키**입니다.  
  → 이 키를 이용해 서명을 생성합니다.

- `publicKey`:  
  → `privateKey`로부터 생성되는, 외부에 공개 가능한 나의 정체성입니다.  
  → 다른 사람이 내 서명이 맞는지 검증할 때 이 키를 사용합니다.

- `account`:  
  → 블록체인에서 내 자산을 조회하거나, 누가 송금받을지를 지정할 때 사용하는 **계정 주소**입니다.  
  → 일반적으로 `publicKey`로부터 해시 또는 압축 방식으로 생성됩니다.

- `balance`:  
  → 이 지갑이 현재 보유하고 있는 **자산의 양**입니다.  
  → 보통 블록체인에서는 트랜잭션과 블록 처리를 통해 갱신됩니다.

> Accounts는 **나 자신을 표현하는 핵심 객체**입니다.  
> 거래를 만들고 서명하며, 잔액을 추적하고, 주소를 통해 외부와 연결됩니다.
