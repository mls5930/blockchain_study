## 공개키는 어떻게 만들어질까?

### 전제:

우리가 앞에서 만든 **비밀키**는 이렇게 생긴 문자열이야:

```ts
privateKey = "d4fcb00d990f4443d349472a946bd042d4f0db17b1306e8fcc545f94a13c6fcb";
```

이건 단순한 문자열처럼 보이지만, 사실은

> **정수값 (BigInt)** 으로 보면 엄청나게 큰 숫자야.

이걸 기반으로 "공개키"라는 걸 만들어야 해.

---

## 공개키 공식

> 공개키 = G × 비밀키

- G: **타원 곡선 상의 기준점 (generator point)** => 누구나 아는 공통된 시작 지점
- 비밀키: 우리가 만든 **정수값**
- ×: 그냥 곱셈 아님! → **타원 곡선 위에서의 점 덧셈 반복** => 아까 만든 비밀 키의 정수 만큼

---

## 코드 흐름 설명 (한 줄씩)

```ts
const keypair = ec.keyFromPrivate(privateKey);
```

### 무슨 의미?

- `ec`는 우리가 secp256k1 곡선을 사용하고 있다는 객체
- `keyFromPrivate()`는 이 곡선 위에서  
  → 비밀키를 기반으로  
  → **공개키까지 계산된 keypair 객체**를 만들어 줌

> 이 `keypair` 안에는 비밀키 + 공개키 둘 다 있음  
> → 단, 우리는 공개키만 뽑아서 쓰는 거야.

---

```ts
publicKey = keypair.getPublic().encode("hex", true);
```

### 이건 뭐냐?

- `.getPublic()` : 공개키 좌표 (`x`, `y`)를 가져옴
- `.encode("hex", true)` :  
  → 공개키를 **압축된 33바이트 형태로 인코딩**  
  → 우리가 보는 66자리짜리 문자열이 나옴

여기서 `"true"`를 넣는 이유는?  
→ 압축된 공개키를 쓰기 위해서  
→ `03 + x좌표` 또는 `02 + x좌표` 형태로 간결하게 표현

---

## 예시 출력

```ts
공개키 (압축형): 034f355bdcb7cc0af728ef3cceb9615d906a3c5a8231804d1c99d0be2eb1e5c17e
길이: 66 (16진수 문자 기준)
```

---
