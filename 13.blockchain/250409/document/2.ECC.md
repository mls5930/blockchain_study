# 그런데... 나라는 걸 어떻게 증명하죠?

블록체인에서 지갑은 곧 ‘나 자신’을 뜻합니다.  
그렇다면, 내가 진짜 나라는 걸 어떻게 증명할 수 있을까요?

> “이 거래는 내가 보낸 게 맞습니다!”  
> 라고 주장하려면, 누가 봐도 믿을 수 있는 **‘나만의 도장’**이 필요합니다.

하지만 블록체인은 중앙기관이 없습니다.  
즉, 나라나 은행이 이 도장을 찍어주지 않죠.

그래서 우리는 **도장 자체를 수학으로 만들기로 했습니다.**

- 누구나 검증할 수 있어야 하고,
- 오직 나만 만들 수 있어야 합니다.

이 구조를 가능하게 만드는 수학이 바로 **ECC(Elliptic Curve Cryptography)** 입니다.

# ECC란? 수학이 만든 신뢰

블록체인은 신뢰를 만드는 기술입니다.  
하지만 **그 신뢰는 사람이나 기관이 아닌, 수학으로 만들어집니다.**

> 핵심은 단순히 수학으로 풀었다는 게 아닙니다.  
> **누구나 같은 방식으로 증명 결과를 확인할 수 있다는 것**입니다.

ECC는 이런 구조를 수학적으로 만들어주는 기술입니다.

## 기존 세상에서의 신뢰

- 주민등록증은 **국가가 발급**합니다.
- 돈은 **중앙은행이 보증**합니다.
- **우리는 중앙이 만든 체계 안에서 신뢰**를 유지해왔죠.

하지만 블록체인은 **그 모든 걸 거부합니다.**

- `나는 나를 스스로 증명할 수 있어야 해.`
- `그리고 누구나 그걸 검증할 수 있어야 해.`

이걸 가능하게 하기 위해, 블록체인은 **수학**을 선택했습니다.

## ECC는 왜 쓰이나요?

ECC는 다음과 같은 특징을 갖고 있습니다:

- **위조 불가능**: 나만 만들 수 있는 ‘도장’ (비밀키)
- **검증 가능**: 누구나 확인할 수 있는 ‘열쇠’ (공개키)
- **효율적**: 짧은 키, 빠른 속도, 낮은 연산 부담
- **안전한 단방향성**: 공개키로는 절대 비밀키를 알 수 없음

즉, **중앙이 없이도 ‘신뢰’를 만들 수 있는 구조**.  
이게 ECC가 블록체인에서 선택된 진짜 이유입니다.

### 왜 그렇게 말씀하시죠? 왜 ECC의 구조는 `비효율적`이에요?

- 우리는 비밀키에서 공개키를 만들기 위해 **타원곡선 곱셈**이라는 무거운 수학 연산을 씁니다.
- 이 연산은 한쪽 방향(비밀키 → 공개키)은 쉽지만, 역방향(공개키 → 비밀키)은 사실상 불가능합니다.

이건 효율을 포기한 구조입니다.  
우리는 쉬운 연산을 일부러 복잡하게 만들었습니다.

왜?

**그 누구도 나를 대신할 수 없게 만들기 위해서입니다.**
=> 나를 검증하는건 나라나 기관, 심지어 한 사람도 맡길 수 없고 내가 만들어낸 수학적 문자열 하나에게 맡기겠다.  
=> 그리고 내가 보관할거야!

## ECC는 블록체인만의 기술인가?

아닙니다!  
ECC는 원래 블록체인 이전부터 존재했던 범용 암호화 기술입니다.

- 스마트 카드, 브라우저 보안(HTTPS), 군사 통신, 인증서 등등
- 이미 수많은 산업에서 사용되던 표준화된 공개키 암호 시스템 중 하나였습니다.

=> 즉, **블록체인이 새롭게 만든 기술이 아니라,**
**신뢰할 수 있는 수학적 기술 중에서 가장 효율적인 것을 선택한 것**입니다.

## 블록체인은 왜 ECC를 선택했을까?

블록체인이 ECC를 선택한 이유는 다음과 같은 조건에 딱 맞기 때문입니다

- 누구나 서명을 검증할 수 있어야 함: 공개키로 검증 가능
- 오직 본인만 서명할 수 있어야 함: 비밀키로만 서명 가능
- 수많은 지갑이 존재해야 함: 256비트 키 → 천문학적 조합 가능
- 모바일/브라우저 환경에서도 사용돼야 함: 짧은 키, 빠른 속도
- 수학적으로 위조 불가능해야 함: 타원곡선 역산은 불가능에 가까움

즉, 블록체인은 **기술이 아니라 조건에 따라 ECC를 선택한 것**

자 그럼, 이 타원 곡선은 어떻게 동작할까?

## secp256k1: 우리가 쓰는 타원곡선은 어떻게 동작할까?

**이건 ECC 안에서도 “우리 반” 이름이에요**

- ECC는 여러 종류가 있어요. 그 중에서도 **비트코인과 이더리움은 `secp256k1`이라는 타원곡선을 씁니다.**

### 이게 뭔데 씹덕아

`secp256k1`는 수학자들이 만든, 전 세계 공통의 곡선입니다.

- 이건 수학적으로 정의된 곡선 하나를 가리키는 이름이에요.
- 마치 “3반 2조”처럼, 수학 책에서 7번 문제에 나오는 곡선이라 생각해도 좋습니다.

### secp256k1의 수학적 정의

ECC는 수학입니다. 그리고 수학은 공식으로 말하죠.

```sh
y² = x³ + ax + b
```

어우...어지럽죠?  
이게 타원 곡선의 기본 형태에요.  
이건 그냥 **곡선의 모양을 정의하는 수학 공식이에요**

#### x, y는 무엇을 의미하나?

- x와 y는 그냥 **그래프 위의 점 좌표**입니다.  
  예: (x, y) = (3, 5) 이런 식
- 이 방정식은 **x 값을 넣으면, y값이 어떤 모양으로 나오는지**를 그리는거에요

즉, 이 공식을 만족하는 점(x, y)들이 모이면 `곡선` 이 그려지는 것

#### x³ + ax + b는 뭐예요?

- x³: x를 세 번 곱하는 거예요 → **x³ = `x * x * x`**
- ax: x에다가 a를 곱하는 것
- b: 그냥 상수

즉, x값을 정해 넣으면 y² 값이 나옵니다.  
그걸로 y도 구할 수 있죠.

#### 곡선인건 알겠어요. 근데 왜 이런 곡선을 쓰나요?

이 곡선 위의 점들끼리 **특별한 덧셈 연산**을 정의할 수 있기 때문이에요.

- 기준점 G를 계속 더하면
- 곡선 위의 다른 점들이 나옵니다
- 예: G + G + G + G + … = 어떤 새로운 점 (이게 공개키 계산 방식이에요!)

#### 그럼 a=0, b=7은 뭔가요?

- ECC는 수많은 곡선 중에서 **하나** 를 골라 써야 합니다.
- 비트코인과 이더리움은 `secp256k1`이라는 **곡선**을 씁니다

이게 바로 **타원 곡선 위에서만 가능한 특별한 구조**입니다.

`secp256k1`에서는

- a = 0
- b = 7
- 그래서 공식은 `y² = x³ + 7`

그리고 **모두가 공유하는 기준점 G**가 존재합니다

- 이 G는 곡선 위의 하나의 점이고,
- G의 좌표(x, y)는 모두 16진수로 정해져 있습니다.
- => 누구나 이 G를 알고 있어야 합니다.

## ECC에서 키는 어떻게 만들어질까?

### 1단계: 비밀 키 (PrivateKey)

- 그냥 무작위로 만든 **큰 숫자**입니다. (예: 256비트 정수)
- 진짜 그냥 랜덤한 문자열이에요.

### 2단계: 공개 키 (PublicKey)

- ECC의 핵심

> 공개키 = 비밀키 X G

- 이건 단순 곱셈이 아니라, 곡선 위의 점들을 계속 더해가는 방식이에요.
  예를 들어 G를 두 번 더하면 2G, 세 번 더하면 3G...
  이런 식으로 개인키만큼 G를 더한 결과가 공개키입니다.
- 이 연산은 단방향입니다.
  - 비밀키 => 공개키 = 가능
  - 공개키 => 비밀키 = 거의 불가능

## 서명은 어떻게 할까?

이제 진짜 거래가 발생했을 때, 우리는 어떻게 서명을 할까요?

### 1. 트랜잭션을 정리 => 해시(z)

```sh
"나는 친구에게 1BTC를 보낸다"
→ SHA-256 해싱 → z
```

### 2. 서명에 사용하는 변수들

- k: 서명에만 잠깐 쓰는 랜덤값 (한 번용 펜)
- G: 모두가 아는 기준점
- r: k × G 연산의 결과 중 x 좌표값 → 첫 번째 서명값
- s: 트랜잭션 해시(z)와 개인키를 조합한 수학적 결과 → 두 번째 서명값
- v: 서명 검증 시, 공개키를 복원할 수 있도록 도와주는 값 (Ethereum에서 주로 사용)

### 3. 정리하면 이렇게

```sh
서명 = (r, s, v)
```

- 이 서명은 내 공개키를 알고있다면 누구나 검증할 수 있어요.
- 이 서명으로부터 **트랜잭션 내용이 위조되지 않았다는 것**을 증명할 수 있습니다.

## 검증은 어떻게 하죠?

- 받는 사람(또는 네트워크)은

1. 트랜잭션 내용을 해시 => z
2. 서명 (r, s) + 공개키를 이용해서, 수학적으로 서명이 맞는지 검증

**비밀키 없이도 서명이 맞는지 검증 가능** => 이게 ECC의 매력입니다

## 머리가 너무 아픕니다...ㅠ 그래서 타원 곡선을 우리가 구현하나요?

하하. 당연히 아니죠.  
놀랍게도 사용하기 편하게 라이브러리가 제공됩니다.

### 라이브러리 설치

```sh
npm i elliptic @types/elliptic
```

- elliptic은 우리가 ECC 연산을 쉽게 할 수 있도록 도와주는 라이브러리입니다.
- 이걸로
  - 비밀키 생성
  - 공개키 생성
  - 서명/검증
  - 전부 할 수 있습니다.

## 결론

이거 수학식이니까 어렵게 느껴지는데, 사실 중요한 건 딱 하나야.  
secp256k1에서는 공식을 y² = x³ + 7로 고정해놓고,  
이 곡선 위에서 점들을 더하고 곱하면서 **비밀키랑 공개키 계산**하는 구조를 만든 거야.
