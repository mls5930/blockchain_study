## 2단계: `getPrivateKey()` — 지갑의 출발점, 비밀키 생성

### 왜 필요할까?

지갑은 단순한 보관함이 아니라,  
**‘나’를 증명하고, 내가 만든 거래임을 입증할 수 있게 해주는 도구**야.  
그 출발점은 바로 **비밀키 (Private Key)** 다.

비밀키는 절대 외부에 공개되어서는 안 되며,  
지갑의 **핵심 정체성**, 그리고 **서명의 출발점**이야.

즉, **비밀키가 없다면 지갑도 없다.**  
지갑의 존재 이유는 결국 “서명 가능한 나”를 증명하는 것이고,  
이 서명은 모두 비밀키로부터 만들어지기 때문이야.

> 📌 우리는 이 비밀키를 암호학적으로 안전하게 생성해야 해.  
> 예측할 수 없고, 충돌이 없어야 하니까.

---

### 무엇을 구현할까?

우리가 만들 `getPrivateKey()` 함수는  
암호학적으로 안전한 **32바이트의 랜덤 값을**  
16진수 문자열(`hex`)로 반환하는 함수야.

이 값은 지갑이 생성될 때 자동으로 호출되어  
**지갑의 핵심 정체성**을 구성하게 돼.

---

### 코드 예시

```ts
import { randomBytes } from "crypto";

getPrivateKey(): string {
  return randomBytes(32).toString("hex");
}
```

---

### 설명

- `crypto.randomBytes(32)`  
  → 암호학적으로 안전한 32바이트(256비트)의 무작위 값 생성  
  → 이 길이는 ECC(secp256k1)에서 요구하는 개인키 길이와 일치함

- `.toString("hex")`  
  → 저장과 전송에 용이하도록 16진수 문자열로 변환

> 이 함수는 지갑이 새로 생성될 때만 사용돼.  
> 기존 지갑을 복원할 땐 외부에서 비밀키가 들어오므로 사용되지 않음.

---

### 확인 방법 (TDD 기준)

```ts
const wallet = new Wallet();
const pk = wallet.getPrivateKey();

console.log(pk.length); // 64
console.log(/^[a-f0-9]{64}$/.test(pk)); // true
```

- 문자열 길이: **64자리**
- 형식: **16진수 문자만 포함**
- 재실행 시마다 값이 달라야 함 → **무작위성 확인**

---

### 다음 단계 예고

우리는 이제 이 **비밀키로부터 공개키를 생성**할 준비를 하게 돼.  
3단계에선 **타원곡선 암호(ECC)**를 이용해  
공개키를 도출하는 과정을 살펴볼 거야.
