## 그래서... 그 블록은 도대체 `어떻게` 생긴 거죠?

지금까지 우리는 “내가 하버드생이다” 같은 정보를 블록에 담고,  
다른 사람들(컴퓨터, 노드들)이 그걸 검증한다는 비유로 블록체인을 이해해봤어요.

---

그럼 이제 이런 생각이 들 수 있죠.

> “그냥 데이터만 넣으면 되는 거 아냐?”

맞아요. 실제로 아래처럼 단순한 데이터로도 블록을 만들 수 있어요.

```sh
나 사실 엄준식임.
나 하버드 나왔음.
나 B에게 1BTC 보냈음.
```

그냥 이런 걸 파일에 저장해도 되잖아요?

---

## 그런데 블록이 많아지기 시작합니다.

블록이 하나일 땐 문제가 없었어요.
근데 이게 10개, 100개, 10,000개가 되면?

**시간이 지나면서 블록은 점점 더 많아지고**,
거래도 많아지고, 사람들이 더 많이 사용하게 됩니다.

그때부터 생각이 드는 거예요.

> “이렇게 계속 블록이 많아지면… 어떻게 정리하지?”
> “이게 진짜 맞는 블록인지 어떻게 알아?”
> “언제 만들어졌는지, 누구와 관련된 건지,
> 중간에 누가 바꾸진 않았는지… 어떻게 알지?”

---

## 그래서 필요한 정보들이 하나씩 생겨나기 시작합니다.

블록은 처음엔 단순한 정보 덩어리였지만,
현실적인 문제를 하나씩 마주하면서 **“아, 이게 필요하겠는데?”** 하고
속성이 하나하나 추가됐어요.

---

### 블록 속성들이 추가됨

1. `data`:
   → 일단 정보가 있어야 하니까. “나 엄준식임” 같은 거래나 사실들.

2. `timestamp`:
   → 이 블록이 **언제** 만들어졌는지는 꼭 필요하겠죠. 시간 순서를 알아야 하니까요.

3. `version`:
   → 블록 구조가 나중에 바뀌면? “나는 어떤 규칙으로 만들어졌는지”를 표시해줘야 해요.

4. `previousHash`:
   → 이 블록이 **어떤 블록의 다음**인지를 알려줘야 해요. 그래야 순서를 알고, 체인으로 연결되죠.

5. `merkleRoot`:
   → 블록 안에 거래가 수십, 수백 개씩 있으면,
   하나라도 바뀌었는지 **빠르게 검증할 수 있는 요약 해시**가 필요해요.

6. `nonce`:
   → 블록 생성자가 퍼즐(난이도 조건)을 풀기 위해 계속 바꿔보는 값이에요.

7. `difficulty`:
   → 퍼즐이 얼마나 어려운지를 수치로 나타내는 값. 즉, 난이도 설정.

8. `hash`:
   → 이 블록 자체의 **디지털 지문**.
   블록의 모든 정보가 반영된 해시값이라서, 이게 바뀌면 "위조!"라고 외칠 수 있어요.

9. `transactions`:
   → 이 블록 안에 실제로 들어가는 **거래들**. 우리가 보호하고자 하는 진짜 데이터.

---

## 정리하면:

> “현실에서 마주친 문제들을 해결하다 보니,
> 블록 구조가 자연스럽게 복잡해진 거예요.”

---

이제 이 구조를 이해했으니

- 우리가 직접 블록을 만들고
- 체인을 구성하고
- P2P로 노드끼리 동기화하고
- 나중엔 채굴 조건까지 구현할 수 있게 됩니다.

---

# 비트코인이랑 무슨 연관이 있느냐?

블록체인 기술이 탄생하게 된 목적중의 하나가 비트코인이라는 전자화폐를 제한하기 위해서  
탄생한거다.
