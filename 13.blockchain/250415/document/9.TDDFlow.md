# TDD 흐름 해설: **코인베이스부터 트랜잭션 반영까지**

## 사전 세팅 단계

우리는 지금 "블록 생성 과정 전체"를 테스트하려고 한다.  
그렇기 때문에, 먼저 필요한 환경과 객체들을 준비해야 한다.

### 1. 테스트에 사용할 기본 클래스 선언

```ts
let transaction: Transaction;
let unspent: Unspent;
```

- **`Transaction` 클래스**: 트랜잭션을 생성하고 풀에 저장하는 기능을 담당한다.
- **`Unspent` 클래스**: 잔액(UTXO)을 저장하고 갱신하는 기능을 담당한다.

> 왜 미리 선언하나?  
> 모든 테스트가 공통적으로 이 객체들을 사용하기 때문이며,  
> `beforeEach()` 안에서 매번 새롭게 인스턴스를 만들어 **독립적인 테스트 환경**을 유지하기 위해서이다.

---

### 2. 사용할 지갑 주소 정의

```ts
const bob = "0x" + "b".repeat(38);
const alice = "0x" + "a".repeat(38);
const miner = "0x" + "m".repeat(38);
```

- **bob**: 보내는 사람 (7코인 전송)
- **alice**: 받는 사람
- **miner**: 블록을 생성하는 채굴자 (보상을 받음)

> 원래는 비밀키에서 공개키를 파생시키고,  
> 거기서 지갑 주소를 만들어야 하지만...  
> 수업에선 **전체 흐름을 이해하는 게 더 중요하기 때문에**  
> → 간단하게 문자열로 지갑 주소를 선언한 것이다.

---

### 3. 테스트 시작 전 실행되는 `beforeEach()`

```ts
beforeEach(() => {
  transaction = new Transaction();
  unspent = new Unspent();
```

- 테스트 하나가 실행될 때마다,
- **새로운 `Transaction`, `Unspent` 객체**를 만들어 초기화한다.
- 테스트 간 상태가 섞이지 않도록 하기 위한 기본 세팅이다.

---

### 4. Bob의 개인키, 공개키 생성

```ts
privateKey = crypto.randomBytes(32).toString("hex");
const keyPair = ec.keyFromPrivate(privateKey);
publicKey = keyPair.getPublic().encode("hex", true);
```

- Bob은 트랜잭션을 만들 때 **자기 소유의 UTXO를 증명**해야 한다.
- 이를 위해서는 **자기만 알고 있는 비밀키**가 필요하다.
- `elliptic` 라이브러리를 활용해서 secp256k1 곡선 기반의 키 쌍을 만든다.

> 왜 이걸 하냐면?  
> 트랜잭션에 필요한 **디지털 서명(signature)** 을 만들기 위해서다.

---

### 5. 서명(signature) 생성

```ts
const hash = SHA256("tx test").toString();
signature = keyPair.sign(hash, "hex");
```

- 일단은 임의의 문자열을 해시한 뒤 서명을 만든다.
- 진짜 트랜잭션에서는 `TxOut` 내용을 직렬화한 값으로 해시를 만들겠지만,
- 여기서는 단순히 **서명 테스트**만을 위한 시나리오이기 때문에  
  → `"tx test"` 문자열을 사용한 것이다.

---

### 6. Bob이 가진 초기 잔액(UTXO) 설정

```ts
const txOuts: TxOut[] = [
  { account: bob, amount: 5 },
  { account: bob, amount: 5 },
];
txOuts.forEach(unspent.create("init"));
```

- Bob은 총 10코인을 가지고 있다고 가정한다. (5 + 5)
- `Unspent` 클래스에 초기 트랜잭션 ID `"init"`을 기반으로 미사용 TxOut을 등록한다.

> 왜 직접 잔액을 추가하나?  
> 우리는 블록을 채굴한 적도 없고, 이전 블록도 없기 때문에  
> → "초기 상태를 수동으로 구성"해서 테스트하는 것이다.  
> 즉, **보상 받은 것처럼 가장한 미사용 잔액**을 직접 추가했다.

## 1단계: 코인베이스 트랜잭션 생성

### 목적

우리는 지금 "블록을 생성한다"는 시나리오를 다루고 있다.  
블록을 만들려면 가장 먼저 **보상 트랜잭션(코인베이스 트랜잭션)** 을 생성해야 한다.

왜냐하면:

- 블록을 채굴한 채굴자에게 보상을 주는 것이  
  Proof of Work 기반 시스템의 **합의된 규칙**이기 때문이다.
- 이 보상은 아무도 주는 게 아니다.  
  → **채굴자가 직접 트랜잭션으로 적어야 한다.**

## 그래서 어떤 코드가 필요했나?

### `createCoinbase(miner, height)` 메서드

```ts
const coinbaseTx = transaction.createCoinbase(miner, height);
```

이 코드는 내부적으로 다음 작업을 수행한다:

- `txIn`: 참조하지 않는 입력값 (height + 1)
- `txOut`: 채굴자 주소로 보상 지급
- `hash`: 고유 트랜잭션 식별자 생성

### 우리가 검증하고자 했던 것

```ts
expect(coinbaseTx.txOuts[0].account).toBe(miner);
expect(coinbaseTx.txOuts[0].amount).toBe(50);
```

- **누가 보상을 받는가? → 채굴자 주소인지 확인**
- **얼마를 받는가? → 50코인인지 확인**

```ts
expect(coinbaseTx.txIns[0].txOutId).toBeUndefined();
expect(coinbaseTx.txIns[0].signature).toBeUndefined();
```

- **코인베이스 트랜잭션은 누구의 잔액도 참조하지 않음**
- 입력값(TxIn)은 단지 형식만 유지하고 있음
  → 그래서 `txOutId`, `signature`는 **없어야 한다**

### 이 테스트가 반드시 필요한 이유

- **블록체인 시스템은 보상 설계를 실수 없이 구현해야** 한다.
- **코인베이스 트랜잭션의 구조는 일반 트랜잭션과 다르기 때문에**  
  반드시 별도로 테스트해야 한다.
- 이 트랜잭션이 잘못되면  
  → 채굴자가 보상을 못 받거나,  
  → 블록체인 네트워크 전체에 신뢰 문제가 발생할 수 있다.

## 2단계: 일반 트랜잭션 생성 및 Pool 저장 – 왜 필요한가?

### 목적

우리는 지금 **사용자(Bob)가 다른 사용자(Alice)에게 코인을 보내는 상황**을 구현하려고 한다.  
이 흐름이 필요한 이유는 다음과 같다:

- **실제 블록체인의 생명 주기에서 가장 많이 발생하는 사건**이 바로 사용자 간의 거래
- 이 거래는 **UTXO를 소모하고**,  
  새로운 TxOut을 만들며,  
  **트랜잭션 풀에 올라가 채굴자의 블록에 포함될 기회를 기다리는 상태**로 유지됨

### 필요한 조건은 무엇인가?

Bob이 Alice에게 7코인을 보내려면 다음 조건이 필요하다:

1. Bob의 계정에는 **7코인 이상 잔액이 있어야** 한다  
   → 우리는 이미 `beforeEach`에서 5+5 UTXO를 등록함
2. Bob은 **해당 UTXO를 사용할 권한이 있다는 것을 서명으로 증명해야** 한다  
   → `signature` 생성 완료
3. TxOut에는 **Alice의 주소와 보낼 금액(7)** 이 명시되어야 한다
4. 트랜잭션이 만들어지면 **트랜잭션 풀에 저장**되어야 한다

## 우리가 실제로 테스트한 것

### 1) 트랜잭션 생성 테스트

```ts
const tx = transaction.create(receipt, utxos);
expect(tx.txOuts.find((o) => o.account === alice)?.amount).toBe(7);
```

- `transaction.create()`는 내부적으로 다음을 수행함:
  - TxIn 생성: 필요한 UTXO를 수집하여 입력값 구성
  - TxOut 생성: 받은 사람과 거스름돈을 정의
  - Tx 조립 및 해시 생성
  - 트랜잭션 풀에 저장

이 테스트는 **Alice에게 7코인이 정확히 할당되었는지**를 확인하는 것이다

---

### 2) 트랜잭션 풀 저장 확인

```ts
const pool = transaction.getPool();
expect(pool.length).toBe(1);
```

- 트랜잭션이 생성되면 자동으로 트랜잭션 풀에 push 되기 때문에  
  → 이 테스트는 **풀에 제대로 저장되었는지 확인**하는 것이다

### 왜 이 테스트가 반드시 필요한가?

- **트랜잭션이 잘못되면 UTXO 오용 또는 위조가 발생**할 수 있다
- **트랜잭션이 풀에 저장되지 않으면** → 블록에 포함될 기회가 아예 없다
- 이 테스트는 **사용자 간 거래 시스템이 제대로 작동하는지**를 검증하는 가장 핵심적인 테스트다

## 3단계: 블록 후보 트랜잭션 목록 완성

블록체인에서 하나의 블록은 단순한 데이터 묶음이 아니라  
**코인베이스 트랜잭션 + 사용자 거래 목록**을 담고 있어야 한다.

우리가 지금 테스트하는 이 부분은  
**블록에 어떤 트랜잭션들을 포함시킬 것인가를 결정하는 로직**을 검증하는 것이다.

즉, 이렇게 묻는 상황과 같다:

> “블록을 만들려고 한다. 그럼 가장 먼저 어떤 트랜잭션을 넣을까?”  
> “사용자들의 거래는 어디서 가져오고, 어떤 순서로 넣어야 하지?”

---

### 이 단계에서 필요한 구성 요소는?

1. 채굴자 보상용 **코인베이스 트랜잭션**
2. 사용자들이 만든 **대기 중인 일반 트랜잭션들**
3. 이 두 가지를 하나의 배열로 **정확한 순서로 조합**할 것

---

### 실제 코드 흐름

```ts
const coinbaseTx = transaction.createCoinbase(miner, height);
```

- `createCoinbase()`를 통해 **블록의 첫 번째 트랜잭션**을 만든다.
- 채굴자 지갑 주소로 50코인을 지급하는 트랜잭션이 생성된다.

```ts
transaction.create(receipt, utxos);
```

- 사용자의 거래가 하나 만들어지고,
- 내부적으로 **트랜잭션 풀에 저장된다.**

```ts
const txsForBlock = [coinbaseTx, ...transaction.getPool()];
```

- 최종적으로 블록에 담을 트랜잭션 배열을 구성한다.
- **항상 코인베이스가 제일 앞에** 있어야 하므로, 이 순서를 반드시 유지해야 한다.

---

### 테스트의 목적은?

- 블록 후보가 구성될 때 **코인베이스가 첫 번째 위치에 있는가**
- 전체 트랜잭션 수가 예상한 개수(2개: 보상 + 1건 거래)와 일치하는가

```ts
expect(txsForBlock[0].txOuts[0].account).toBe(miner);
expect(txsForBlock.length).toBe(2);
```

---

### 왜 이걸 테스트해야 하는가?

- 블록의 **구성 순서가 잘못되면 합의 과정에서 무효 처리될 수 있다**
- 채굴 보상을 받으려면 반드시 **코인베이스가 정확한 구조로 포함**되어 있어야 한다
- 사용자 트랜잭션이 **누락되거나 중복 포함되지 않는지** 검증하는 과정도 여기에서 출발한다

## 4단계: 트랜잭션 반영 – 어떤 상태를 바꾸는가?

블록이 생성되면 끝이 아니라,  
그 안에 들어간 트랜잭션들이 시스템 전체에 반영되어야 진짜 **블록의 영향력이 유효**합니다.

즉, 이제 시스템은 이렇게 물어야 합니다:

> "이 블록 안의 트랜잭션들은 **이미 처리된 거야**?"  
> "그러면 **트랜잭션 풀에서 제거하고**,  
> 잔액도 **새로운 상태로 갱신해야지?**"

---

### 첫 번째 테스트 – 트랜잭션 풀 정리 (`transaction.sync()`)

```ts
transaction.sync(txsForBlock);
```

- 여기서 우리는 `txsForBlock` 배열을 그대로 넘겨줍니다.
- 그 안에는 `[코인베이스, 일반 트랜잭션]` 두 개가 들어있죠.
- `sync()`는 트랜잭션 풀에서 해당 트랜잭션들을 제거합니다.
- 이걸 테스트하는 이유는 간단합니다:

> **블록에 이미 포함된 트랜잭션이 다시 블록에 포함되면 안 되니까요.**

```ts
expect(transaction.getPool().length).toBe(0);
```

- 트랜잭션 풀은 이제 비어 있어야 정상입니다.

---

### 두 번째 테스트 – 잔액 상태 반영 (`unspent.update()`)

```ts
txsForBlock.forEach((tx) => unspent.update(tx));
```

- `update()`는 각 트랜잭션이 사용한 TxIn을 기반으로 기존 UTXO를 제거하고,  
  새롭게 생성된 TxOut을 기준으로 새로운 잔액을 추가합니다.

```ts
expect(result.find((o) => o.account === miner)?.amount).toBe(50);
expect(result.find((o) => o.account === alice)?.amount).toBe(7);
expect(result.find((o) => o.account === bob)?.amount).toBe(3);
```

- `miner`: 코인베이스 트랜잭션의 결과로 50코인을 보상받음
- `alice`: Bob이 보낸 7코인을 받음
- `bob`: 원래 10코인을 가지고 있었고, 그중 3코인을 거스름돈으로 받음

---

### 왜 이 테스트가 필요한가?

1. 트랜잭션 풀의 상태가 정확히 정리되었는지
2. 시스템이 현재 잔액 상태를 정확하게 반영하고 있는지
3. **코인베이스 트랜잭션도 동일한 방식으로 반영되는지**

> 즉, 이 테스트는 **블록 전체가 시스템에 반영되었음을 검증하는 마지막 관문**입니다.

---

### 이 구간을 정리하자면

- 앞에서 만든 모든 트랜잭션이 **실제 상태를 바꾸는지 검증**하는 곳
- 단순히 블록에 넣고 끝나는 것이 아니라,  
  블록이 반영된 결과로서 **잔액과 트랜잭션 풀 상태까지 바뀌는지**를 확인해야 한다

---

이렇게 하면 트랜잭션 생성 → 블록 포함 → 반영까지  
전체 흐름을 **단일 시나리오**로 검증하는 TDD 구조가 완성됩니다.
