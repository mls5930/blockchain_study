## 1. 시나리오 정의

> **Bob이 Alice에게 7코인을 준다**

- Bob은 7코인 이상의 잔액을 가지고 있다 (UTXO 필요)
- Alice는 받는 사람이다 (새로운 TxOut이 생성됨)
- 거래가 만들어진다 (Tx 생성)
- 이 트랜잭션은 검증되고 풀에 저장된다
- 블록에 포함되면 UTXO 상태가 변경된다

---

## 2. 시나리오 기반 리스트 정리

### 1단계. **채굴자는 블록을 만들 준비를 한다**

- 현재 블록 높이를 기준으로 `height`를 알고 있고, 블록에 담을 트랜잭션들을 준비해야 한다.
- 블록은 반드시 **가장 앞에 보상 트랜잭션(코인베이스)** 을 포함해야 한다.

> ❗즉, **보상은 누가 줄까?** 라는 질문에서 시작한다  
> → **시스템이 코인베이스 트랜잭션을 통해 지급**하는 구조다

---

### 2단계. **채굴자는 코인베이스 트랜잭션을 생성한다**

- `createCoinbase(account, height)` 함수를 통해  
  **자신의 지갑 주소(account)** 와 **현재 블록 높이**를 넣는다.
- 이 함수는 다음을 내부적으로 처리한다:
  - TxIn: 참조하지 않는 입력값 (블록 높이 + 1)
  - TxOut: 채굴자 지갑 주소로 50코인 지급
  - hash: 트랜잭션 식별자 생성

---

### 3단계. **사용자들이 만든 일반 트랜잭션들을 가져온다**

- 트랜잭션 풀에는 이미 사용자들이 만든 트랜잭션이 존재한다.
- `transaction.getPool()`을 통해 현재 대기 중인 트랜잭션들을 가져온다.
- 이 트랜잭션들도 블록에 포함될 예정이지만, 반드시 **coinbaseTx 뒤에 위치**해야 한다.

---

### 4단계. **블록에 포함할 트랜잭션 목록을 완성한다**

- 블록에 담을 트랜잭션 목록은 다음과 같다:

```ts
const txsForBlock = [coinbaseTx, ...transaction.getPool()];
```

- 이 구조로 생성된 `txsForBlock` 배열은 블록에 그대로 포함된다.
- 즉, 블록은 보상을 주고 → 사용자 거래들을 반영하는 구조가 된다.

---

### 5단계. **블록이 생성되고, 전파되었고, 유효하다고 가정하자**

- 블록이 네트워크에 전파되고 유효성이 검증된 후,
- 블록에 포함된 트랜잭션들은 다음과 같은 처리를 거친다:

---

### 6단계. **트랜잭션 풀에서 제거 (transaction.sync or update)**

- 블록에 포함된 트랜잭션들은 이제 **더 이상 대기 중이 아니므로**,  
  `transaction.update()` 또는 `transaction.sync()`로  
  **트랜잭션 풀에서 제거**된다.

---

### 7단계. **UTXO 상태 갱신 (unspent.update)**

- `unspent.update(transaction)`을 호출하여  
  해당 트랜잭션이 사용한 잔액(UTXO)은 제거되고,
  새로 만들어진 TxOut들은 새로운 잔액으로 등록된다.
- 여기서 코인베이스 트랜잭션도 동일한 방식으로 처리된다.  
  → 즉, 채굴자에게 지급된 보상도 UTXO에 등록된다.

---

## 요약된 흐름

> 블록 생성 시나리오는 이렇게 정리할 수 있다:

1. `createCoinbase()`로 보상 트랜잭션 생성
2. `getPool()`로 사용자 트랜잭션 가져오기
3. `[coinbaseTx, ...txPool]`으로 블록 트랜잭션 완성
4. 블록 생성 및 전파 완료 후
5. `transaction.sync()`으로 풀에서 제거
6. `unspent.update()`로 잔액 상태 반영
