# 우리가 지금까지 다룬 것:

**트랜잭션과 잔액 구조 중심의 흐름 정리**

---

이 문서는 블록체인의 전체 구조 중에서도

> **“트랜잭션이 어떻게 만들어지고 → 저장되고 → 블록에 반영되는가”**  
> 에 초점을 맞춘 정리입니다.

즉, 블록체인의 생명주기 전체를 설명하는 게 아니라,  
**트랜잭션 수업에서 다룬 흐름만 정리한 자료**입니다.

## 1. 트랜잭션 구조 이해

- 트랜잭션(Transaction)은 **입력(TxIn)** 과 **출력(TxOut)** 으로 구성
- 입력(TxIn)은 “어디서 돈을 가져왔는가?”
- 출력(TxOut)은 “누가 얼마를 받았는가?”

> 하나의 트랜잭션은  
> 과거에 받은 돈(UTXO)을 사용해서  
> 새로 잔액을 만들어내는 구조다.

---

## 2. 잔액 구조: UTXO 모델

- 우리는 사용되지 않은 출력(UTXO)을 모아  
  **사용 가능한 잔액 상태**를 관리한다.
- 사용된 TxOut은 제거되고,  
  새롭게 만들어진 TxOut은 **UTXO에 등록**된다.

→ 즉, 잔액은 “계좌의 숫자”가 아니라  
→ “쓸 수 있는 TxOut의 집합”이다.

---

## 3. 트랜잭션 생성 흐름

트랜잭션을 만들기 위해 다음 흐름을 따랐다:

1. **getUTXO(account)**  
   → 내가 가진 UTXO 목록을 조회하고

2. **필요한 만큼의 TxIn 선택**  
   → 보내려는 금액을 충당할 수 있는 만큼

3. **TxOut 생성**  
   → 받는 사람에게 보낼 금액  
   → 거스름돈은 내 주소로

4. **해시 생성 → 트랜잭션 조립**

5. **트랜잭션 풀에 저장**
   → 아직 블록에 들어가지 않은 상태

---

## 4. 트랜잭션 적용: UTXO 갱신

블록에 트랜잭션이 포함되었을 경우,

- `Unspent.update(transaction)` 호출

→ 내부에서는

1. 사용된 TxIn 기반 UTXO 제거
2. 생성된 TxOut은 새 UTXO로 등록
   => 3

---

## 5. 트랜잭션 풀 관리

블록 후보에 들어가기 전까지  
트랜잭션은 **대기 공간(pool)** 에 머문다.

- `getPool()` → 현재 대기 중인 트랜잭션 확인
- `update(tx)` → 특정 트랜잭션 제거
- `sync([tx1, tx2])` → 여러 트랜잭션 한 번에 제거

이 구조를 통해  
트랜잭션 풀을 **지속적으로 정리**하고,  
블록에 중복 포함되는 걸 방지한다.

---

## 6. 코인베이스 트랜잭션 생성

블록을 생성해준 **채굴자에게 보상**을 주기 위한  
특수한 트랜잭션도 구현했다.

- `createCoinbase(account, height)`
  - TxIn: 참조 없음 (블록 높이 + 1로 형식만 유지)
  - TxOut: 채굴자 계정에 50코인 지급
  - hash까지 포함한 완전한 트랜잭션 생성

이 트랜잭션은 **항상 블록의 첫 번째 위치**에 들어간다.

## 정리하며

우리는 이번 트랜잭션 수업을 통해  
다음과 같은 흐름을 직접 구현해보았습니다:

- **UTXO 모델을 기반으로 잔액을 확인하고**
- **서명된 트랜잭션을 생성하고**
- **트랜잭션 풀에 저장한 뒤**
- **블록에 포함되면 잔액(UTXO)이 반영되는 구조까지** 학습했습니다.

여기까지의 구현이 끝나면,  
트랜잭션은 네트워크에서 전파되고,  
블록은 점점 쌓여가며,  
블록체인은 **점점 신뢰를 축적해가는 상태**로 진화하게 됩니다.
