# 체인 교체란 무엇인가?

## 이런 상황을 떠올려보자

지금 내 컴퓨터에서 블록을 잘 채굴하고 있어요.  
근데 친구 A가 자기 체인을 내게 보내줬어요.

> ❓ 근데 그 체인, **내 체인이랑 달라!**  
> 블록 개수도 다르고, 내용도 달라.

---

## ❗ 그럼 어떤 걸 믿어야 할까?

=> **지금 내가 가진 체인을 계속 유지할까?**  
=> 아니면 **친구가 보낸 체인으로 바꿔야 할까?**

이런 상황에서 우리는 **선택**을 해야 합니다.  
그리고 이 선택의 기준이 바로:

## "롱기스트 체인 룰 (Longest Chain Rule)"

> “**더 길고, 유효한 체인이 있다면 그걸 선택한다**”

## 왜 길이가 중요한가?

> 체인은 블록이 많이 쌓일수록  
> **더 많은 계산과 시간이 들어간 ‘신뢰의 흔적’**이 되기 때문입니다.

- 블록을 만들 때마다 해시 조건(난이도)을 맞춰야 하죠?
- 체인이 길다는 건 = **그 조건을 많이 만족해왔다는 것**
- 그래서 더 긴 체인은 **더 ‘많이 일한 체인’**,  
  즉 **신뢰할 만한 체인**이 됩니다.

## 정리하면,

| 비교 기준   | 선택 기준                  |
| ----------- | -------------------------- |
| 블록 개수   | 더 많은 블록 가진 체인     |
| 유효성 검증 | 모든 블록이 정상이어야 함  |
| 교체 조건   | "더 길고, 유효하다면 교체" |

## 이걸 코드로 구현하려면?

우리는 체인 교체를 위한 메서드를 하나 만들 겁니다:

```ts
replaceChain(newChain: Block[])
```

이 메서드는 이런 흐름을 가질 거예요:

1. 전달받은 체인(newChain)이 **정상 체인인지 검사**
2. 그 체인의 길이가 현재 내 체인보다 **길면 교체**
3. 그렇지 않으면 무시

---

## 체인 교체는 언제 일어날까?

> 주로 **네트워크를 통해 다른 노드의 체인을 받았을 때**,  
> 또는 **재시작 후 동기화할 때** 일어납니다.

---

## 요약

> **체인 교체는 분기된 체인 중에서  
> 더 길고, 유효한 쪽을 선택하는 과정**입니다.  
> 이것이 바로 블록체인의 합의 방식 중 하나인  
> **롱기스트 체인 룰**입니다.

---

## 다음은?

→ 이제 실제로 이 로직을  
→ `replaceChain()` 메서드로 구현해보고,  
→ 유효성 검사와 교체 흐름을 TDD로 확인할 거예요!
