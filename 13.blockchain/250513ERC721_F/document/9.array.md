# 그리고 여러분, 또 하나의 자료형을 만나게 됩니다.

```solidity
uint256[] private allTokenIds;
```

이 변수… 낯익지 않나요?

바로 **배열(Array)**입니다.
여러분이 자바스크립트에서 수백 번 썼던 그 배열과 아주 비슷하게 생겼죠?

---

하지만,
**Solidity에서의 배열은 겉보기와는 다르게 약간 다른 방식으로 작동합니다.**

## 먼저 맥락부터 살펴봅시다 – 지금 우리가 만든 컨트랙트에서

```solidity
function minting(uint256 tokenId) public {
    ...
    allTokenIds.push(tokenId);
}
```

- 이 코드는 새로운 NFT를 발급할 때마다,
- 그 tokenId를 `allTokenIds`라는 배열에 저장하는 코드입니다.
- 이 배열은 결국 우리가 만든 모든 tokenId들을 모아놓는 **리스트의 역할**을 하죠.

즉,
→ "지금까지 몇 개의 NFT가 발급되었고, 그 tokenId가 무엇인지"
→ 기억해두는 역할입니다.

## 그런데 왜 이걸 따로 만들어야 하죠?

Solidity에는 자동으로 모든 tokenId를 추적해주는 기능이 없습니다.
=> ERC721.sol에서는

> ERC721Enumerable이라는 표준을 쓰지 않으면,  
> 우리가 직접 **토큰 목록을 저장해야만**  
> 전체 NFT 리스트를 불러올 수 있게 됩니다.

그래서 우리는 민팅할 때마다 이 배열에 `tokenId`를 수동으로 넣고 있는 거예요.

## 그럼 이 배열은 자바스크립트의 배열과 완전히 같을까요?

아닙니다. 겉은 비슷하지만, 작동 방식에는 차이가 있습니다.

---

### 자바스크립트의 배열

```js
const arr = [1, 2, 3];
arr.push(4); // 추가
arr[0]; // 접근
arr.length; // 길이
```

- 배열의 길이를 `.length`로 바로 알 수 있고,
- 모든 요소에 언제든 접근 가능합니다.

---

### Solidity의 배열

```solidity
uint256[] private allTokenIds;
allTokenIds.push(tokenId); // 추가
allTokenIds[i];            // 접근 (가능은 하지만 view 함수에서만)
allTokenIds.length;        // 길이 (가능)
```

- 문법적으로는 비슷하지만,
- 내부적으로는 **스토리지(storage)**에 저장되고,
- **읽고 쓰는 데에는 가스 비용**이 듭니다.

특히, **공개적으로 전체 배열을 return하는 건 주의가 필요**합니다.

## 그리고 중요한 차이 – 외부에서 접근이 제한됨

```solidity
function getAllTokenIds() public view returns (uint256[] memory) {
    return allTokenIds;
}
```

- 이렇게 view 함수로 외부에서 읽어야만, 전체 tokenId 배열을 조회할 수 있습니다.
- `private` 접근제한자 때문에 직접 접근은 불가능하고,
- 꼭 이런 **조회용 getter 함수를 명시적으로 만들어줘야** 합니다.

## 이걸 통해 우리가 알 수 있는 것

### 1. Solidity의 배열도 결국 **자료형의 한 종류**입니다

- `uint256[]`은 "숫자들의 리스트"라는 자료형입니다.
- 타입이 확장되면서 `[]` 형태로 구조를 표현할 수 있다는 걸 배웁니다.

---

### 2. 모든 상태는 "명시적으로 저장"되어야 한다는 감각

- 자바스크립트처럼 모든 상태가 RAM에 자동 저장되는 게 아니라,
- Solidity에서는 어떤 값이든 블록체인에 **저장하거나 불러오는 것을 명시적으로 작성**해야 합니다.

---

### 3. `배열`이라는 익숙한 문법 속에서도, 블록체인적인 사고방식이 필요하다

- 단순히 `push()`했다고 끝이 아니라,
  이 배열은 곧 **블록체인에 기록되며 가스를 소모하는 상태값**이라는 점을 체감해야 합니다.

---

## 요약 정리

| 항목          | 설명                                      |
| ------------- | ----------------------------------------- |
| `uint256[]`   | 숫자들의 배열 자료형                      |
| `allTokenIds` | 민팅된 모든 NFT의 tokenId를 저장          |
| JS와 차이점   | 가스 비용 존재, 명시적 getter 필요        |
| 핵심 철학     | 상태는 자동이 아님 → 직접 기록하고 읽는다 |

---

이렇게 보시면,
우리가 보고 있는 `uint256[] allTokenIds`라는 한 줄이 단순한 배열이 아니라,
**컨트랙트의 상태를 저장하는 도구이며**,
**자료형이 확장될 수 있다는 Solidity의 철학을 보여주는 예시**라는 걸 알 수 있습니다.

이제 여러분은 배열 하나를 보더라도
그게 단순한 값 목록이 아니라
**상태를 추적하고, 외부와 통신하며, 실행 흐름을 저장하는 구조**라는 걸
깨달았으면 하는 바램입니다.
