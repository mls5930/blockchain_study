## pinata 메타데이터 재업로드

여러분, 오늘은 스마트 컨트랙트를 아주 조금 수정할 예정입니다.
하지만 이걸 하기 전에, 우리가 먼저 **메타데이터 파일(JSON)들을 다시 업로드**해야 해요.

왜냐하면?

---

### 기존에 올린 구조를 이렇게 바꿀 겁니다

기존에는 이렇게 돼 있었죠:

```
1.json
2.json
3.json

1.png
2.png
3.png
```

이제부터는 아래처럼 **0번부터 시작**할 겁니다:

```
0.json
1.json
2.json

0.png
1.png
2.png
```

---

사실, 이런 방식은 "편하긴 하지만" **정석적인 구조는 아닙니다.**
그럼에도 불구하고 오늘 수업에서는
**수업 흐름의 일관성과 실습 오류 방지를 위해**
이렇게 구성하겠습니다.

---

### ❗ 그런데 왜 이게 "올바른 방식이 아닐까요"?

좋은 질문입니다.

우리가 NFT를 만들면서 흔히 **파일명 = tokenId** 구조를 따라가곤 합니다.
즉, `0.json`은 `tokenId = 0`인 NFT의 메타데이터로 연결된다는 가정이죠.

하지만 이 구조에는 몇 가지 문제가 있습니다:

---

#### 1. **파일명은 의미가 없습니다**

IPFS는 **파일 이름**이 중요한 게 아닙니다.  
**내용(content)**이 중요하죠.

파일을 올리면 생기는 CID는  
→ `0.json`이든 `lion.json`이든  
→ **파일 안의 내용이 같으면 동일한 CID가 생성됩니다.**

즉, "파일 이름이 0이라고 해서 tokenId 0과 연결되는 게 아니다"는 겁니다.

---

#### 2. **tokenId와 파일명을 1:1로 강제 매핑하면 유지보수가 어렵습니다**

- 실제 서비스에서는 tokenId가 꼭 0, 1, 2처럼 순차적이지 않을 수 있고,
- 메타데이터를 고정된 파일명으로 관리하면,
  **새로운 NFT가 추가될 때마다 기존 파일명을 바꾸거나 새로 정렬해야 합니다.**

이건 아주 비효율적인 구조입니다.

---

#### 3. **OpenSea와 같은 플랫폼은 ‘tokenURI’에 있는 주소만 보고 처리합니다**

즉, tokenId가 0이라도
→ `tokenURI(0)`이 어떤 CID를 반환하느냐가 중요하지
→ 그게 `0.json`이든 `dog42.json`이든 전혀 상관없습니다.

---

### 그럼에도 오늘은 왜 이렇게 할까요?

> 수업에서 `minting("0.json")` → `tokenId = 0` > `minting("1.json")` → `tokenId = 1`
> … 이렇게 흐름이 맞아떨어지는 게
> 실습 이해도 면에서 가장 자연스럽기 때문입니다.

---

### 그래서 오늘 여러분이 해야 할 일

1. 기존 `1.json`, `2.json`, `3.json` 파일을
   각각 `0.json`, `1.json`, `2.json`으로 이름을 바꿉니다.
2. 마찬가지로 이미지도 `0.png`, `1.png`, `2.png`로 정리합니다.
3. Pinata에 재업로드하여 새로운 CID를 확보합니다.
4. 그 CID를 기준으로
   `tokenURI()`가 `"ipfs://새로운CID/0.json"` 형태로 연결되도록
   컨트랙트를 수정합니다.

---

이 작업은 **단순한 파일 정리가 아니라**,  
NFT 구조의 핵심인  
**"토큰 ID → 메타데이터 → 이미지" 연결 흐름을 명확히 인지하는 훈련**입니다.

지금부터 함께 하나씩 진행해보겠습니다.
