# Class 문법을 활용한 블록 만들거임

아까 만들었던 블록 생성 함수를 `추상화` 시킬거임  
`우린 체계적으로 블록은 이렇게 생겨먹었다!`

1. BlockHeader
2. Block

```js
class BlockHeader {
  version;
  height;
  timestamp;
  previousHash;
  constructor() {}
}

const blockHeader = new BlockHeader();
```

제네시스 블록이니까 0번째 index => height겠지?
생성자 매개변수에 0을 넣습니다.

```js
class BlockHeader {
  version;
  height;
  timestamp;
  previousHash;
  constructor() {}
}

const blockHeader = new BlockHeader(0);
```

그럼 생성자 매개변수에 넣겠죠?

```js
class BlockHeader {
  version;
  height;
  timestamp;
  previousHash;
  constructor(_height) {
    this.height = _height;
  }
}

const blockHeader = new BlockHeader(0);
```

- version
- timestamp
- previousHash

```js
class BlockHeader {
  version;
  height;
  timestamp;
  previousHash;
  constructor(_height, _previousHash) {
    this.version = '1.0.0';
    this.height = _height;
    this.timestamp = Date.now();
    this.previousHash = _previousHash;
  }
}

const blockHeader = new BlockHeader(0);
```

version, timestamp 얻는 메서드 만들거임

```js
class BlockHeader {
  version;
  height;
  timestamp;
  previousHash;
  constructor(_height, _previousHash) {
    this.version = '1.0.0';
    this.height = _height;
    this.timestamp = new Date().getTime();
    this.previousHash = _previousHash;
  }

  getVersion() {
    return '1.0.0';
  }

  getTimestamp() {
    return new Date().getTime();
  }
}

const blockHeader = new BlockHeader(0);
```

new Date().getTime();
Date.now()

둘 다 시간을 얻는 메서드임.

```js
class BlockHeader {
  version;
  height;
  timestamp;
  previousHash;
  constructor(_height, _previousHash) {
    this.version = BlockHeader.getVersion();
    this.height = _height;
    this.timestamp = BlockHeader.getTimestamp();
    this.previousHash = _previousHash;
  }

  getVersion() {
    return '1.0.0';
  }

  getTimestamp() {
    return new Date().getTime();
  }
}

const blockHeader = new BlockHeader(0);
```

## 오류가 발생함

```sh
/home/wnqudgus1234/blockchain/practice/250331/src/block.js:7
      this.version = BlockHeader.getVersion();
                                 ^

TypeError: BlockHeader.getVersion is not a function
    at new BlockHeader (/home/wnqudgus1234/blockchain/practice/250331/src/block.js:7:34)
    at Object.<anonymous> (/home/wnqudgus1234/blockchain/practice/250331/src/block.js:22:21)
    at Module._compile (node:internal/modules/cjs/loader:1565:14)
    at Object..js (node:internal/modules/cjs/loader:1708:10)
    at Module.load (node:internal/modules/cjs/loader:1318:32)
    at Function._load (node:internal/modules/cjs/loader:1128:12)
    at TracingChannel.traceSync (node:diagnostics_channel:322:14)
    at wrapModuleLoad (node:internal/modules/cjs/loader:219:24)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:170:5)
    at node:internal/main/run_main_module:36:49

Node.js v22.12.0
```

---

## 왜 오류가 발생했을까?

```js
this.version = BlockHeader.getVersion();
```

이 코드에서 오류가 발생했어.  
메시지를 보면 이렇게 나오지:

```
TypeError: BlockHeader.getVersion is not a function
```

이 말은, **BlockHeader 클래스에 `getVersion`이라는 메서드가 존재하지 않는다**는 뜻이야.  
하지만 우리는 분명 아래와 같이 `getVersion` 메서드를 만들었잖아?

```js
getVersion() {
  return "1.0.0";
}
```

그런데 왜 존재하지 않는다고 나올까?

---

## 먼저 생각해볼 흐름

생성자 내부에서 `this.version = BlockHeader.getVersion()`이라는 코드가 실행돼.

그런데 이때 중요한 질문:

### 생성자 내부에서 메서드에 접근하려면, **그 메서드는 언제 정의되어 있어야 할까?**

- 클래스 내부에 메서드가 정의되어 있어도
- 그 메서드는 **인스턴스가 생성되고 나서야 사용할 수 있는** 것일 수 있어.

즉, 지금 만든 `getVersion()`은 **인스턴스 메서드**이기 때문에  
`new BlockHeader()`로 인스턴스를 완전히 만든 다음에야 `blockHeader.getVersion()`처럼 접근할 수 있어.

그런데 생성자 내부에서는 **인스턴스가 완전히 만들어지기 전**이기 때문에  
`this.getVersion()`도, `BlockHeader.getVersion()`도 안 돼.

---

## 해결: 메서드를 `static`으로 만들자

그래서 필요한 건 **클래스가 인스턴스를 만들지 않아도 바로 호출할 수 있는 메서드**,  
즉, `static` 메서드야.

```js
class BlockHeader {
  constructor(_height, _previousHash) {
    this.version = BlockHeader.getVersion(); // ⭕

    this.height = _height;
    this.timestamp = BlockHeader.getTimestamp(); // ⭕

    this.previousHash = _previousHash;
  }

  static getVersion() {
    return '1.0.0';
  }

  static getTimestamp() {
    return Date.now();
  }
}
```

---

## 왜 `static`이 필요한가?

### 클래스의 static 메서드는 **클래스 자체에 귀속**되는 메서드야.

- `BlockHeader.getVersion()` => 클래스에서 직접 호출 가능
- `new BlockHeader().getVersion()` => 인스턴스 메서드일 경우에만 가능

생성자에서 아직 `this`가 완성되지 않았거나  
인스턴스를 만들기 전에 필요한 값이라면  
static으로 만들어야 안전하게 접근할 수 있어.

```js
class BlockHeader {
  version;
  height;
  timestamp;
  previousHash;
  constructor(_height, _previousHash) {
    this.version = BlockHeader.getVersion();
    this.height = _height;
    this.timestamp = BlockHeader.getTimestamp();
    this.previousHash = _previousHash;
  }

  static getVersion() {
    return '1.0.0';
  }

  static getTimestamp() {
    return new Date().getTime();
  }
}

const blockHeader = new BlockHeader(0);
console.log(blockHeader);
```

```js
BlockHeader {
  version: '1.0.0',
  height: 0,
  timestamp: 1742942595420,
  previousHash: undefined
}
```

previousHash: undefined 이네?
제네시스 블록은 최초의 블록이라서 이전 블록이 존재하지 않음.  
따라서 이전 블록의 해시조차 존재하지 않아서  
**64자리의 0으로 채운 값을 사용하라.**

- 1번 블록의 previousHash → 0번 블록의 해시
- 2번 블록의 previousHash → 1번 블록의 해시

```js
class BlockHeader {
  version;
  height;
  timestamp;
  previousHash;
  constructor(_height, _previousHash) {
    this.version = BlockHeader.getVersion();
    this.height = _height;
    this.timestamp = BlockHeader.getTimestamp();
    this.previousHash = _previousHash || '0'.repeat(64);
  }

  static getVersion() {
    return '1.0.0';
  }

  static getTimestamp() {
    return new Date().getTime();
  }
}

const blockHeader = new BlockHeader(0);
console.log(blockHeader);
```
