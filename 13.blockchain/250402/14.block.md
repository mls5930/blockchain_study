# Class 문법을 활용한 블록 만들거임

아까 만들었던 블록 생성 함수를 `추상화` 시킬거임  
`우린 체계적으로 블록은 이렇게 생겨먹었다!`

1. BlockHeader
2. Block

아까 BlockHeader는 만들었고
이제 Block => BlockBody 만들거임
아까 block.js파일에다가 만들거임

```js
class Block {}
```

## 뭐가 있을까?

- hash
- merkleroot
- data

그 이외에 nonce, difficulty라는 값이 있는데  
지금 배우면 머리 깨지니까 다음 시간에

```js
class Block {
  hash;
  mercleroot;
  data;
  constructor() {
    this.hash = "";
    this.mercleroot = "";
    this.data = "";
  }
}
```

0번째 데이터니까 제네시스 블록.  
이전에 BlockHeader한테 받은 데이터도 가져와서 넣을거임

```js
class Block {
  // 여긴 블록 헤더 값
  version;
  height;
  previousHash;
  timestamp;
  // 여긴 블록 바디 값
  hash;
  mercleroot;
  data;
  constructor() {
    this.hash = "";
    this.mercleroot = "";
    this.data = "";
  }
}
```

이제 생성자를 넣을꺼니까 어떤걸 넣어?

```js
const blockHeader = new BlockHeader(0);
new Block(blockHeader, data);
```

0번째 데이터 => 하버드 생 데이터겠지?

근데, 다른 값을 넣어볼거임.  
사토시 나카모토가 최초의 제네시스 블록에 집어넣은 문자열 값

```js
const data = [
  "The Times 03/Jan/2009 Chancellor on brink of second bailout for bank",
];
const blockHeader = new BlockHeader(0);
const block = new Block(blockHeader, data);
```

그럼 블록 인스턴스 => 생성자 매개변수로 받아야겠지?

```js
class Block {
  // 여긴 블록 헤더 값
  version;
  height;
  previousHash;
  timestamp;
  // 여긴 블록 바디 값
  hash;
  mercleroot;
  data;
  constructor(_blockHeader, _data) {
    this.hash = "";
    this.mercleroot = "";
    this.data = "";
  }
}
```

그리고 클래스 내부 변수에 할당해보자

```js
class Block {
  // 여긴 블록 헤더 값
  version;
  height;
  previousHash;
  timestamp;
  // 여긴 블록 바디 값
  hash;
  mercleroot;
  data;
  constructor(_blockHeader, _data) {
    // 여긴 블록 헤더 값
    this.version = _blockHeader.version;
    this.height = _blockHeader.height;
    this.previousHash = _blockHeader.previousHash;
    this.timestamp = _blockHeader.timestamp;
    // 여긴 블록 바디 값
    this.hash = "";
    this.mercleroot = "";
    this.data = _data;
  }
}
```

자 이제 우리가 구해야 할 값은 뭐지?

- 해당 블록의 해시값
- 해당 트랜잭션(데이터들)의 머클루트

머클루트 부터 구해보자

```js
class Block {
  // 여긴 블록 헤더 값
  version;
  height;
  previousHash;
  timestamp;
  // 여긴 블록 바디 값
  hash;
  mercleroot;
  data;
  constructor(_blockHeader, _data) {
    // 여긴 블록 헤더 값
    this.version = _blockHeader.version;
    this.height = _blockHeader.height;
    this.previousHash = _blockHeader.previousHash;
    this.timestamp = _blockHeader.timestamp;
    // 여긴 블록 바디 값
    this.hash = "";
    this.mercleroot = "";
    this.data = _data;
  }

  static getMerkleRoot() {}
}
```

hash와 머클루트의 차이와 역할

1. merkleroot - 이 블록 안에 있는 '트랜잭션'들의 요약값

즉, 트랜잭션들 => data 변수 값.

```js
class Block {
  // 여긴 블록 헤더 값
  version;
  height;
  previousHash;
  timestamp;
  // 여긴 블록 바디 값
  hash;
  mercleroot;
  data;
  constructor(_blockHeader, _data) {
    // 여긴 블록 헤더 값
    const merkleroot = Block.getMerkleRoot(_data);
    this.version = _blockHeader.version;
    this.height = _blockHeader.height;
    this.previousHash = _blockHeader.previousHash;
    this.timestamp = _blockHeader.timestamp;
    // 여긴 블록 바디 값
    this.hash = "";
    this.mercleroot = merkleroot;
    this.data = _data;
  }

  static getMerkleRoot(_data) {}
}
```

### 머클루트 메서드 흐름

#### 1. 매개변수로 받은 데이터로 머클 트리를 만든다.

```js
class Block {
  static getMerkleRoot(_data) {
    const merkleTree = merkle("sha256").sync(data);
  }
}
```

#### 2. 그리고 최종적으로 합쳐서 다시 암호화하여 해시한 root값 => 머클 루트 값을 만든다

```js
class Block {
  static getMerkleRoot(_data) {
    const merkleTree = merkle("sha256").sync(data);
    const merkleRoot = merkleTree.root();
    return merkleRoot;
  }
}
```

2. hash - 현재 블록 자체의 요약값

```js
class Block {
  static createBlockHash() {}
}
```

현재 **블록 헤더와 블록 속성의 모든 값 + 머클루트** 를 문자열로 결합하고
그걸 `SHA256`으로 암호화한 16진수 문자열이다.

```js
class Block {
  // 여긴 블록 헤더 값
  version;
  height;
  previousHash;
  timestamp;
  // 여긴 블록 바디 값
  hash;
  mercleroot;
  data;
  constructor(_blockHeader, _data) {
    // 여긴 블록 헤더 값
    const merkleroot = Block.getMerkleRoot(_data);
    this.version = _blockHeader.version;
    this.height = _blockHeader.height;
    this.previousHash = _blockHeader.previousHash;
    this.timestamp = _blockHeader.timestamp;
    // 여긴 블록 바디 값
    this.mercleroot = merkleroot;
    this.hash = Block.createBlockHash(_blockHeader, merkleroot);
    this.data = _data;
  }

  static getMerkleRoot(_data) {
    const merkleTree = merkle("sha256").sync(data);
    const merkleRoot = merkleTree.root();
    return merkleRoot;
  }

  static createBlockHash() {}
}
```

```js
${block.height}${block.timestamp}${block.data}${block.prevHash}
```

```js
class Block {
  static createBlockHash(_blockHeader, _merkleroot) {}
}
```

### 블록 해시 만들기 메서드 흐름

#### 0. crypto-js/SHA256 사용할 거임

```sh
npm install crypto-js
```

#### 1. `_blockHeader`는 객체 형태로 전달 (헤더 정보만 포함)

```js
class Block {
  static createBlockHash(_blockHeader, _merkleroot) {
    const values = Object.values(_header);
  }
}
```

`Object.values()`로 값만 추출 → 문자열로 병합

#### 2. 그 뒤에 `merkleRoot`도 추가

```js
class Block {
  static createBlockHash(_blockHeader, _merkleroot) {
    const values = Object.values(_header);
    const data = values.join("") + _merkleroot;
  }
}
```

#### 3. 전체 문자열을 `SHA256()`으로 해시

```js
class Block {
  static createBlockHash(_blockHeader, _merkleroot) {
    const values = Object.values(_header);
    const data = values.join("") + _merkleroot;
    SHA256(data);
  }
}
```

#### 4. .toString()으로 16진수 문자열 반환

```js
class Block {
  static createBlockHash(_blockHeader, _merkleroot) {
    const values = Object.values(_header);
    const data = values.join("") + _merkleroot;
    return SHA256(data).toString();
  }
}
```

이게 블록의 hash값이다.
