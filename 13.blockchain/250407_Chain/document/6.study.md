# 블록의 난이도 조정 흐름을 완전히 이해하고, TDD로 직접 확인해보기

## 지금 당장은 이것만 기억해라.

"블록이 많아지면 체인이 된다.
체인 위에 쌓이는 블록은 시간과 양에 따라 난이도가 조절된다."

## 목표: 블록의 난이도 조정 흐름을 완전히 이해하고, TDD로 직접 확인해보기

- Block.ts 안의 getDifficulty() 메서드를 중심으로
- 블록이 여러 개 생겼을 때,
- **정해진 주기마다 난이도가 바뀌는가? 를 TDD로 확인하는 것이 목표입니다.**

## 이건 오늘 잊어라

- replaceChain() 같은 체인 교체, 분기 처리는 오늘 안 합니다.
- 복잡한 검증, 네트워크 흐름은 생략!

오늘은 순수하게 체인에 블록을 쌓고,  
블록의 난이도가 조정되는지 그 원리만 확인합니다.

---

### 1단계. 지금까지 우리 수업 흐름 복습

먼저 인지해야할게, 우리는 가정하고 있어.

체인

=> 체인이 있다는 건, 수많은 블록이 생성되고 연결되었다는 거야.  
=> 맥락

지금 체인에는 졸라게 많은 블록이 이미 있다고 가정해야 합니다.
그래서 그 블록이 졸라게 많으니 생성했을 때 기준을 세 개를 예로 든거야.

1. 이전 블록
2. 데이터
3. 난이도 조정을 위한 기준 블록

```ts
const newBlock = Block.generateBlock(prevBlock, data, adjustmentBlock);
```

이 과정에서 **난이도(difficulty)** 값도 계산되어 블록 안에 들어갑니다.

### 지금 목표는?

우리는 단순히 블록을 추가하는 게 아니라  
“난이도는 어떤 기준에 따라 바뀌는가?” 를 실험하려고 합니다.  
이걸 위해 먼저 “체인이 있고, 블록이 계속 추가된다”는 시점을 ‘마음속으로 시뮬레이션’ 해야한다.

## 난이도가 왜 필요할까?

지금까지 블록은 `generateBlock()` 한 번이면 **뚝딱** 만들어졌죠?  
하지만 **진짜 블록체인 네트워크**에서는 그렇게 쉽게 만들 수 없습니다.

왜일까요?

---

## 문제 상황을 먼저 생각해보자

> 만약 누구나, 아무 때나, 블록을 만들 수 있다면?

- 그냥 코드 몇 줄로 나도 만들고,
- 옆 친구도 만들고,
- 전 세계 수십만 명이 동시에 만들면?

→ **네트워크는 블록 폭탄으로 터져버립니다.**

---

## 그래서 필요한 개념이 바로 **"난이도(Difficulty)"**

> **"이 조건을 만족해야만 블록을 인정해줄게."**

0000....

이걸 맞추기 위해선 수많은 연산을 반복해야 하죠.  
이게 바로 우리가 말하는 **“채굴(mining)”**.

## 난이도란?

- 블록이 **얼마나 만들기 어려운가**를 나타내는 수치입니다.
- 이 수치를 기반으로 **해시 조건이 자동 조절**됩니다.

> 난이도 = 네트워크 속도 조절 장치

### 그런데 난이도도 문제야

> 난이도가 **너무 낮으면?**

- 누구나 금방 만들어서 **블록 남발**
- 보상 남발 → **인플레이션**
- 네트워크 혼잡, 블록 충돌

> 난이도가 **너무 높으면?**

- 아무도 못 만듦 → **거래 정체**
- 시스템이 멈춰버림

### 그래서?

> “적절한 속도로 블록이 만들어지게 하려면,  
> 난이도를 **상황에 따라 조절해야 하지 않을까?”**

=> 오늘 주인공은 difficulty야.
=> 얘를 올리느냐 내리느냐.
=> 언제? 올리느냐 내릴건데?

그 언제?를 실습하는 시간이야 쉽지?

### 2단계. 그래서 등장한 게 `getDifficulty()` 메서드

앞에 get을 붙히는게 단순히 조회한다!라는 뜻이 아닌걸 인지해.  
얘는 반환값이 **조절된 난이도 값**이야

블록을 만들 때 이 함수를 호출합니다:

```ts
Block.getDifficulty(newBlock, adjustmentBlock, previousBlock);
```

---

### 3단계. 매개변수 하나하나 의미 알아보기

Block.getDifficulty가 언제 호출돼?

블록 후보 생성되었을 때.
즉, 블록의 생성자 함수가 최초로 호출 되었을 때 난이도를 결정하는거야.

| 매개변수          | 역할                                          |
| ----------------- | --------------------------------------------- |
| `newBlock`        | 지금 막 만들 블록 (몇 번째인지 알아야 함)     |
| `adjustmentBlock` | 난이도 기준 시작점 블록 (주기 전 블록)        |
| `previousBlock`   | 직전 블록 (조정 안되면 이 블록의 난이도 사용) |

- newBlock: 새 블록
- adjustmentBlock: 주기 전 블록
- previousBlock: 직전 블록

아직 조정할 시점이 아니면 직전 블록 난이도 사용
조정할 시점이 되면? adjustmentBlock 블록 기준으로 계산

쉽지?

목표는 지금 만들 블록을, 과거 흐름과 비교해서 난이도를 결정하는 구조
=> 난이도 조정임.

---

### 5단계. 난이도 조정 규칙

```ts
if (_newBlock.height % DIFFICULTY_ADJUSTMENT_INTERVAL !== 0)
  return _previousBlock.difficulty;
```

→ 주기(`DIFFICULTY_ADJUSTMENT_INTERVAL`)가 아닐 땐 **그냥 직전 블록의 난이도 복사**

---

### 6단계. 난이도 진짜 조정 시기에는?

```ts
const timeToken = _newBlock.timestamp - _adjustmentBlock.timestamp;
const timeExpected =
  BLOCK_GENERATION_INTERVAL * 10 * DIFFICULTY_ADJUSTMENT_INTERVAL;
```

=> 실제 걸린 시간 vs. 우리가 기대한 시간

```ts
if (timeToken < timeExpected / 2) return _previousBlock.difficulty + 1;
if (timeToken > timeExpected * 2) return _previousBlock.difficulty - 1;
```
