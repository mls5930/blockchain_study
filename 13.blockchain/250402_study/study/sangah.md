# 오늘 뭐가 어려웠나?

## any, unknown

any

unknown

## 어설션

**"제네릭이 왜 필요한가?"**,  
**"그게 납득이 안 되는 게 오히려 자연스럽다"**는 시선에서 출발,  
=> 조팀장이 자연스럽게 **any, 유니언, 제네릭**의 차이를 느끼게 하려는 구성.

---

## 제네릭이 납득 안 되는 게 오히려 정상입니다

학생들에게 제네릭을 설명할 때 가장 먼저 마주하는 반응은 대체로 이렇습니다.

> "이거 꼭 써야 하나요?"  
> "그냥 `any`나 유니언 쓰면 되지 않아요?"

이런 질문은 너무도 자연스럽고, 오히려 **정상적인 사고 흐름**입니다.  
왜냐면 **제네릭 없이도 '다형성'을 흉내낼 수 있는 문법**이 이미 존재하니까요.  
그래서 그 과정을 단계별로 살펴보면서,  
"왜 결국 제네릭이 필요한가?"를 **몸으로 느끼게** 해보려고 합니다.

---

### 1단계: 그냥 `any` 쓰면 되잖아?

```ts
const fn101 = (): any => {
  return "1";
};

fn101(); // 어떤 타입이든 넣고 빼도 오류 안 남
```

`any`는 진짜 만능입니다. 모든 타입을 받아주고, 타입 검사도 하지 않죠.  
**하지만 문제는 타입 안정성이 없습니다.**

```ts
const result = fn101(); // result는 any
result.toFixed(); // 런타임 오류 가능성 있음
```

개발자 입장에서 타입스크립트를 쓰는 이유가 없어져 버리는 겁니다.

---

### 2단계: 유니언 쓰면 되는 거 아냐?

```ts
const fn100 = (): string | number | string[] => {
  return "1";
};
```

유니언을 쓰면 좀 더 제한된 타입 범위 안에서 안전하게 타입을 관리할 수 있어요.  
하지만 문제는... **타입을 특정하기 어렵다는 점**입니다.

```ts
const res = fn100();
res.toUpperCase(); // ❌ Error: string | number | string[]에 toUpperCase 없음
```

결국 타입을 **정확히 특정할 수 없으면** 이점이 사라집니다.  
타입스크립트의 도움을 온전히 못 받게 됩니다.

---

### 3단계: 아예 타입을 밖에서 넘기면 안 되나?

```ts
const fn4 = <T>(): T => {
  return "1" as T;
};

fn4<string>(); // 호출 시 string으로 지정
```

여기서 제네릭이 등장합니다.  
호출 시점에 타입을 정해서, **타입 유추 + 타입 안정성**을 모두 잡을 수 있어요.  
하지만 `"1"`은 string 리터럴이고, 함수의 반환 타입은 T입니다.  
그래서 **타입스크립트는 `"1"`이 진짜 T라고 보장할 수 없어서 오류가 납니다.**

그래서 우리가 `as T`로 타입 단언을 해주는 거예요.

> "야 타입스크립트야, 이건 T가 맞아. 내가 책임질게."

---

### 여기서 중요한 질문:

> 왜 굳이 `as T`까지 써가며 제네릭을 써야 하나요?

그 이유는, **함수 로직은 그대로 두고**,  
**호출 시점에서 타입을 바꾸면서도 타입 체크를 강력하게 하고 싶기 때문**입니다.

---

### 4단계: 결국 타입스크립트 개발자는 이렇게 생각했을 것

> 재사용하면서도 타입 규칙은 지키고 싶다.  
> 그런데 `any`나 `|` 같은 유니언은 타입 체크에 구멍이 생긴다.  
> 그러면...  
> **"함수 호출 시 타입을 넘겨서 그 타입에 맞춰 함수 전체를 체크하면 좋지 않을까?"**

그래서 제네릭이 탄생한 겁니다.

---

## 강의 포인트 정리

- **제네릭이 처음부터 납득되는 게 비정상이다.**
- **`any` → `유니언` → `제네릭` 흐름**을 통해 제네릭의 필요성을 체감하게 한다.
- **`as T`는 타입스크립트가 확신하지 못하는 상황을 명시적으로 넘기는 방법**이다.
- **결국 제네릭은 호출자가 타입을 명시함으로써 재사용성과 타입 안정성을 동시에 확보하는 방식**이다.

## 학생 질문 : 타입을 먼저 지정하잖아요 근데 처음 얘를 정의할 때 쓴다고 했잖아요 얘를 export해서 내보낼거야 정의할게요. 그럼 다른 곳에서 불러올거 아니에요? 얘를 아까처럼 정의를 해줘야하냐?

=> 일단 질문부터 정리

타입을 나중에 지정하는 거면, export해서 다른 곳에서 쓸 때도 매번 타입을 명시해야 하나요?
즉, 정의할 때 안 정하면, 매번 fn<string>() 이렇게 써야 하는 건가요?

## 학생 질문 요약:

> 타입을 나중에 지정하는 거면, export해서 다른 곳에서 쓸 때도 매번 타입을 명시해야 하나요?  
> 즉, 정의할 때 안 정하면, 매번 `fn<string>()` 이렇게 써야 하는 건가요?

---

## 핵심 답변 요약:

### 1. 제네릭은 **가능하면 정의(선언)할 때 타입을 유추하게 설계**해야 한다

- **호출하는 쪽에서 타입을 안 적어도 되게끔** 만드는 게 깔끔한 설계야.
- 타입을 유추할 수 있다면 그게 제일 좋음.

```ts
const identity = <T>(value: T): T => value;

identity("hello"); // 타입 유추됨 — OK
```

---

### 2. 타입스크립트가 유추를 못 하는 경우 → 어쩔 수 없이 **타입 명시 or 어설션**

- 예: 반환값이 고정된 `"1"`인데, 그걸 T라고 하려고 함

```ts
const fn4 = <T>(): T => {
  return "1" as T; // 어설션 필요함 — 타입스크립트는 유추 못 함
};
```

- 이건 **“코드를 강아지같이 짰다”**, 즉 *타입스크립트가 유추해줄 수 없게 코드를 짰다*는 뜻.
- 결국 타입스크립트한테 **“맞아, 이거 T야. 그냥 그렇게 믿어줘”** 라고 우기게 되는 상황.

---

### 3. export 해서 다른 데서 쓰려면?

```ts
// utils.ts
export const fn = <T>(input: T): T => input;

// main.ts
import { fn } from "./utils";

const result = fn("hello"); // 타입 유추됨 ✅
const result2 = fn<number>(123); // 명시도 가능 ✅
```

- 일반적으로는 **유추되도록 짜는 게 베스트**
- **불가피한 경우만 `as T`나 명시적 제네릭 사용**

---

## 결론 요약 (학생 전달용)

> **타입은 웬만하면 선언 시 유추되게 짜야 한다.**  
> **직접 `T`를 넣어야 하거나 `as T`를 썼다면, 설계가 조금 부자연스러운 코드일 수 있다.**  
> 🐶 **즉, 어설션을 쓴다? 타입스크립트가 못 알아먹게 강아지같이 짠 코드다.**

---

### 🔔 보너스: 좋은 함수 설계 기준

| 조건                        | 좋음? | 이유                       |
| --------------------------- | ----- | -------------------------- |
| 타입 유추 가능              | ✅    | 호출할 때 편하고 안전함    |
| T 타입을 강제 어설션해야 함 | ❌    | 타입 안정성이 깨질 수 있음 |
| 매번 타입 명시해야 작동함   | ❌    | 유연성이 떨어짐            |
