## 이제 머릿속에 흐름을 다시 그려봅시다

**– BaseballGame 전체 유저 플로우로 풀어보기**

자, 이제 여러분은 ERC-20의 핵심 흐름을 이해했고,
또 ETH 기반으로 짰던 BaseballGame도 한번 만들었습니다.

이제는 화면 없이,
**“유저가 어떤 순서로 어떤 행위를 하며, 그때 스마트컨트랙트 내부에서 무슨 일이 벌어지는가”**
를 말로 풀어보며 **전체 흐름을 재구성**해봅시다.

---

## 유저 입장에서 순서를 따라가 봅시다

### 1단계. 유저는 게임을 하기 위해 **토큰이 필요**합니다.

- **전제 조건:** 게임에 참가하려면 `ticket` 만큼의 토큰이 있어야 합니다.
- **가능한 흐름:**

  - 오너가 `mint()`로 토큰을 발행하고
  - 그 중 일부를 유저에게 `transfer()`해서 지급합니다.

→ 즉, **"토큰이 없다면 게임 자체에 참여할 수 없습니다."**

---

### 2단계. 유저는 참가비를 “미리 위임”해야 합니다.

- 참가자는 게임 컨트랙트에게 다음과 같은 트랜잭션을 보냅니다:

```solidity
approve(gameContract, ticket);
```

- 이 트랜잭션은 “게임 컨트랙트가 내 지갑에서 참가비를 가져갈 수 있도록 허락하겠다”는 의미입니다.
- 이 과정에서는 **실제로 토큰이 이동하진 않습니다.**

→ 이건 말하자면, “자동이체 등록” 같은 것입니다.
→ **“내가 직접 보내지 않지만, 너가 가져갈 수 있어.”**

---

### 3단계. 유저는 게임을 시작합니다 → `gameStart(_value)` 호출

이제 유저는 본격적으로 게임을 시작합니다:

```solidity
gameStart(내가 고른 숫자);
```

- 이 함수 내부에서 `transferFrom(msg.sender, address(this), ticket)`이 실행되며
  유저 지갑에서 **참가비가 회수**됩니다.
- 동시에, 유저가 고른 숫자 `_value`가 정답인지 비교합니다.

---

### 4단계. 정답이라면?

- 유저가 고른 `_value`가 정답 `random`과 일치한다면:

```solidity
token.transfer(msg.sender, reword);
```

- 지금까지 누적된 보상(`reword`)을 유저에게 지급하고, 게임은 종료됩니다.
- `gameState`를 `gameOver`로 바꾸어 **더 이상 플레이가 불가능**하게 만듭니다.

→ **“참가비를 냈고, 정답을 맞췄기 때문에, 보상을 받고 종료되는 흐름입니다.”**

---

### 5단계. 틀렸다면?

- 정답이 아니라면, `reword` 변수에 참가비만큼 누적됩니다:

```solidity
reword += ticket;
```

- `progress`도 증가시킵니다 (시도 횟수)

→ 이 과정을 **10번 반복할 수 있습니다.**
→ 유저는 여러 번 시도할 수 있고, 그만큼 보상 풀은 계속 쌓입니다.

---

### 6단계. 10번 다 틀렸다면?

- `progress == GAME_COUNT`가 되면, 자동으로 게임이 종료됩니다.
- 아무도 정답을 맞히지 못했다면, 보상은 지급되지 않은 상태로 남습니다.

---

### 7단계. 게임 종료 후 → 오너는 남은 토큰을 인출할 수 있어야 함

- 아무도 정답을 맞히지 못한 경우, 오너는 다음 함수를 호출할 수 있습니다:

```solidity
withdrawToOwner();
```

- 이 함수는 컨트랙트 안에 남아 있는 토큰(=누적된 reword)을 오너 지갑으로 전송합니다.

→ **공정한 게임 실패 처리 흐름입니다.**

---

## 전체 흐름 요약 (시나리오)

| 순서 | 주체     | 동작                     | 내부 처리                                   |
| ---- | -------- | ------------------------ | ------------------------------------------- |
| 1    | 오너     | `mint()`                 | 토큰 생성 + 오너 잔고 증가                  |
| 2    | 오너     | `transfer(user, amount)` | 유저에게 토큰 지급                          |
| 3    | 유저     | `approve(game, ticket)`  | 참가비 위임 등록                            |
| 4    | 유저     | `gameStart(_value)`      | 참가비 회수 (`transferFrom`) + 정답 체크    |
| 5    | 컨트랙트 | `_value == random`이면   | `transfer(user, reword)` → 보상 지급 + 종료 |
| 6    | 컨트랙트 | `_value != random`이면   | `reword += ticket` + `progress++`           |
| 7    | 유저     | 10번 틀림                | 게임 종료                                   |
| 8    | 오너     | `withdrawToOwner()` 호출 | 남은 토큰 인출                              |

---

## 우리는 이 흐름을 코드가 아닌 “구조로 기억”해야 합니다

이제 여러분은
**"transferFrom이 어떤 흐름에서 호출되어야 하는지"**,
**"mint는 언제 실행되고, transfer는 어떤 역할을 하는지"**
이런 것들을 모두 “하나의 게임 시나리오” 안에서 이해하고 있어야 합니다.

화면이 없어도 흐름을 머릿속에 그릴 수 있다면,
그건 **진짜 이해한 것**입니다.

---

다음 수업에서는 이 흐름을 기반으로
**TDD로 하나씩 검증하면서 전체 구조를 몸으로 구현해볼 것**입니다.

→ 그 시작은 오너만 `mint()` 할 수 있어야 한다는 조건부터 확인하는 것입니다.
