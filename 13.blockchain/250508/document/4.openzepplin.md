## 그런데 이 줄, 궁금하지 않으세요?

```solidity
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
```

이게 바로 오늘 이야기의 핵심 중 하나,
**"OpenZeppelin(오픈제플린)"**입니다.

## 오픈제플린이 만들어지기 전엔…

이더리움이 막 생기고 나서,
스마트 컨트랙트를 짜는 개발자들은 모두 **각자 자기만의 방식**으로 토큰을 구현했습니다.

- 어떤 사람은 `transfer()`에 조건을 하나 더 붙이고,
- 어떤 사람은 `approve()`를 빼먹고,
- 누군가는 이벤트 로그를 안 남기고,
- 심지어 누군가는 `mint()`를 아무나 호출 가능하게 만들기도 했습니다.

이런 일들이 실제로 있었습니다.

그 결과, 다음과 같은 문제가 생겼죠:

> “**어떤 토큰은 지갑에서 안 보이고**,
> **어떤 토큰은 거래소에서 인식이 안 되고**,
> **어떤 토큰은 `transfer()`가 아예 실패하고**…”

## 진짜 있었던 일입니다 – 실수 하나에 수천만 원이 날아갔습니다

이더리움 초창기 시절, 스마트 컨트랙트를 직접 구현하는 사람들은 대부분
**처음 접하는 언어, 처음 접하는 개념, 그리고 돈이 연결된 코드**를 다뤘습니다.

그 결과, 이런 실수들이 실제로 자주 벌어졌습니다:

---

### ❌ 1. 토큰을 전송했는데 화면에는 안 보임

어떤 개발자는 `transfer()` 함수는 잘 만들었는데,
**이벤트 로그를 안 남겼습니다.**

> “토큰은 전송됐는데, 지갑 화면엔 표시가 안 되는 거예요.”

왜냐하면 메타마스크나 블록 탐색기들은
**`Transfer` 이벤트가 발생한 기록**을 기준으로
토큰 이동 내역을 추적하기 때문입니다.

---

### ❌ 2. 상속을 잘못해서, 컨트랙트가 이상하게 작동함

Solidity는 `is`를 사용해 상속을 하는데,
상속 순서를 헷갈리거나 내부 함수가 꼬이면
**어떤 기능이 덮어쓰였는지, 아예 실행되지 않는지 모르는 상황**이 벌어집니다.

> “그냥 함수 하나 넣었는데, 원래 있던 기능이 안 돌아가는 거예요.”

→ 이런 오류는 컴파일은 되지만, 실행하면서 망합니다.

---

### ❌ 3. 누군가 실수로 돈을 꺼낼 수 있게 만들어둠

아래처럼 너무 단순하게 출금 함수를 만든 경우도 있었습니다:

```solidity
function withdraw() public {
    payable(msg.sender).transfer(address(this).balance);
}
```

- 누가 호출하든, 그냥 컨트랙트에 있는 돈을 다 가져갈 수 있게 되는 구조입니다.

> “테스트할 땐 내가 잘 보냈으니까 문제없었는데,
> 배포하고 나니까 아무나 실행할 수 있었던 거예요.”

실제로 이런 실수 하나로
**수천만 원어치 이더가 털려버린 사례도 존재**합니다.

---

### 즉, 실수는 너무 쉽고… 뒷감당은 너무 큽니다

> 블록체인은 **되돌릴 수 없기 때문에**
> 한번 배포된 컨트랙트에 오류가 생기면 끝입니다.

그래서 우리는 이제 코드 하나하나를 일일이 짜는 게 아니라,
**검증된 컨트랙트를 불러다 조립하는 방식**으로 개발하게 된 것입니다.

---

## 그래서 어떤 개발자들이 이렇게 생각했죠:

> “우리가 자주 쓰는 컨트랙트 코드들,
> 미리 보안 검증해서 잘 정리해두면 안 될까?”

이 생각에서 시작된 프로젝트가 바로 **OpenZeppelin**입니다.

---

## OpenZeppelin은 어떤 철학과 배경을 가졌나요?

- **2016년에 설립된 오픈소스 프로젝트**
- 처음에는 “스마트 컨트랙트 보안 감사 회사”에서 출발했지만,
  → 점점 **보안이 검증된 표준 컨트랙트 라이브러리**로 진화했습니다.

이들이 가진 철학은 단 하나입니다:

> “**누구나 신뢰할 수 있는 블록체인 코드를 작성할 수 있도록 만들자.**”

즉, 중요한 건 코드의 “재사용성”이나 “간편함”이 아니라,
**“검증되고, 누구나 믿고 쓸 수 있는 안정성”입니다.**

## 그래서 OpenZeppelin의 컨트랙트는 다음이 전제입니다

- **표준 스펙(EIP, ERC)에 정확히 부합하고**
- **보안 전문가들이 리뷰를 거쳤으며**
- **전 세계 수많은 프로젝트들이 실전에 사용 중**
- **누구나 오픈소스로 내용을 확인하고 감사할 수 있음**

## 우리가 지금 사용하는 `ERC20.sol`도 바로 그 중 하나입니다

이 파일은 다음을 모두 내부에 구현해두고 있습니다:

- 상태: `balances`, `allowances`, `totalSupply`
- 함수: `transfer`, `approve`, `transferFrom`, `mint`, `burn`
- 이벤트: `Transfer`, `Approval`

그리고 우리는 **그 복잡한 코드 전체를 직접 작성하지 않고**,
이 한 줄로 상속받을 수 있습니다:

```solidity
contract MyToken is ERC20 {
```

---

## 그래서 우리는 코드를 “복붙”하지 않고, “신뢰”를 가져옵니다

> “OpenZeppelin은 단지 라이브러리가 아니라,
> **이더리움 생태계 전체가 함께 만든 안전한 약속**입니다.”

그 약속 위에서 우리는 MyToken을 만들고,
그 위에 BaseballGame 같은 디앱을 쌓아가게 되는 것입니다.
