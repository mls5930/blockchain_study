## 스마트 컨트랙트가 스마트 컨트랙트를 부른다고요?

**– 외부 컨트랙트 호출 구조의 철학과 기술, 그리고 필요성**

---

자, 우리는 앞서

- **MyToken**: 토큰을 발행하고 관리하는 컨트랙트
- **BaseballGame**: 게임 로직만을 다루는 컨트랙트
  이렇게 **기능별로 컨트랙트를 분리**해서 만들었습니다.

그런데 한 가지 질문이 생기죠.

---

> “그냥 `BaseballGame` 안에 `mint()`, `transfer()` 다 넣고 하나로 만들면 안 되나요?”

**기술적으로? 가능은 합니다.**
하지만 **현실에서는 불가능에 가깝고, 심각한 구조적 문제**가 생깁니다.

---

### 예를 들어 볼까요?

#### 1. 여러 게임이 하나의 토큰을 써야 하는 상황

- BaseballGame, RPGGame, PuzzleGame…
  → 이 모든 게임이 동일한 토큰을 사용해야 한다면?

→ 만약 각 게임마다 `token.sol`을 복사해서 넣는다면?
→ **총 공급량, 잔액, 위임 내역**이 전부 따로 관리됩니다.
→ 유저 입장에선 동일한 MTK인 줄 알았는데,
사실은 서로 다른 별개의 토큰인 거죠.

---

#### 2. 거래소, 프론트엔드, 지갑과의 연동

- ERC-20 토큰은 **지갑이나 프론트에서 자동으로 인식**되기 위해,
  **표준 인터페이스만 노출된 전용 컨트랙트**를 필요로 합니다.

→ 그런데 Game 컨트랙트 안에 ERC-20 기능이 섞여 있다면?
→ **토큰으로 인식 자체가 안 됩니다.**
→ Etherscan에 뜨지도 않고, 지갑도 읽지 못하고, 거래소도 지원 못합니다.

---

### 그래서 우리는 이렇게 합니다

> **“토큰은 토큰대로 독립적으로 배포하고,
> 게임은 그 토큰의 주소만 연결해서 사용한다.”**

즉,

- **기능별 분리** (Separation of Concerns)
- **호환성 확보**
- **재사용성 확보**
- **보안성과 검증 용이성 확보**

→ 이 네 가지 이유로 인해,
**토큰과 게임은 반드시 분리**되어야 합니다.

---

## 그리고 이때 필요한 게 바로…

**"스마트 컨트랙트가 다른 스마트 컨트랙트의 기능을 호출하는 구조"**입니다.

BaseballGame이 MyToken의 기능을 쓰고 싶을 때,
코드를 복붙하지 않습니다.
**CA 주소만 연결**해서 **인터페이스를 통해 불러오는 방식**을 사용합니다.

---

### 그런데… 이 구조는 단지 기술적인 선택일까요?

아니요.
이건 **이더리움 백서와 태생적 철학**에서부터 이어지는 구조입니다.

---

## 이더리움은 왜 이런 구조를 선호할까요?

이더리움은 단순한 “개발 프레임워크”가 아닙니다.
그 철학은 처음부터 명확했습니다:

> **“모든 코드는 분리되고, 재사용 가능해야 하며,
> 누구나 그 코드를 가져와 자신의 프로젝트에 결합할 수 있어야 한다.”**

—

### ▶ 이더리움 백서 2장: “계약의 일반성”

> “Ethereum is intended to serve as a foundational layer upon which decentralized applications may be built.”
> 즉, 이더리움은 **다양한 계약(컨트랙트)이 서로 독립적이되 연결 가능한 형태**로 구성될 것을 전제로 설계되었습니다.

—

### ▶ 이것이 바로 CA 주소 호출 구조의 탄생 배경입니다

- 컨트랙트는 스스로 독립적이어야 하며,
- 다른 컨트랙트와 연동할 땐 **“주소를 통한 연결”**이 기본입니다.

이건 마치 **모듈화된 리눅스 시스템**처럼,
**필요한 기능만 불러와서, 그 기능을 가진 컨트랙트에 요청을 보내는 구조**입니다.

---

## 그리고 지금 우리가 하는 게 바로 그 구조입니다

### `BaseballGame` 안에서는 이렇게 쓰이죠:

```solidity
IERC20 public token;

constructor(address tokenAddress) {
    token = IERC20(tokenAddress);
}
```

- 이건 “`tokenAddress`에 있는 컨트랙트가 ERC-20 인터페이스를 따른다”는 전제 하에
- `transferFrom`, `transfer`, `approve` 등을 호출할 수 있게 해주는 구조입니다.

---

### 이후에는…

```solidity
token.transferFrom(msg.sender, address(this), ticket);
token.transfer(msg.sender, reword);
```

→ 이런 실제 호출이 가능해지죠.
→ 토큰을 움직이는 기능은 MyToken이 담당하고,
→ **게임 로직은 게임 컨트랙트가 담당**합니다.

---

## 결론: 이 구조가 없으면?

- 토큰 재사용이 불가능하고
- 지갑과 거래소에서 인식되지 않으며
- 보안 검증이 어렵고
- 커뮤니티에 의한 신뢰도 낮고
- 디앱 생태계의 확장성이 무너집니다

---

그래서 우리는 이렇게 구조를 만듭니다:

- **토큰은 MyToken에서 분리해서 만들고**,
- **BaseballGame은 그 주소를 가져와서 `IERC20`을 통해 호출하는 구조로**.

> 이게 바로 이더리움이 추구하는 **탈중앙적이고 결합 가능한 생태계 구조**입니다.

---

이제 여러분은
단순히 컨트랙트 하나 만드는 걸 넘어서,
**“블록체인 생태계에서 확장 가능하고 협업 가능한 구조”**를 만들고 있는 겁니다.

다음 수업에서는
이 연결 구조를 기반으로 실제 `transferFrom`이 언제 호출되고,
`transfer`는 어떤 시점에 실행되는지를
TDD 기반으로 하나씩 검증해볼 차례입니다.
